---
title: Guia de design de índice do SQL Server | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87569754"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="46107-102">Guia de criação de índice do SQL Server</span><span class="sxs-lookup"><span data-stu-id="46107-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="46107-103">Os índices criados inadequadamente e a falta de índices são as principais fontes de gargalos do aplicativo de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="46107-104">A criação eficiente de índices é muito importante para alcançar um bom desempenho de banco de dados e de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="46107-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="46107-105">Este guia de criação de índice do SQL Server contém informações e práticas recomendadas para ajudar você a criar índices efetivos para atender às necessidades de seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="46107-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="46107-106">**Aplica-se a**: a [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] menos que indicado o contrário.</span><span class="sxs-lookup"><span data-stu-id="46107-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="46107-107">Este guia presume que o leitor tenha uma compreensão geral dos tipos de índices disponíveis no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="46107-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="46107-108">Para obter uma descrição geral dos tipos de índices, consulte [Tipos de índice](../relational-databases/indexes/indexes.md).</span><span class="sxs-lookup"><span data-stu-id="46107-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="46107-109">Neste guia</span><span class="sxs-lookup"><span data-stu-id="46107-109">In This Guide</span></span>  

 [<span data-ttu-id="46107-110">Noções básicas de design de índice</span><span class="sxs-lookup"><span data-stu-id="46107-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="46107-111">Diretrizes de design de índice geral</span><span class="sxs-lookup"><span data-stu-id="46107-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="46107-112">Diretrizes de design de índice clusterizado</span><span class="sxs-lookup"><span data-stu-id="46107-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="46107-113">Diretrizes de design de índice não clusterizado</span><span class="sxs-lookup"><span data-stu-id="46107-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="46107-114">Diretrizes de design de índice exclusivo</span><span class="sxs-lookup"><span data-stu-id="46107-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="46107-115">Diretrizes de design de índice filtrado</span><span class="sxs-lookup"><span data-stu-id="46107-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="46107-116">Leitura adicional</span><span class="sxs-lookup"><span data-stu-id="46107-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="46107-117">Noções básicas sobre criação de índice</span><span class="sxs-lookup"><span data-stu-id="46107-117">Index Design Basics</span></span>  

 <span data-ttu-id="46107-118">Um índice é uma estrutura em disco associada a uma tabela ou exibição, que agiliza a recuperação das linhas de uma tabela ou exibição.</span><span class="sxs-lookup"><span data-stu-id="46107-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="46107-119">Um índice contém chaves criadas de uma ou mais colunas da tabela ou exibição.</span><span class="sxs-lookup"><span data-stu-id="46107-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="46107-120">Essas chaves são armazenadas em uma estrutura (árvore B) que habilita o SQL Server a localizar a linha ou as linhas associadas aos valores de chave de forma rápida e eficaz.</span><span class="sxs-lookup"><span data-stu-id="46107-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="46107-121">A seleção dos índices certos para um banco de dados e sua carga de trabalho é um ato de balanceamento complexo entre a velocidade de consulta e o custo de atualização.</span><span class="sxs-lookup"><span data-stu-id="46107-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="46107-122">Índices limitados ou com poucas colunas na chave de índice exigem menos espaço em disco e sobrecarga de manutenção.</span><span class="sxs-lookup"><span data-stu-id="46107-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="46107-123">Por outro lado, índices amplos cobrem mais consultas.</span><span class="sxs-lookup"><span data-stu-id="46107-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="46107-124">Talvez você precise experimentar vários projetos diferentes antes de encontrar o índice mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="46107-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="46107-125">Os índices podem ser adicionados, modificados e descartados sem afetar o esquema de banco de dados ou o design do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="46107-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="46107-126">Portanto, você não deve hesitar em experimentar índices diferentes.</span><span class="sxs-lookup"><span data-stu-id="46107-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="46107-127">O otimizador de consulta no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] escolhe o índice mais eficaz de forma confiável na grande maioria dos casos.</span><span class="sxs-lookup"><span data-stu-id="46107-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="46107-128">Sua estratégia geral de criação de índice deveria fornecer uma variedade de opções de índices para o otimizador de consulta escolher e confiar durante a tomada de decisão correta.</span><span class="sxs-lookup"><span data-stu-id="46107-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="46107-129">Isso reduz o tempo de análise e atinge um bom desempenho em várias situações.</span><span class="sxs-lookup"><span data-stu-id="46107-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="46107-130">Para consultar quais índices o otimizador de consulta usa em uma consulta específica, no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], no menu **Consulta** , selecione **Incluir Plano de Execução Real**.</span><span class="sxs-lookup"><span data-stu-id="46107-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="46107-131">Não equipare sempre o uso de índice com bom desempenho e bom desempenho com uso de índice eficiente.</span><span class="sxs-lookup"><span data-stu-id="46107-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="46107-132">Se o uso de um índice sempre ajudasse a produzir o melhor desempenho, a tarefa do otimizador de consulta seria simples.</span><span class="sxs-lookup"><span data-stu-id="46107-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="46107-133">Na realidade, a escolha incorreta de um índice pode causar um desempenho insatisfatório.</span><span class="sxs-lookup"><span data-stu-id="46107-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="46107-134">Portanto, a tarefa do otimizador de consulta é selecionar um índice ou uma combinação de índices apenas quando isso gerar melhoria de desempenho e evitar a recuperação indexada quando isso atrapalhar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="46107-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="46107-135">Tarefas de criação de índice</span><span class="sxs-lookup"><span data-stu-id="46107-135">Index Design Tasks</span></span>  

 <span data-ttu-id="46107-136">As seguintes tarefas compõem a estratégia recomendada para criação de índices:</span><span class="sxs-lookup"><span data-stu-id="46107-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="46107-137">Entenda as características do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="46107-138">Por exemplo, trata-se de um banco de dados OLTP (transação online) com modificações frequentes de dados, um DSS (sistema de apoio à decisão) ou um banco de dados OLAP de data warehouse que contém principalmente dados somente leitura e deve processar conjuntos de dados muito grandes rapidamente.</span><span class="sxs-lookup"><span data-stu-id="46107-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="46107-139">No [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], o *columnstore xVelocity de memória otimizada* é especialmente apropriado para conjuntos de dados de data warehouse típicos.</span><span class="sxs-lookup"><span data-stu-id="46107-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="46107-140">Os índices columnstore podem transformar a experiência com data warehouse para usuários proporcionando um desempenho mais rápido para consultas de data warehouse comuns, como filtragem, agregação, agrupamento ou consultas de junção em estrela.</span><span class="sxs-lookup"><span data-stu-id="46107-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="46107-141">Para obter mais informações, consulte [índices Columnstore descritos](../relational-databases/indexes/columnstore-indexes-described.md).</span><span class="sxs-lookup"><span data-stu-id="46107-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="46107-142">Entenda as características das consultas mais usadas.</span><span class="sxs-lookup"><span data-stu-id="46107-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="46107-143">Por exemplo, saber que uma consulta usada frequentemente associa duas ou mais tabelas o ajudará a determinar o melhor tipo de índice a ser usado.</span><span class="sxs-lookup"><span data-stu-id="46107-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="46107-144">Entenda as características das colunas usadas nas consultas.</span><span class="sxs-lookup"><span data-stu-id="46107-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="46107-145">Por exemplo, um índice é ideal para colunas que tenham um tipo de dados de inteiro e, também, colunas exclusivas ou não nulas.</span><span class="sxs-lookup"><span data-stu-id="46107-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="46107-146">Para colunas que têm subconjuntos bem definido de dados, é possível usar um índice filtrado no [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e versões posteriores.</span><span class="sxs-lookup"><span data-stu-id="46107-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="46107-147">Para obter mais informações, consulte [Diretrizes de criação de índice filtrado](#Filtered) neste guia.</span><span class="sxs-lookup"><span data-stu-id="46107-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="46107-148">Determine quais opções de índice poderiam aumentar o desempenho na criação ou manutenção do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="46107-149">Por exemplo, a criação de um índice clusterizado em uma tabela grande existente se beneficiaria da opção de índice ONLINE.</span><span class="sxs-lookup"><span data-stu-id="46107-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="46107-150">A opção ONLINE permite que atividade simultânea nos dados subjacentes continue enquanto o índice está sendo criado ou reconstruído.</span><span class="sxs-lookup"><span data-stu-id="46107-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="46107-151">Para obter mais informações sobre opções de índice, consulte [Definir opções de índice](../relational-databases/indexes/set-index-options.md).</span><span class="sxs-lookup"><span data-stu-id="46107-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="46107-152">Determine o melhor local de armazenamento para o índice.</span><span class="sxs-lookup"><span data-stu-id="46107-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="46107-153">Um índice não clusterizado pode ser armazenado no mesmo grupo de arquivos que a tabela subjacente ou em um grupo de arquivos diferente.</span><span class="sxs-lookup"><span data-stu-id="46107-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="46107-154">O local de armazenamento de índices pode melhorar o desempenho de consulta aumentando desempenho de E/S do disco.</span><span class="sxs-lookup"><span data-stu-id="46107-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="46107-155">Por exemplo, o armazenamento de um índice não clusterizado em um grupo de arquivos que está em um disco diferente do grupo de arquivos de tabela pode melhorar o desempenho porque vários discos podem ser lidos ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="46107-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="46107-156">Alternativamente, os índices clusterizados e não clusterizados podem usar um esquema de partição em vários grupos de arquivos.</span><span class="sxs-lookup"><span data-stu-id="46107-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="46107-157">O particionamento facilita o gerenciamento de tabelas ou índices grandes permitindo o acesso ou o gerenciamento de subconjuntos de dados de forma rápida e eficaz, enquanto mantém a integridade geral da coleção.</span><span class="sxs-lookup"><span data-stu-id="46107-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="46107-158">Para saber mais, confira [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="46107-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="46107-159">Quando você pensar em particionamento, determine se o índice deve ser alinhado; isto é, particionado essencialmente da mesma maneira que a tabela ou particionado de forma independente.</span><span class="sxs-lookup"><span data-stu-id="46107-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="46107-160">Diretrizes para criação de índice geral</span><span class="sxs-lookup"><span data-stu-id="46107-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="46107-161">Administradores de banco de dados experientes podem projetar um bom conjunto de índices, mas essa tarefa é muito complexa, demorada e propensa a erros até mesmo para bancos de dados e cargas de trabalho moderadamente complexos.</span><span class="sxs-lookup"><span data-stu-id="46107-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="46107-162">Compreender as características de seu banco de dados, consultas e colunas de dados pode lhe ajudar a projetar índices melhores.</span><span class="sxs-lookup"><span data-stu-id="46107-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="46107-163">Considerações sobre banco de dados</span><span class="sxs-lookup"><span data-stu-id="46107-163">Database Considerations</span></span>  

 <span data-ttu-id="46107-164">Quando você projeta um índice, considere as seguintes diretrizes para banco de dados:</span><span class="sxs-lookup"><span data-stu-id="46107-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="46107-165">Números grandes de índices em uma tabela afetam o desempenho das instruções INSERT, UPDATE, DELETE e MERGE porque todos os índices precisam ser ajustados adequadamente à medida que os dados são alterados em uma tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="46107-166">Por exemplo, se uma coluna for usada em vários índices e você executar uma instrução UPDATE que modifica os dados dessa coluna, cada índice que contém essa coluna deverá ser atualizado, bem como a coluna na tabela base subjacente (heap ou índice clusterizado).</span><span class="sxs-lookup"><span data-stu-id="46107-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="46107-167">Evite tabelas fortemente atualizadas em cima desindexações e mantenha os índices estreitos, ou seja, com o mínimo de colunas possível.</span><span class="sxs-lookup"><span data-stu-id="46107-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="46107-168">Use muitos índices para aperfeiçoar o desempenho da consulta em tabelas com baixos requisitos de atualização, mas com grandes volumes de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="46107-169">Grandes números de índices podem ajudar o desempenho de consultas que não modificam dados, como instruções SELECT, porque o otimizador de consulta tem mais índices para escolher para determinar o método de acesso mais rápido.</span><span class="sxs-lookup"><span data-stu-id="46107-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="46107-170">Indexar tabelas pequenas pode não ser bom porque pode fazer o otimizador de consulta levar mais tempo para atravessar o índice procurando dados do que executar uma simples varredura de tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="46107-171">Portanto, os índices em tabelas pequenas talvez nunca sejam usados, mas ainda devem ser mantidos como dados nas alterações de tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="46107-172">Índices em exibições pode prover ganhos de desempenho significantes quando a exibição contiver agregações, junções de tabela ou uma combinação de agregações e junções.</span><span class="sxs-lookup"><span data-stu-id="46107-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="46107-173">A exibição não precisa estar explicitamente referenciada na consulta para o otimizador de consulta usá-la.</span><span class="sxs-lookup"><span data-stu-id="46107-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="46107-174">Use o Orientador de Otimização do Mecanismo de Banco de Dados para analisar seu banco de dados e fazer recomendações de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="46107-175">Para obter mais informações, consulte [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span><span class="sxs-lookup"><span data-stu-id="46107-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="46107-176">Considerações sobre consultas</span><span class="sxs-lookup"><span data-stu-id="46107-176">Query Considerations</span></span>  

 <span data-ttu-id="46107-177">Quando você projeta um índice, considere as seguintes diretrizes para consultas:</span><span class="sxs-lookup"><span data-stu-id="46107-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="46107-178">Crie índices não clusterizados nas colunas frequentemente usadas em predicados e condições de junção em consultas.</span><span class="sxs-lookup"><span data-stu-id="46107-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="46107-179">No entanto, evite adicionar colunas desnecessárias.</span><span class="sxs-lookup"><span data-stu-id="46107-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="46107-180">Acrescentar muitas colunas de índice pode afetar adversamente o espaço em disco e o desempenho de manutenção de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="46107-181">Cobrindo índices pode melhorar desempenho de consulta porque todos os dados precisaram satisfazer os requisitos da consulta existe dentro do próprio índice.</span><span class="sxs-lookup"><span data-stu-id="46107-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="46107-182">Ou seja, apenas as páginas de índice, e não as páginas de dados da tabela ou do índice clusterizado, são necessárias para recuperar os dados solicitados, portanto reduzindo as operações de E/S gerais do disco.</span><span class="sxs-lookup"><span data-stu-id="46107-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="46107-183">Por exemplo, uma consulta de colunas **a** e **b** em uma tabela que tem um índice composto criado em colunas **a**, **b**e **c** pode recuperar os dados especificados somente do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="46107-184">Escreva consultas que insiram ou modifiquem o máximo de filas possível em uma única instrução, em vez de usar consultas múltiplas para atualizar essas mesmas filas.</span><span class="sxs-lookup"><span data-stu-id="46107-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="46107-185">Ao usar apenas uma instrução, pode-se explorar uma manutenção otimizada do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="46107-186">Avalie o tipo da consulta e como as colunas são usadas na consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="46107-187">Por exemplo, uma coluna usada em uma consulta de correspondência exata seria uma boa candidata para um índice clusterizado ou não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="46107-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="46107-188">Considerações sobre colunas</span><span class="sxs-lookup"><span data-stu-id="46107-188">Column Considerations</span></span>  

 <span data-ttu-id="46107-189">Quando você projeta um índice, considere as seguintes diretrizes para as colunas:</span><span class="sxs-lookup"><span data-stu-id="46107-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="46107-190">Mantenha o comprimento da chave de índice curto para os índices clusterizados.</span><span class="sxs-lookup"><span data-stu-id="46107-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="46107-191">Além disso, os índices clusterizados se beneficiam de serem criados em colunas exclusivas ou não nulas.</span><span class="sxs-lookup"><span data-stu-id="46107-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="46107-192">As colunas que forem do tipo de dados `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, e `varbinary(max)` não podem ser especificadas como colunas de chave de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="46107-193">Entretanto, os tipos de dados, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, e `xml` podem participar em um índice não clusterizados como colunas de índice não chave.</span><span class="sxs-lookup"><span data-stu-id="46107-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="46107-194">Para obter mais informações, consulte a seção ['Índice com colunas incluídas](#Included_Columns)' neste guia.</span><span class="sxs-lookup"><span data-stu-id="46107-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="46107-195">Um tipo de dados `xml` só pode ser uma coluna de chave em um índice XML.</span><span class="sxs-lookup"><span data-stu-id="46107-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="46107-196">Para obter mais informações, veja [Índices XML &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span><span class="sxs-lookup"><span data-stu-id="46107-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="46107-197">O SQL Server 2012 SP1 apresenta um novo tipo de índice XML conhecido como um índice XML seletivo.</span><span class="sxs-lookup"><span data-stu-id="46107-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="46107-198">Esse novo índice pode melhorar o desempenho da consulta dos dados armazenados como XML no SQL Server, permitir uma indexação muito mais rápida de cargas de trabalho de dados XML grandes e melhorar a escalabilidade ao reduzir os custos de armazenamento do próprio índice.</span><span class="sxs-lookup"><span data-stu-id="46107-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="46107-199">Para obter mais informações, consulte [Índices XML seletivos &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span><span class="sxs-lookup"><span data-stu-id="46107-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="46107-200">Examine a singularidade da coluna.</span><span class="sxs-lookup"><span data-stu-id="46107-200">Examine column uniqueness.</span></span> <span data-ttu-id="46107-201">Um índice exclusivo em vez de um índice não exclusivo na mesma combinação de colunas, provê informações adicional para o otimizador de consulta, o que torna o índice mais útil.</span><span class="sxs-lookup"><span data-stu-id="46107-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="46107-202">Para obter mais informações, consulte [Diretrizes de design de índice exclusivo](#Unique) neste guia.</span><span class="sxs-lookup"><span data-stu-id="46107-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="46107-203">Examine a distribuição de dados na coluna.</span><span class="sxs-lookup"><span data-stu-id="46107-203">Examine data distribution in the column.</span></span> <span data-ttu-id="46107-204">Frequentemente, uma consulta longa é causada ao se indexar uma coluna com poucos valores exclusivos, ou ao executar uma junção em tal coluna.</span><span class="sxs-lookup"><span data-stu-id="46107-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="46107-205">Isto é um problema fundamental com dados e consulta, e geralmente não pode ser resolvido sem identificar esta situação.</span><span class="sxs-lookup"><span data-stu-id="46107-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="46107-206">Por exemplo, uma lista telefônica física ordenada alfabeticamente pelo último nome não será rápida em localizar uma pessoa, se todas as pessoas na cidade tiverem nomes de Smith ou Jones.</span><span class="sxs-lookup"><span data-stu-id="46107-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="46107-207">Para obter mais informações sobre distribuição de dados, consulte [Statistics](../relational-databases/statistics/statistics.md).</span><span class="sxs-lookup"><span data-stu-id="46107-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="46107-208">Considere o uso de índices filtrados em colunas com subconjuntos bem definidos, por exemplo, colunas esparsas, colunas com grande a maioria dos valores NULL, colunas com categorias de valores e colunas com intervalos diferentes de valores.</span><span class="sxs-lookup"><span data-stu-id="46107-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="46107-209">Um índice filtrado bem projetado pode melhorar o desempenho da consulta e reduzir os custos de manutenção de índice e de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="46107-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="46107-210">Considere a ordem das colunas se o índice contiver colunas múltiplas.</span><span class="sxs-lookup"><span data-stu-id="46107-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="46107-211">A coluna que é usada na cláusula WHERE em um critério de consulta igual a (=), maior que (>), menor que (>) ou BETWEEN, ou que participa em uma junção, deve ser posicionada primeiro.</span><span class="sxs-lookup"><span data-stu-id="46107-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="46107-212">Colunas adicionais devem ser ordenadas com base em seu nível de distinção, ou seja, do mais distinto ao menos distinto.</span><span class="sxs-lookup"><span data-stu-id="46107-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="46107-213">Por exemplo, se o índice for definido como `LastName`, `FirstName` o índice será útil quando o critério de consulta for `WHERE LastName = 'Smith'` ou `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span><span class="sxs-lookup"><span data-stu-id="46107-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="46107-214">Porém, o otimizador de consulta não usaria o índice para uma consulta que tivesse pesquisado apenas em `FirstName (WHERE FirstName = 'Jane')`.</span><span class="sxs-lookup"><span data-stu-id="46107-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="46107-215">Considere indexar as colunas computadas.</span><span class="sxs-lookup"><span data-stu-id="46107-215">Consider indexing computed columns.</span></span> <span data-ttu-id="46107-216">Para obter mais informações, consulte [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="46107-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="46107-217">Características do índice</span><span class="sxs-lookup"><span data-stu-id="46107-217">Index Characteristics</span></span>  

 <span data-ttu-id="46107-218">Depois de ter determinado que um índice é apropriado para uma consulta, você pode selecionar o tipo de índice que melhor se adéque a sua situação.</span><span class="sxs-lookup"><span data-stu-id="46107-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="46107-219">Características de índice incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="46107-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="46107-220">Clusterizado X não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="46107-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="46107-221">Exclusivo X não exclusivo</span><span class="sxs-lookup"><span data-stu-id="46107-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="46107-222">Única coluna X multicoluna</span><span class="sxs-lookup"><span data-stu-id="46107-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="46107-223">Ordem crescente ou decrescente em colunas no índice</span><span class="sxs-lookup"><span data-stu-id="46107-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="46107-224">Tabela completa versus filtrada para índices não clusterizados</span><span class="sxs-lookup"><span data-stu-id="46107-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="46107-225">Você também pode personalizar as características de armazenamento inicial do índice para aperfeiçoar seu desempenho ou manutenção definindo uma opção como FILLFACTOR.</span><span class="sxs-lookup"><span data-stu-id="46107-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="46107-226">Além disso, você pode determinar o local de armazenamento de índice usando grupos de arquivos ou esquemas de partição para aperfeiçoar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="46107-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="46107-227">Posição do índice em grupos de arquivos ou esquemas de partição</span><span class="sxs-lookup"><span data-stu-id="46107-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="46107-228">À medida que desenvolve sua estratégia de design de índices, considere a colocação dos índices nos grupos de arquivos associados ao banco de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="46107-229">A seleção cuidadosa do grupo de arquivos ou esquema de partição pode melhorar o desempenho da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="46107-230">Por padrão, os índices são armazenados no mesmo grupo de arquivos que a tabela base na qual o índice é criado.</span><span class="sxs-lookup"><span data-stu-id="46107-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="46107-231">Um índice cluster não particionado e a tabela base sempre residem no mesmo grupo de arquivos.</span><span class="sxs-lookup"><span data-stu-id="46107-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="46107-232">No entanto, você pode fazer o seguinte:</span><span class="sxs-lookup"><span data-stu-id="46107-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="46107-233">Crie índices não clusterizados em um grupo de arquivos diferente do grupo de arquivos da tabela base ou do índice clusterizado.</span><span class="sxs-lookup"><span data-stu-id="46107-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="46107-234">Particione índices cluster e não cluster para que ocupem vários grupos de arquivos.</span><span class="sxs-lookup"><span data-stu-id="46107-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="46107-235">Mova uma tabela de um grupo de arquivos para outro descartando o índice cluster e especificando um novo grupo de arquivos ou esquema de partição na cláusula MOVE TO da instrução DROP INDEX ou usando a instrução CREATE INDEX com a cláusula DROP_EXISTING.</span><span class="sxs-lookup"><span data-stu-id="46107-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="46107-236">Ao criar o índice não cluster em um grupo de arquivos diferente, você pode obter ganhos de desempenho se os grupos de arquivos estiverem usando unidades físicas diferentes com seus próprios controladores.</span><span class="sxs-lookup"><span data-stu-id="46107-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="46107-237">As informações de índices e de dados podem ser lidas em paralelo pelas várias cabeças de disco.</span><span class="sxs-lookup"><span data-stu-id="46107-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="46107-238">Por exemplo, se `Table_A` no grupo de arquivos `f1` e `Index_A` no grupo de arquivos `f2` estiverem ambos sendo usados pela mesma consulta, podem-se obter ganhos de desempenho porque os dois grupos de arquivos estão sendo completamente usados sem contenção.</span><span class="sxs-lookup"><span data-stu-id="46107-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="46107-239">Porém, se `Table_A` for verificado pela consulta, mas `Index_A` não for referenciado, apenas o grupo de arquivos `f1` será usado.</span><span class="sxs-lookup"><span data-stu-id="46107-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="46107-240">Isso não cria nenhum ganho de desempenho.</span><span class="sxs-lookup"><span data-stu-id="46107-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="46107-241">Como você não pode prever que tipo de acesso acontecerá e quando ocorrerá, pode ser preferível distribuir suas tabelas e índices por todos os grupos de arquivos.</span><span class="sxs-lookup"><span data-stu-id="46107-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="46107-242">Isso garantirá que todos os discos estejam sendo acessados, pois todos os dados e índices estarão distribuídos igualmente por todos os discos, independentemente da maneira como os dados sejam acessados.</span><span class="sxs-lookup"><span data-stu-id="46107-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="46107-243">Essa também é uma abordagem mais simples para os administradores do sistema.</span><span class="sxs-lookup"><span data-stu-id="46107-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="46107-244">Partições em vários grupos de arquivos</span><span class="sxs-lookup"><span data-stu-id="46107-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="46107-245">Você também pode considerar o particionamento de índices cluster e não cluster em vários grupos de arquivos.</span><span class="sxs-lookup"><span data-stu-id="46107-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="46107-246">Os índices particionados são particionados horizontalmente, ou por linha, com base na função de uma partição.</span><span class="sxs-lookup"><span data-stu-id="46107-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="46107-247">A função da partição define como cada linha é mapeada para um conjunto de partições, com base nos valores de certas colunas, chamadas colunas de particionamento.</span><span class="sxs-lookup"><span data-stu-id="46107-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="46107-248">Um esquema de partição especifica o mapeamento das partições para um conjunto de grupos de arquivos.</span><span class="sxs-lookup"><span data-stu-id="46107-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="46107-249">O particionamento de um índice pode proporcionar os seguintes benefícios:</span><span class="sxs-lookup"><span data-stu-id="46107-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="46107-250">Proporcionar sistemas evolutivos que tornam grandes índices mais gerenciáveis.</span><span class="sxs-lookup"><span data-stu-id="46107-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="46107-251">Sistemas OLTP, por exemplo, podem implementar aplicativos que reconhecem partição que tratam de índices grandes.</span><span class="sxs-lookup"><span data-stu-id="46107-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="46107-252">Fazer as consultas serem executadas de maneira mais rápida e eficiente.</span><span class="sxs-lookup"><span data-stu-id="46107-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="46107-253">Quando as consultas acessarem várias partições de um índice, o otimizador de consulta pode processar partições individuais ao mesmo tempo e pode excluir partições que não sejam afetadas pela consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="46107-254">Para saber mais, confira [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="46107-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="46107-255">Diretrizes de criação de ordem de classificação de índice</span><span class="sxs-lookup"><span data-stu-id="46107-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="46107-256">Ao definir índices, confirme se os dados da coluna de chave de índice deverão ser armazenados em ordem crescente ou decrescente.</span><span class="sxs-lookup"><span data-stu-id="46107-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="46107-257">Ordem crescente é o padrão e assegura a compatibilidade com as versões anteriores do [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="46107-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="46107-258">A sintaxe das instruções CREATE INDEX, CREATE TABLE e ALTER TABLE dá suporte às palavras-chave ASC (crescente) e DESC (decrescente) em colunas individuais de índices e restrições.</span><span class="sxs-lookup"><span data-stu-id="46107-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="46107-259">A especificação da ordem de armazenamento dos valores de chave em um índice é útil quando as consultas que fazem referência à tabela contêm cláusulas ORDER BY que especificam direcionamentos diferentes para a coluna de chave ou as colunas daquele índice.</span><span class="sxs-lookup"><span data-stu-id="46107-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="46107-260">Nesses casos, o índice pode eliminar a necessidade de um operador SORT no plano de consulta, o que torna a consulta mais eficaz.</span><span class="sxs-lookup"><span data-stu-id="46107-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="46107-261">Por exemplo, os compradores do departamento de compras da [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] devem avaliar a qualidade dos produtos que adquirem de fornecedores.</span><span class="sxs-lookup"><span data-stu-id="46107-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="46107-262">Os compradores estão mais interessados em localizar os produtos enviados por esses fornecedores, e que têm alta taxa de rejeição.</span><span class="sxs-lookup"><span data-stu-id="46107-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="46107-263">Como demonstrado pela consulta a seguir, recuperar os dados para atender esses critérios requer que a coluna `RejectedQty` da tabela `Purchasing.PurchaseOrderDetail` seja classificada em ordem decrescente (do maior para o menor) e que a coluna `ProductID` seja classificada em ordem crescente (do menor para o maior).</span><span class="sxs-lookup"><span data-stu-id="46107-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="46107-264">O plano de execução a seguir, dessa consulta, mostra que o otimizador de consultas usou um operador SORT para retornar o conjunto de resultados na ordem especificada pela cláusula ORDER BY.</span><span class="sxs-lookup"><span data-stu-id="46107-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="46107-265">![O plano de execução mostra um operador SORT usado.](media/indexsort1.gif "O plano de execução mostra um operador SORT usado.")</span><span class="sxs-lookup"><span data-stu-id="46107-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="46107-266">Se um índice for criado com colunas de chave correspondentes às da cláusula ORDER BY da consulta, o operador SORT poderá ser eliminado do plano de consulta, e este se tornará mais eficaz.</span><span class="sxs-lookup"><span data-stu-id="46107-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="46107-267">Depois que a consulta for novamente executada, o plano de execução a seguir mostra que o operador SORT foi eliminado e que o índice não clusterizado recentemente criado é utilizado.</span><span class="sxs-lookup"><span data-stu-id="46107-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="46107-268">![O plano de execução mostra um operador SORT não usado](media/insertsort2.gif "O plano de execução mostra um operador SORT não usado")</span><span class="sxs-lookup"><span data-stu-id="46107-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="46107-269">O [!INCLUDE[ssDE](../includes/ssde-md.md)] pode se mover para qualquer direção de forma igualmente eficaz.</span><span class="sxs-lookup"><span data-stu-id="46107-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="46107-270">Um índice definido como `(RejectedQty DESC, ProductID ASC)` ainda pode ser usado em uma consulta na qual a direção de classificação das colunas da cláusula ORDER BY é invertida.</span><span class="sxs-lookup"><span data-stu-id="46107-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="46107-271">Por exemplo, uma consulta com a cláusula ORDER BY `ORDER BY RejectedQty ASC, ProductID DESC` pode utilizar o índice.</span><span class="sxs-lookup"><span data-stu-id="46107-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="46107-272">A ordem de classificação só pode ser especificada para colunas de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="46107-273">A exibição de catálogo [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) e a função INDEXKEY_PROPERTY relatam se a coluna de índice está armazenada em ordem crescente ou decrescente.</span><span class="sxs-lookup"><span data-stu-id="46107-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="46107-274">![Ícone de seta usado com o link voltar ao início](media/uparrow16x16.gif "Ícone de seta usado com o link Voltar ao Início") [neste guia](#Top)</span><span class="sxs-lookup"><span data-stu-id="46107-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="46107-275">Diretrizes de design de índices clusterizados</span><span class="sxs-lookup"><span data-stu-id="46107-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="46107-276">Os índices clusterizados classificam e armazenam as linhas de dados da tabela com base em seus valores de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="46107-277">Pode haver apenas um índice clusterizado por tabela, porque as próprias linhas de dados podem ser classificadas apenas em uma única ordem.</span><span class="sxs-lookup"><span data-stu-id="46107-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="46107-278">Com poucas exceções, toda tabela deveria ter um índice clusterizado definido na coluna ou colunas, o qual proporciona o seguinte:</span><span class="sxs-lookup"><span data-stu-id="46107-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="46107-279">Pode ser usado para consultas frequentemente usadas.</span><span class="sxs-lookup"><span data-stu-id="46107-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="46107-280">Oferece um alto grau de singularidade.</span><span class="sxs-lookup"><span data-stu-id="46107-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="46107-281">Quando você cria uma restrição PRIMARY KEY, um índice exclusivo na coluna, ou colunas, é criado automaticamente.</span><span class="sxs-lookup"><span data-stu-id="46107-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="46107-282">Por padrão, esse índice é cluster. Porém, você pode especificar um índice não clusterizado ao criar a restrição.</span><span class="sxs-lookup"><span data-stu-id="46107-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="46107-283">Pode ser usado em consultas de intervalo.</span><span class="sxs-lookup"><span data-stu-id="46107-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="46107-284">Se o índice clusterizado não for criado com a propriedade UNIQUE, o [!INCLUDE[ssDE](../includes/ssde-md.md)] adicionará automaticamente uma coluna uniquifier de 4 bytes à tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="46107-285">Quando necessário, o [!INCLUDE[ssDE](../includes/ssde-md.md)] adiciona automaticamente um valor uniquifier a uma linha para tornar cada chave exclusiva.</span><span class="sxs-lookup"><span data-stu-id="46107-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="46107-286">Essa coluna e seus valores são usados internamente e não podem ser vistos ou avaliados por usuários.</span><span class="sxs-lookup"><span data-stu-id="46107-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="46107-287">Arquitetura de índice clusterizado</span><span class="sxs-lookup"><span data-stu-id="46107-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="46107-288">No [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], os índices são organizados como árvores B.</span><span class="sxs-lookup"><span data-stu-id="46107-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="46107-289">Cada página em uma árvore B de índice é chamada de nó do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="46107-290">O nó superior da árvore B é chamado de nó raiz.</span><span class="sxs-lookup"><span data-stu-id="46107-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="46107-291">Os nós inferiores no índice são chamados de nós folha.</span><span class="sxs-lookup"><span data-stu-id="46107-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="46107-292">Quaisquer níveis de índice entre os nós raiz e folha são coletivamente conhecidos como níveis intermediários.</span><span class="sxs-lookup"><span data-stu-id="46107-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="46107-293">Em um índice clusterizado, os nós folha contêm as páginas de dados da tabela subjacente.</span><span class="sxs-lookup"><span data-stu-id="46107-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="46107-294">Os nós de nível intermediário e raiz contêm páginas de índice com linhas de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="46107-295">Cada linha de índice contém um valor de chave e um ponteiro para uma página de nível de intermediário na árvore B ou uma linha de dados no nível folha do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="46107-296">As páginas de cada nível do índice são vinculadas a uma lista vinculada duas vezes.</span><span class="sxs-lookup"><span data-stu-id="46107-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="46107-297">Índices clusterizados têm uma linha em [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), com **index_id** = 1 para cada partição usada pelo índice.</span><span class="sxs-lookup"><span data-stu-id="46107-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="46107-298">Por padrão, um índice clusterizado tem um único particionamento.</span><span class="sxs-lookup"><span data-stu-id="46107-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="46107-299">Quando um índice clusterizado tem particionamentos múltiplos, cada particionamento tem uma estrutura de árvore B que contém os dados para aquele particionamento específico.</span><span class="sxs-lookup"><span data-stu-id="46107-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="46107-300">Por exemplo, se um índice clusterizado tiver quatro particionamentos, haverá quatro estruturas de árvore B; uma em cada particionamento.</span><span class="sxs-lookup"><span data-stu-id="46107-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="46107-301">Dependendo dos tipos de dados no índice clusterizado, cada estrutura de índice clusterizado terá uma ou mais unidades de alocação para armazenar e gerenciar os dados de um particionamento específico.</span><span class="sxs-lookup"><span data-stu-id="46107-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="46107-302">No mínimo, cada índice clusterizado terá uma unidade de alocação IN_ROW_DATA por particionamento.</span><span class="sxs-lookup"><span data-stu-id="46107-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="46107-303">O índice clusterizado também terá uma unidade de alocação LOB_DATA por particionamento se contiver colunas LOB (objetos grandes).</span><span class="sxs-lookup"><span data-stu-id="46107-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="46107-304">Também terá uma unidade de alocação ROW_OVERFLOW_DATA por particionamento se tiver colunas de comprimento variável excedendo o limite de tamanho de linha de 8.060 bytes.</span><span class="sxs-lookup"><span data-stu-id="46107-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="46107-305">As páginas da cadeia de dados e as linhas são classificadas pelo valor da chave de índice clusterizado.</span><span class="sxs-lookup"><span data-stu-id="46107-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="46107-306">Todas as inserções são feitas no ponto em que o valor de chave da linha inserida se ajusta à sequência de classificação entre as linhas existentes.</span><span class="sxs-lookup"><span data-stu-id="46107-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="46107-307">Esta ilustração mostra a estrutura de um índice clusterizado em um único particionamento.</span><span class="sxs-lookup"><span data-stu-id="46107-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="46107-308">![Níveis de um índice clusterizado](media/bokind2.gif "Níveis de um índice clusterizado")</span><span class="sxs-lookup"><span data-stu-id="46107-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="46107-309">Considerações sobre consultas</span><span class="sxs-lookup"><span data-stu-id="46107-309">Query Considerations</span></span>  

 <span data-ttu-id="46107-310">Antes de criar índices clusterizados, entenda como seus dados serão acessados.</span><span class="sxs-lookup"><span data-stu-id="46107-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="46107-311">Considere utilizar um índice clusterizado para consultas que façam o seguinte:</span><span class="sxs-lookup"><span data-stu-id="46107-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="46107-312">Retornam um intervalo de valores usando os operadores como BETWEEN, >, >=, < e <=.</span><span class="sxs-lookup"><span data-stu-id="46107-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="46107-313">Depois que a linha com o primeiro valor for encontrada usando o índice cluster, garante-se que as linhas com valores indexados subsequentes estejam fisicamente adjacentes.</span><span class="sxs-lookup"><span data-stu-id="46107-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="46107-314">Por exemplo, se uma consulta recuperar registros entre um intervalo de números de ordem de vendas, um índice clusterizado na coluna `SalesOrderNumber` poderá localizar rapidamente a linha que contém o número de ordem de vendas inicial e em seguida recuperará todas as linhas sucessivas na tabela, até que o último número de ordem de vendas seja alcançado.</span><span class="sxs-lookup"><span data-stu-id="46107-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="46107-315">Retornam grandes conjuntos de resultados.</span><span class="sxs-lookup"><span data-stu-id="46107-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="46107-316">Use cláusulas JOIN. Normalmente elas são colunas de chave estrangeira.</span><span class="sxs-lookup"><span data-stu-id="46107-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="46107-317">Use cláusulas ORDER BY ou GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="46107-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="46107-318">Um índice nas colunas especificadas na cláusula ORDER BY ou GROUP BY pode eliminar a necessidade de o [!INCLUDE[ssDE](../includes/ssde-md.md)] classificar os dados, pois as linhas já estão classificadas.</span><span class="sxs-lookup"><span data-stu-id="46107-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="46107-319">Isso melhora o desempenho da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="46107-320">Considerações sobre colunas</span><span class="sxs-lookup"><span data-stu-id="46107-320">Column Considerations</span></span>  

 <span data-ttu-id="46107-321">Geralmente, você deve definir a chave de índice clusterizado com o menor número de colunas possível.</span><span class="sxs-lookup"><span data-stu-id="46107-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="46107-322">Considere colunas que tenham um ou mais dos seguintes atributos:</span><span class="sxs-lookup"><span data-stu-id="46107-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="46107-323">Sejam exclusivas ou contenham muitos valores distintos</span><span class="sxs-lookup"><span data-stu-id="46107-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="46107-324">Por exemplo, uma ID de funcionário identifica os funcionários de maneira exclusiva.</span><span class="sxs-lookup"><span data-stu-id="46107-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="46107-325">Um índice clusterizado ou restrição PRIMARY KEY na coluna `EmployeeID` melhoraria o desempenho de consultas que pesquisam informações de funcionário com base no número de ID do funcionário.</span><span class="sxs-lookup"><span data-stu-id="46107-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="46107-326">Como alternativa, um índice clusterizado poderia ser criado em `LastName`, `FirstName`, `MiddleName` porque os registros dos funcionários são agrupados e consultados frequentemente dessa maneira e a combinação dessas colunas ainda ofereceria um grau alto de diferença.</span><span class="sxs-lookup"><span data-stu-id="46107-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="46107-327">Sejam acessadas sequencialmente</span><span class="sxs-lookup"><span data-stu-id="46107-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="46107-328">Por exemplo, um ID de produto identifica produtos de maneira exclusiva na tabela `Production.Product` no banco de dados [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="46107-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="46107-329">Consultas nas quais uma pesquisa sequencial seja especificada, tais como `WHERE ProductID BETWEEN 980 and 999`, se beneficiariam de um índice clusterizado em `ProductID`.</span><span class="sxs-lookup"><span data-stu-id="46107-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="46107-330">Isso ocorre porque as linhas seriam armazenadas em ordem classificada nessa coluna de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="46107-331">Definido como IDENTITY.</span><span class="sxs-lookup"><span data-stu-id="46107-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="46107-332">Frequentemente usado para classificar os dados recuperados de uma tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="46107-333">Pode ser uma boa ideia agrupar, ou seja, classificar fisicamente, a tabela nessa coluna para economizar o custo de uma operação de classificação toda vez que a coluna for consultada.</span><span class="sxs-lookup"><span data-stu-id="46107-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="46107-334">Índices clusterizados não são uma boa escolha para os seguintes atributos:</span><span class="sxs-lookup"><span data-stu-id="46107-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="46107-335">Colunas que sofrem mudanças frequentes</span><span class="sxs-lookup"><span data-stu-id="46107-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="46107-336">Isso faz com que toda a linha seja movida, porque o [!INCLUDE[ssDE](../includes/ssde-md.md)] deve manter os valores de dados de uma linha em ordem física.</span><span class="sxs-lookup"><span data-stu-id="46107-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="46107-337">Essa é uma consideração importante em sistemas de processamento de transações de alto volume nos quais os dados sejam normalmente voláteis.</span><span class="sxs-lookup"><span data-stu-id="46107-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="46107-338">Chaves largas</span><span class="sxs-lookup"><span data-stu-id="46107-338">Wide keys</span></span>  
  
     <span data-ttu-id="46107-339">Chaves largas são uma combinação de várias colunas ou de várias colunas de tamanho grande.</span><span class="sxs-lookup"><span data-stu-id="46107-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="46107-340">Os valores de chave do índice clusterizado são usados por todos os índices não clusterizados como chaves de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="46107-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="46107-341">Qualquer índice não clusterizado definido na mesma tabela será significativamente maior porque as entradas de índice não clusterizado contêm a chave de cluster e também as colunas de chave definidas para aquele índice não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="46107-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="46107-342">![Ícone de seta usado com o link voltar ao início](media/uparrow16x16.gif "Ícone de seta usado com o link Voltar ao Início") [neste guia](#Top)</span><span class="sxs-lookup"><span data-stu-id="46107-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="46107-343">Diretrizes de criação de índice não clusterizado</span><span class="sxs-lookup"><span data-stu-id="46107-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="46107-344">Um índice não clusterizado contém os valores de chave do índice e os localizadores de linha que apontam para o local de armazenamento dos dados da tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="46107-345">Você pode criar vários índices não clusterizados em uma tabela ou exibição indexada.</span><span class="sxs-lookup"><span data-stu-id="46107-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="46107-346">Em geral, os índices não clusterizados devem ser criados para aprimorar o desempenho de consultas utilizadas com frequência que não são cobertas pelo índice clusterizado.</span><span class="sxs-lookup"><span data-stu-id="46107-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="46107-347">Semelhante à maneira como o índice de um livro é usado, o otimizador de consulta procura um valor de dados pesquisando o índice não clusterizado para encontrar o local do valor de dados na tabela e, depois, recupera os dados diretamente daquele local.</span><span class="sxs-lookup"><span data-stu-id="46107-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="46107-348">Isso faz com que os índices não clusterizados sejam a opção ideal para consultas de correspondência exata, uma vez que o índice contém entradas que descrevem o local preciso na tabela dos valores de dados pesquisados pelas consultas.</span><span class="sxs-lookup"><span data-stu-id="46107-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="46107-349">Por exemplo, para consultar a tabela `HumanResources. Employee` de todos os funcionários que reportam para um determinado gerente, o otimizador de consulta pode usar o índice não clusterizado `IX_Employee_ManagerID`, que tem `ManagerID` como sua coluna de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="46107-350">O otimizador de consulta pode localizar rapidamente todas as entradas no índice que correspondem ao `ManagerID`especificado.</span><span class="sxs-lookup"><span data-stu-id="46107-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="46107-351">Cada entrada do índice aponta para a página e a linha exatas na tabela ou índice clusterizado, em que os dados correspondentes podem ser localizados.</span><span class="sxs-lookup"><span data-stu-id="46107-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="46107-352">Depois que o otimizador de consulta localizar todas as entradas no índice, poderá ir diretamente para a página e a linha exatas e recuperar os dados.</span><span class="sxs-lookup"><span data-stu-id="46107-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="46107-353">Arquitetura de índice não clusterizado</span><span class="sxs-lookup"><span data-stu-id="46107-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="46107-354">Os índices não clusterizados têm a mesma estrutura de árvore B que os índices clusterizados, com exceção das seguintes diferenças significativas:</span><span class="sxs-lookup"><span data-stu-id="46107-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="46107-355">As linhas de dados da tabela subjacente não são classificadas nem armazenadas em ordem com base nas suas chaves não clusterizadas.</span><span class="sxs-lookup"><span data-stu-id="46107-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="46107-356">A camada de folha de um índice não clusterizado é constituída de páginas de índice, em vez de páginas de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="46107-357">Os localizadores de linha, em linhas de índice não clusterizado, são um ponteiro para uma linha ou uma chave de índice clusterizado para uma linha, como descrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="46107-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="46107-358">Se a tabela for um heap, ou seja, se não tiver um índice clusterizado, o localizador de linha será um ponteiro para a linha.</span><span class="sxs-lookup"><span data-stu-id="46107-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="46107-359">O ponteiro é criado a partir do ID (identificador), do número da página e do número da linha na página do arquivo.</span><span class="sxs-lookup"><span data-stu-id="46107-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="46107-360">O ponteiro inteiro é conhecido como RID (Identificação de Linha).</span><span class="sxs-lookup"><span data-stu-id="46107-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="46107-361">Se a tabela tiver um índice clusterizado, ou o índice estiver em uma exibição indexada, o localizador de linha será a chave de índice clusterizado da linha.</span><span class="sxs-lookup"><span data-stu-id="46107-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="46107-362">Os índices não clusterizados têm uma linha em [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) com **index_id** >1 para cada partição usada pelo índice.</span><span class="sxs-lookup"><span data-stu-id="46107-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="46107-363">Por padrão, um índice não clusterizado tem uma única partição.</span><span class="sxs-lookup"><span data-stu-id="46107-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="46107-364">Quando um índice não clusterizado tem várias partições, cada partição tem uma estrutura de árvore B que contém linhas de índice para aquela partição específica.</span><span class="sxs-lookup"><span data-stu-id="46107-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="46107-365">Por exemplo, se um índice não clusterizado tiver quatro partições, haverá quatro estruturas de árvore B, uma em cada partição.</span><span class="sxs-lookup"><span data-stu-id="46107-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="46107-366">Dependendo dos tipos de dados no índice não clusterizado, cada estrutura de índice não clusterizado terá uma ou mais unidades de alocação para armazenar e gerenciar os dados de uma partição específica.</span><span class="sxs-lookup"><span data-stu-id="46107-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="46107-367">No mínimo, cada índice não clusterizado terá uma unidade de alocação IN_ROW_DATA por partição que armazena as páginas de árvore B do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="46107-368">O índice não clusterizado também terá uma unidade de alocação LOB_DATA por partição se contiver colunas LOB (objetos grandes).</span><span class="sxs-lookup"><span data-stu-id="46107-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="46107-369">Além disso, terá uma unidade de alocação ROW_OVERFLOW_DATA por partição se contiver colunas de comprimento variável que excedem o limite de tamanho de linha de 8.060 bytes.</span><span class="sxs-lookup"><span data-stu-id="46107-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="46107-370">A ilustração a seguir mostra a estrutura de um índice não clusterizado em uma única partição.</span><span class="sxs-lookup"><span data-stu-id="46107-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="46107-371">![Níveis de um índice não clusterizado](media/bokind1.gif "Níveis de um índice não clusterizado")</span><span class="sxs-lookup"><span data-stu-id="46107-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="46107-372">Considerações sobre banco de dados</span><span class="sxs-lookup"><span data-stu-id="46107-372">Database Considerations</span></span>  

 <span data-ttu-id="46107-373">Considere as características do banco de dados ao criar índices não clusterizados.</span><span class="sxs-lookup"><span data-stu-id="46107-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="46107-374">Os bancos de dados ou as tabelas com baixos requisitos de atualização, mas volumes grandes de dados, podem se beneficiar de muitos índices não clusterizados para aprimorar o desempenho da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="46107-375">Considere a criação de índices filtrados para subconjuntos bem definidos de dados para aprimorar o desempenho da consulta, reduzir os custos de armazenamento de índice e reduzir os custos de manutenção de índice comparados a índices não clusterizados de tabela completa.</span><span class="sxs-lookup"><span data-stu-id="46107-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="46107-376">Os aplicativos do Sistema de Suporte a Decisões e os bancos de dados que contêm fundamentalmente dados somente leitura podem se beneficiar de vários índices não clusterizados.</span><span class="sxs-lookup"><span data-stu-id="46107-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="46107-377">O otimizador de consulta tem mais índices dos quais selecionar para determinar o método de acesso mais rápido e as baixas características de atualização do banco de dados significam que a manutenção do índice não impedirá o desempenho.</span><span class="sxs-lookup"><span data-stu-id="46107-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="46107-378">Os aplicativos de Processamento de Transações online e os bancos de dados que contêm tabelas com grandes atualizações devem evitar a superindexação.</span><span class="sxs-lookup"><span data-stu-id="46107-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="46107-379">Adicionalmente, os índices deveriam ser restritos, ou seja, com o mínimo possível de colunas.</span><span class="sxs-lookup"><span data-stu-id="46107-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="46107-380">Números grandes de índices em uma tabela afetam o desempenho das instruções INSERT, UPDATE, DELETE e MERGE porque todos os índices precisam ser ajustados adequadamente à medida que os dados são alterados em uma tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="46107-381">Considerações sobre consultas</span><span class="sxs-lookup"><span data-stu-id="46107-381">Query Considerations</span></span>  

 <span data-ttu-id="46107-382">Antes de criar índices não clusterizados, é recomendado entender como os dados são acessados.</span><span class="sxs-lookup"><span data-stu-id="46107-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="46107-383">Considere usar um índice não clusterizado para consultas com os seguintes atributos:</span><span class="sxs-lookup"><span data-stu-id="46107-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="46107-384">Use as cláusulas JOIN ou GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="46107-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="46107-385">Crie vários índices não clusterizados em colunas envolvidas em operações de junção e de agrupamento e um índice clusterizado em qualquer coluna de chave estrangeira.</span><span class="sxs-lookup"><span data-stu-id="46107-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="46107-386">Consultas que não retornam grandes conjuntos de resultados.</span><span class="sxs-lookup"><span data-stu-id="46107-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="46107-387">Crie índices filtrados para abranger consultas que retornam um subconjunto bem definido de linhas de uma tabela grande.</span><span class="sxs-lookup"><span data-stu-id="46107-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="46107-388">Contém as colunas envolvidas frequentemente em condições de pesquisa de consulta, como a cláusula WHERE, que retorna correspondências exatas.</span><span class="sxs-lookup"><span data-stu-id="46107-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="46107-389">Considerações sobre colunas</span><span class="sxs-lookup"><span data-stu-id="46107-389">Column Considerations</span></span>  

 <span data-ttu-id="46107-390">Considere as colunas que tenham um ou mais destes atributos:</span><span class="sxs-lookup"><span data-stu-id="46107-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="46107-391">Cubra a consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-391">Cover the query.</span></span>  
  
     <span data-ttu-id="46107-392">São obtidos ganhos de desempenho quando o índice contém todas as colunas da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="46107-393">O otimizador de consulta pode localizar todos os valores da coluna dentro do índice. Os dados de tabela ou de índice clusterizado não são acessados, o que resulta em menos operações de E/S.</span><span class="sxs-lookup"><span data-stu-id="46107-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="46107-394">Use índice com colunas incluídas para adicionar colunas de cobertura, em vez de criar uma ampla chave de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="46107-395">Se a tabela tiver um índice clusterizado, a coluna ou as colunas definidas no índice clusterizado serão anexadas automaticamente ao final de cada índice não clusterizado da tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="46107-396">Isso pode produzir uma consulta coberta sem especificar as colunas de índice clusterizado na definição do índice não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="46107-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="46107-397">Por exemplo, se uma tabela tiver um índice clusterizado na coluna `C`, um índice não clusterizado nas colunas `B` e `A` , terá como colunas de valores de chave `B`, `A`e `C`.</span><span class="sxs-lookup"><span data-stu-id="46107-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="46107-398">Muitos valores distintos, como uma combinação de sobrenome e nome, caso um índice clusterizado seja usado em outras colunas.</span><span class="sxs-lookup"><span data-stu-id="46107-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="46107-399">Se houver poucos valores distintos, como apenas 1 e 0, a maioria das consultas não usará o índice porque uma verificação de tabela é, em geral, mais eficaz.</span><span class="sxs-lookup"><span data-stu-id="46107-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="46107-400">Para esse tipo de dados, considere a criação de um índice filtrado em um valor diferente que ocorra apenas em um número pequeno de linhas.</span><span class="sxs-lookup"><span data-stu-id="46107-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="46107-401">Por exemplo, se a maioria dos valores for 0, o otimizador de consulta pode usar um índice filtrado para as linhas de dados que contêm 1.</span><span class="sxs-lookup"><span data-stu-id="46107-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="46107-402">Usar colunas incluídas para estender índices não clusterizados</span><span class="sxs-lookup"><span data-stu-id="46107-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="46107-403">Você pode estender a funcionalidade de índices não clusterizados acrescentando colunas de não chave ao nível folha do índice não cluster.</span><span class="sxs-lookup"><span data-stu-id="46107-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="46107-404">Ao incluir colunas não chave, você pode criar você índices não clusterizados que abrangem mais consultas.</span><span class="sxs-lookup"><span data-stu-id="46107-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="46107-405">Isto porque as colunas não chave têm os seguintes benefícios:</span><span class="sxs-lookup"><span data-stu-id="46107-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="46107-406">Elas podem ser tipos de dados não permitidos como colunas de chave de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="46107-407">Eles não são considerados pelo [!INCLUDE[ssDE](../includes/ssde-md.md)] ao calcular o número de colunas de chave de índice ou o tamanho da chave de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="46107-408">Um índice com colunas não chave incluídas pode melhorar o desempenho de consulta significativamente quando todas as colunas na consulta forem incluídas no índice como colunas de chave ou não chave.</span><span class="sxs-lookup"><span data-stu-id="46107-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="46107-409">Os ganhos de desempenho são alcançados pois o otimizador de consulta pode localizar todos os valores de coluna dentro do índice, a tabela, ou dados de índice clusterizado não são acessados, resultando em poucas operações de E/S de disco.</span><span class="sxs-lookup"><span data-stu-id="46107-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="46107-410">Quando um índice contém todas colunas referenciadas pela consulta, ele costuma ser referenciado como se abrangendo a consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="46107-411">Enquanto as colunas de chave são armazenadas em todos os níveis do índice, as colunas não chave são armazenadas apenas em nível folha.</span><span class="sxs-lookup"><span data-stu-id="46107-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="46107-412">Usando colunas incluídas para evitar limites de tamanho</span><span class="sxs-lookup"><span data-stu-id="46107-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="46107-413">Você pode incluir colunas não chave em um índice não clusterizado para evitar exceder as limitações do tamanho atual do índice, de um máximo de 16 colunas de chave, e um máximo de tamanho chave de índice de 900 bytes.</span><span class="sxs-lookup"><span data-stu-id="46107-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="46107-414">O [!INCLUDE[ssDE](../includes/ssde-md.md)] não considera as colunas não chave ao calcular o número de colunas de chave de índice, ou o tamanho da chave do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="46107-415">Por exemplo, suponha que você quer indexar as colunas seguintes na tabela `Document` :</span><span class="sxs-lookup"><span data-stu-id="46107-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="46107-416">Como os tipos de dados `nchar` e `nvarchar` exigem 2 bytes para cada caractere, um índice que contém essas três colunas ultrapassaria a limitação de tamanho de 900 bytes por 10 bytes (455 \* 2).</span><span class="sxs-lookup"><span data-stu-id="46107-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="46107-417">Ao usar a cláusula `INCLUDE` da declaração `CREATE INDEX` , a chave de índice pode ser definida como uma coluna não chave (`Title, Revision`) e `FileName` .</span><span class="sxs-lookup"><span data-stu-id="46107-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="46107-418">Desse modo, o tamanho da chave de índice seria de 110 bytes (55 \* 2) e o índice ainda conteria todas as colunas necessárias.</span><span class="sxs-lookup"><span data-stu-id="46107-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="46107-419">A seguinte declaração cria tal índice.</span><span class="sxs-lookup"><span data-stu-id="46107-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="46107-420">Índice com diretrizes das colunas incluídas</span><span class="sxs-lookup"><span data-stu-id="46107-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="46107-421">Quando você projeta índices não clusterizados com colunas incluídas, considere as seguintes diretrizes:</span><span class="sxs-lookup"><span data-stu-id="46107-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="46107-422">As colunas não chave estão definidas na cláusula INCLUDE da instrução CREATE INDEX.</span><span class="sxs-lookup"><span data-stu-id="46107-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="46107-423">As colunas não chave só podem ser definidas em índices não clusterizados em tabelas, ou em exibições indexadas.</span><span class="sxs-lookup"><span data-stu-id="46107-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="46107-424">São permitidos todos os tipos de dados, exceto `text`, `ntext` e `image`.</span><span class="sxs-lookup"><span data-stu-id="46107-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="46107-425">As colunas computadas que são determinísticas e precisas ou imprecisas podem ser colunas incluídas.</span><span class="sxs-lookup"><span data-stu-id="46107-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="46107-426">Para obter mais informações, consulte [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="46107-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="46107-427">Assim como com as colunas de chave, as colunas computadas derivadas dos tipos de dados `image`, `ntext`, e `text` podem ser colunas não chave (incluídas), desde que o tipo de dados da coluna computada seja permitido como uma coluna de índice não chave.</span><span class="sxs-lookup"><span data-stu-id="46107-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="46107-428">Os nomes das colunas não podem ser especificados na lista INCLUDE e na lista de coluna de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="46107-429">Os nomes das colunas não podem ser repetidos na lista INCLUDE.</span><span class="sxs-lookup"><span data-stu-id="46107-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="46107-430">Diretrizes do tamanho da coluna</span><span class="sxs-lookup"><span data-stu-id="46107-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="46107-431">Pelo menos uma coluna de chave deve ser definida.</span><span class="sxs-lookup"><span data-stu-id="46107-431">At least one key column must be defined.</span></span> <span data-ttu-id="46107-432">O número de máximo de colunas não chave é de 1023 colunas.</span><span class="sxs-lookup"><span data-stu-id="46107-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="46107-433">Esse é o número máximo de colunas de tabela menos 1.</span><span class="sxs-lookup"><span data-stu-id="46107-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="46107-434">As colunas de chave de índice, exceto as não chave, devem seguir as restrições de tamanho de índice de no máximo 16 colunas de chave, e um tamanho total de chave de índice de no máximo 900 bytes.</span><span class="sxs-lookup"><span data-stu-id="46107-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="46107-435">O tamanho total de todas as colunas não chave está limitado somente pelo tamanho especificado das colunas na cláusula INCLUDE; por exemplo, as colunas `varchar(max)` estão limitadas a 2 GB.</span><span class="sxs-lookup"><span data-stu-id="46107-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="46107-436">Diretrizes para modificação de coluna</span><span class="sxs-lookup"><span data-stu-id="46107-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="46107-437">Quando você modifica uma coluna de tabela que estava definida como uma coluna incluída, as restrições seguintes se aplicam:</span><span class="sxs-lookup"><span data-stu-id="46107-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="46107-438">As colunas não chave não podem ser soltar das tabelas, a menos que o índice seja solto antes.</span><span class="sxs-lookup"><span data-stu-id="46107-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="46107-439">As colunas não chave não podem ser alteradas, exceto para fazerem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="46107-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="46107-440">Alterar a nulidade da coluna da coluna NOT NULL até NULL.</span><span class="sxs-lookup"><span data-stu-id="46107-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="46107-441">Aumentar o comprimento das colunas `varchar`, `nvarchar`, ou `varbinary` .</span><span class="sxs-lookup"><span data-stu-id="46107-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="46107-442">Estas restrições de modificação de coluna também se aplicam para indexar colunas de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="46107-443">Recomendações de design</span><span class="sxs-lookup"><span data-stu-id="46107-443">Design Recommendations</span></span>  

 <span data-ttu-id="46107-444">Redesenhe índices não clusterizados com um comprimento de chave de índice, de tal forma que apenas as colunas usadas para buscas e pesquisas sejam colunas de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="46107-445">Faça todas as outras colunas que abrangem a consulta colunas não chave incluídas.</span><span class="sxs-lookup"><span data-stu-id="46107-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="46107-446">Deste modo, você terá todas as colunas necessárias para abranger a consulta, mas a chave de índice em si é pequena e eficiente.</span><span class="sxs-lookup"><span data-stu-id="46107-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="46107-447">Por exemplo, suponha que você quer projetar um índice para abranger a consulta seguinte.</span><span class="sxs-lookup"><span data-stu-id="46107-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="46107-448">Para abranger a consulta, cada coluna deve ser definida no índice.</span><span class="sxs-lookup"><span data-stu-id="46107-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="46107-449">Embora você possa definir todas as colunas como colunas de chave, o tamanho chave seria de 334 bytes.</span><span class="sxs-lookup"><span data-stu-id="46107-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="46107-450">Em razão da única coluna de fato usada como critério de pesquisa ser a coluna `PostalCode` , que tem um comprimento de 30 bytes, um melhor design de índice definiria `PostalCode` como sendo a coluna de chave e incluiria todas as outras colunas como colunas que não são colunas de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="46107-451">A seguinte declaração cria um índice com colunas incluídas para abranger a consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="46107-452">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="46107-452">Performance Considerations</span></span>  

 <span data-ttu-id="46107-453">Evite a adição desnecessária de colunas.</span><span class="sxs-lookup"><span data-stu-id="46107-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="46107-454">Adicionar muitas colunas de índice, sejam elas chave ou não, pode gerar as seguintes implicações no desempenho:</span><span class="sxs-lookup"><span data-stu-id="46107-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="46107-455">Poucas filas de índice se ajustarão em uma página.</span><span class="sxs-lookup"><span data-stu-id="46107-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="46107-456">Isto poderia criar aumentos de E/S e eficiência de cache reduzida.</span><span class="sxs-lookup"><span data-stu-id="46107-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="46107-457">Será necessário mais espaço em disco para armazenar o índice.</span><span class="sxs-lookup"><span data-stu-id="46107-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="46107-458">Em particular, acrescentar os tipos de dados `varchar(max)`, `nvarchar(max)`, `varbinary(max)`ou `xml` como colunas de índice não chave pode aumentar significativamente os requisitos de espaço em disco.</span><span class="sxs-lookup"><span data-stu-id="46107-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="46107-459">Isto porque os valores de coluna são copiados no nível folha de índice.</span><span class="sxs-lookup"><span data-stu-id="46107-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="46107-460">Portanto, eles residem no índice e na tabela base.</span><span class="sxs-lookup"><span data-stu-id="46107-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="46107-461">A manutenção do índice pode aumentar o tempo necessário para executar modificações, inserções, atualizações ou exclusões, para a tabela subjacente ou exibição indexada.</span><span class="sxs-lookup"><span data-stu-id="46107-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="46107-462">Você terá que determinar se os ganhos no desempenho de consulta superam o efeito no desempenho durante a modificação de dados, e em requisitos adicionais de espaço em disco.</span><span class="sxs-lookup"><span data-stu-id="46107-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="46107-463">![Ícone de seta usado com o link voltar ao início](media/uparrow16x16.gif "Ícone de seta usado com o link Voltar ao Início") [neste guia](#Top)</span><span class="sxs-lookup"><span data-stu-id="46107-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="46107-464">Diretrizes de design de índice exclusivo</span><span class="sxs-lookup"><span data-stu-id="46107-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="46107-465">Um índice exclusivo garante que a chave de índice não contém nenhum valor duplicado e, portanto, cada linha na tabela é exclusiva de algum modo.</span><span class="sxs-lookup"><span data-stu-id="46107-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="46107-466">Especificar um índice exclusivo só faz sentido quando a exclusividade for uma característica dos próprios dados.</span><span class="sxs-lookup"><span data-stu-id="46107-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="46107-467">Por exemplo, se você quiser garantir que os valores na coluna `NationalIDNumber` na tabela `HumanResources.Employee` sejam exclusivos, quando a chave primária for `EmployeeID`, crie uma restrição UNIQUE na coluna `NationalIDNumber` .</span><span class="sxs-lookup"><span data-stu-id="46107-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="46107-468">Se o usuário tentar digitar o mesmo valor naquela coluna para mais de um empregado, será exibida uma mensagem de erro e o valor duplicado não é inserido.</span><span class="sxs-lookup"><span data-stu-id="46107-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="46107-469">Com índices exclusivos de multicolunas, o índice garante que cada combinação de valores na chave de índice é exclusivo.</span><span class="sxs-lookup"><span data-stu-id="46107-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="46107-470">Por exemplo, se um índice exclusivo for criado em uma combinação de colunas `LastName`, `FirstName`e `MiddleName` , duas linhas na tabela não poderão ter a mesma combinação de valores que essas colunas.</span><span class="sxs-lookup"><span data-stu-id="46107-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="46107-471">Tanto os índices clusterizados quanto os não clusterizados podem ser exclusivos.</span><span class="sxs-lookup"><span data-stu-id="46107-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="46107-472">Contanto que os dados na coluna sejam exclusivos, você pode criar um índice clusterizado exclusivo e não clusterizado na mesma tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="46107-473">Os benefícios dos índices exclusivos incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="46107-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="46107-474">A integridade de dados das colunas definidas é garantida.</span><span class="sxs-lookup"><span data-stu-id="46107-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="46107-475">São fornecidas informações úteis adicionais ao otimizador de consultas.</span><span class="sxs-lookup"><span data-stu-id="46107-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="46107-476">Criar uma restrição PRIMARY KEY ou UNIQUE automaticamente gera um índice exclusivo nas colunas especificadas.</span><span class="sxs-lookup"><span data-stu-id="46107-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="46107-477">Não há nenhuma diferença significativa entre criar uma restrição UNIQUE e criar um índice exclusivo independente de uma restrição.</span><span class="sxs-lookup"><span data-stu-id="46107-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="46107-478">A validação de dados ocorre da mesma maneira e o otimizador de consultas não diferencia entre um índice exclusivo criado por uma restrição ou manualmente.</span><span class="sxs-lookup"><span data-stu-id="46107-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="46107-479">Entretanto, você deverá criar uma restrição UNIQUE ou PRIMARY KEY na coluna quando o objetivo for a integridade de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="46107-480">Fazendo isso o objetivo do índice será claro.</span><span class="sxs-lookup"><span data-stu-id="46107-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="46107-481">Considerações</span><span class="sxs-lookup"><span data-stu-id="46107-481">Considerations</span></span>  
  
-   <span data-ttu-id="46107-482">Um índice exclusivo, uma restrição UNIQUE ou uma restrição PRIMARY KEY não poderão ser criados, se existirem valores de chave duplicados nos dados.</span><span class="sxs-lookup"><span data-stu-id="46107-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="46107-483">Se os dados forem exclusivos e você quiser impor exclusividade, criar um índice exclusivo em vez de um índice não exclusivo, na mesma combinação de colunas, fornecerá informações adicionais para otimizador de consultas que poderá produzir planos de execução mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="46107-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="46107-484">Criar um índice exclusivo (preferivelmente criando uma restrição UNIQUE) é recomendável nesse caso.</span><span class="sxs-lookup"><span data-stu-id="46107-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="46107-485">Um índice não clusterizado exclusivo pode conter colunas não chave incluídas.</span><span class="sxs-lookup"><span data-stu-id="46107-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="46107-486">Para obter mais informações, consulte [Índice com colunas incluídas](#Included_Columns).</span><span class="sxs-lookup"><span data-stu-id="46107-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="46107-487">![Ícone de seta usado com o link voltar ao início](media/uparrow16x16.gif "Ícone de seta usado com o link Voltar ao Início") [neste guia](#Top)</span><span class="sxs-lookup"><span data-stu-id="46107-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="46107-488">Diretrizes de criação de índice filtrado</span><span class="sxs-lookup"><span data-stu-id="46107-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="46107-489">Um índice filtrado é um índice não clusterizado otimizado, criado especialmente para consultas que fazem seleções a partir de um subconjunto bem-definido de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="46107-490">Ele usa um predicado de filtro para indexar uma parte das linhas da tabela.</span><span class="sxs-lookup"><span data-stu-id="46107-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="46107-491">Um índice filtrado bem projetado pode melhorar o desempenho da consulta e reduzir os custos de manutenção e armazenamento do índice em comparação com os índices de tabela completa.</span><span class="sxs-lookup"><span data-stu-id="46107-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="46107-492">**Aplica-se a**: do [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] ao [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="46107-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="46107-493">Os índices filtrados podem oferecer as seguintes vantagens com relação aos índices de tabela completa:</span><span class="sxs-lookup"><span data-stu-id="46107-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="46107-494">**Melhor desempenho de consultas e qualidade de plano**</span><span class="sxs-lookup"><span data-stu-id="46107-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="46107-495">Um índice filtrado bem projetado melhora o desempenho das consultas e a qualidade do plano de execução porque é menor do que um índice não clusterizado de tabela completa e possui estatísticas filtradas.</span><span class="sxs-lookup"><span data-stu-id="46107-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="46107-496">As estatísticas filtradas são mais precisas do que as estatísticas de tabela completa, pois abrangem apenas as linhas do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="46107-497">**Redução dos custos de manutenção do índice**</span><span class="sxs-lookup"><span data-stu-id="46107-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="46107-498">A manutenção do índice é feita apenas quando as instruções DML (linguagem de manipulação de dados) afetam os dados do índice.</span><span class="sxs-lookup"><span data-stu-id="46107-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="46107-499">Um índice filtrado reduz os custos de manutenção em comparação com o índice não clusterizado de tabela completa porque é menor e a manutenção é feita somente quando seus dados são afetados.</span><span class="sxs-lookup"><span data-stu-id="46107-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="46107-500">É possível ter um grande número de índices filtrados, especialmente quando eles contêm dados que são raramente afetados.</span><span class="sxs-lookup"><span data-stu-id="46107-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="46107-501">Do mesmo modo, se um índice filtrado tiver apenas dados afetados com frequência, seu tamanho reduzido diminuirá o custo de atualização das estatísticas.</span><span class="sxs-lookup"><span data-stu-id="46107-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="46107-502">**Redução dos custos de armazenamento do índice**</span><span class="sxs-lookup"><span data-stu-id="46107-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="46107-503">A criação de um índice filtrado pode reduzir o armazenamento em disco de índices não clusterizados quando um índice de tabela completa não é necessário.</span><span class="sxs-lookup"><span data-stu-id="46107-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="46107-504">É possível substituir um índice não clusterizado de tabela completa por vários índices filtrados sem aumentar de forma significativa os requisitos de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="46107-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="46107-505">Os índices filtrados são úteis quando as colunas contêm subconjuntos de dados bem-definidos, a que as consultas fazem referência em instruções SELECT.</span><span class="sxs-lookup"><span data-stu-id="46107-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="46107-506">São exemplos:</span><span class="sxs-lookup"><span data-stu-id="46107-506">Examples are:</span></span>  
  
-   <span data-ttu-id="46107-507">Colunas esparsas que contêm apenas alguns valores não NULL.</span><span class="sxs-lookup"><span data-stu-id="46107-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="46107-508">Colunas heterogêneas que contêm categorias de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="46107-509">Colunas que contêm intervalos de valores como quantias em dinheiro, hora e datas.</span><span class="sxs-lookup"><span data-stu-id="46107-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="46107-510">Partições de tabela definidas pela lógica de comparação simples para obter valores de coluna.</span><span class="sxs-lookup"><span data-stu-id="46107-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="46107-511">O custo de manutenção reduzido dos índices filtrados é mais perceptível quando o número de linhas do índice é pequeno, se comparado a um índice de tabela completa.</span><span class="sxs-lookup"><span data-stu-id="46107-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="46107-512">Se o índice filtrado incluir a maioria das linhas da tabela, sua manutenção poderá ser mais cara do que a do índice de tabela completa.</span><span class="sxs-lookup"><span data-stu-id="46107-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="46107-513">Nesse caso, você deve usar um índice de tabela completa em vez do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="46107-514">Os índices filtrados são definidos em uma tabela e oferecem suporte apenas a operadores de comparação simples.</span><span class="sxs-lookup"><span data-stu-id="46107-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="46107-515">Se você precisar de uma expressão de filtro que referencie várias tabelas ou que tenha uma lógica complexa, deverá criar uma exibição.</span><span class="sxs-lookup"><span data-stu-id="46107-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="46107-516">Considerações de criação</span><span class="sxs-lookup"><span data-stu-id="46107-516">Design Considerations</span></span>  

 <span data-ttu-id="46107-517">Para criar índices filtrados eficazes, é importante entender quais consultas o aplicativo usa e como elas se relacionam com os subconjuntos de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="46107-518">Alguns exemplos de dados com subconjuntos bem-definidos são as colunas com valores predominantemente NULL, as colunas com categorias de valores heterogêneas e as colunas com intervalos de valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="46107-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="46107-519">As considerações sobre criação a seguir apresentam uma variedade de cenários em que um índice filtrado pode ser vantajoso com relação aos índices de tabela completa.</span><span class="sxs-lookup"><span data-stu-id="46107-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="46107-520">Índices filtrados para subconjuntos de dados</span><span class="sxs-lookup"><span data-stu-id="46107-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="46107-521">Quando a coluna tem apenas uma pequena quantidade de valores relevantes para consultas, você pode criar um índice filtrado no subconjunto de valores.</span><span class="sxs-lookup"><span data-stu-id="46107-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="46107-522">Por exemplo, se os valores de uma coluna forem predominantemente NULL e a consulta selecionar apenas valores não NULL, será possível criar um índice filtrado para linhas de dados não NULL.</span><span class="sxs-lookup"><span data-stu-id="46107-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="46107-523">O índice resultante será menor e sua manutenção será menos dispendiosa em comparação com um índice não clusterizado de tabela completa definido nas mesmas colunas de chave.</span><span class="sxs-lookup"><span data-stu-id="46107-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="46107-524">Por exemplo, o banco de dados `AdventureWorks2012` tem uma tabela `Production.BillOfMaterials` com 2.679 linhas.</span><span class="sxs-lookup"><span data-stu-id="46107-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="46107-525">A coluna `EndDate` tem apenas 199 linhas que contêm um valor não NULL e outras 2.480 linhas que contêm NULL.</span><span class="sxs-lookup"><span data-stu-id="46107-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="46107-526">O índice filtrado a seguir abrange consultas que retornam as colunas definidas no índice e que selecionam apenas linhas com valor não NULL para `EndDate`.</span><span class="sxs-lookup"><span data-stu-id="46107-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="46107-527">O índice filtrado `FIBillOfMaterialsWithEndDate` é válido para a consulta a seguir.</span><span class="sxs-lookup"><span data-stu-id="46107-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="46107-528">Você pode exibir o plano de execução da consulta para determinar se o otimizador de consulta usou o índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="46107-529">Para obter mais informações sobre como criar índices filtrados e definir a expressão de predicado do índice filtrado, consulte [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="46107-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="46107-530">Índices filtrados para dados heterogêneos</span><span class="sxs-lookup"><span data-stu-id="46107-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="46107-531">Quando a tabela contém linhas de dados heterogêneos, é possível criar um índice filtrado para uma ou mais categorias de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="46107-532">Por exemplo, a cada produto listado na tabela `Production.Product` é atribuído um `ProductSubcategoryID`que, por sua vez, está associado às categorias de produtos Bikes, Components, Clothing ou Accessories.</span><span class="sxs-lookup"><span data-stu-id="46107-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="46107-533">Essas categorias são heterogêneas porque os valores das coluna da tabela `Production.Product` não estão estreitamente correlacionados.</span><span class="sxs-lookup"><span data-stu-id="46107-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="46107-534">Por exemplo, as colunas `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`e `Style` têm características exclusivas para cada categoria de produto.</span><span class="sxs-lookup"><span data-stu-id="46107-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="46107-535">Suponha que haja consultas frequentes sobre acessórios que possuem subcategorias entre 27 e 36.</span><span class="sxs-lookup"><span data-stu-id="46107-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="46107-536">É possível aprimorar o desempenho das consultas sobre acessórios criando um índice filtrado nas subcategorias de acessórios, conforme ilustrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="46107-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="46107-537">O índice filtrado `FIProductAccessories` abrange a seguinte consulta porque os resultados da consulta</span><span class="sxs-lookup"><span data-stu-id="46107-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="46107-538">estão contidos no índice e o plano da consulta não inclui uma pesquisa de tabela base.</span><span class="sxs-lookup"><span data-stu-id="46107-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="46107-539">Por exemplo, a expressão de predicado da consulta `ProductSubcategoryID = 33` é um subconjunto do predicado de índice filtrado `ProductSubcategoryID >= 27` e `ProductSubcategoryID <= 36`, as colunas `ProductSubcategoryID` e `ListPrice` no predicado de consulta são ambas colunas de chave no índice, e o nome é armazenado no nível folha do índice como uma coluna incluída.</span><span class="sxs-lookup"><span data-stu-id="46107-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="46107-540">Colunas de Chave</span><span class="sxs-lookup"><span data-stu-id="46107-540">Key Columns</span></span>  

 <span data-ttu-id="46107-541">Uma prática recomendada é incluir um pequeno número de colunas de chave ou incluídas em uma definição de índice filtrado e inserir apenas as colunas necessárias para o otimizador de consulta escolher o índice filtrado para o plano de execução da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="46107-542">O otimizador de consulta pode escolher um índice filtrado para a consulta, independentemente de ele abranger ou não a consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="46107-543">No entanto, é mais provável que o otimizador de consulta escolha um índice filtrado se ele abranger a consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="46107-544">Em alguns casos, um índice filtrado abrange a consulta sem incluir as colunas na expressão do índice filtrado como colunas de chave ou incluídas na definição do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="46107-545">As diretrizes a seguir explicam quando uma coluna em uma expressão de índice filtrado deve ser uma coluna de chave ou incluída na definição do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="46107-546">Os exemplos se referem ao índice filtrado `FIBillOfMaterialsWithEndDate` que foi criado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="46107-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="46107-547">A coluna na expressão do índice filtrado não precisará ser uma coluna de chave ou incluída na definição do índice filtrado, se a expressão do índice filtrado for equivalente ao predicado da consulta e a consulta não retorná-la com os resultados da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="46107-548">Por exemplo, `FIBillOfMaterialsWithEndDate` abrange a consulta a seguir porque o predicado da consulta é equivalente à expressão de filtro e `EndDate` não é retornado com os resultados da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="46107-549">`FIBillOfMaterialsWithEndDate` não precisa de `EndDate` como uma coluna de chave ou incluída na definição do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="46107-550">A coluna na expressão de índice filtrado deverá ser uma coluna de chave ou incluída na definição do índice filtrado se o predicado de consulta usá-la em uma comparação que não for equivalente à expressão do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="46107-551">Por exemplo, `FIBillOfMaterialsWithEndDate` é válido para a consulta a seguir, porque seleciona um subconjunto de linhas do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="46107-552">Contudo, não abrange a consulta a seguir porque `EndDate` é usado na comparação de `EndDate > '20040101'`, que não é equivalente à expressão do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="46107-553">O processador de consultas não pode executar essa consulta sem observar os valores de `EndDate`.</span><span class="sxs-lookup"><span data-stu-id="46107-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="46107-554">Portanto, `EndDate` deve ser uma coluna de chave ou incluída na definição do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="46107-555">A coluna na expressão do índice filtrado deverá ser uma coluna de chave ou incluída na definição do índice filtrado se fizer parte do conjunto de resultados da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="46107-556">Por exemplo, `FIBillOfMaterialsWithEndDate` não abrange a consulta a seguir, porque retorna a coluna `EndDate` nos resultados da consulta.</span><span class="sxs-lookup"><span data-stu-id="46107-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="46107-557">Portanto, `EndDate` deve ser uma coluna de chave ou incluída na definição do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="46107-558">A chave de índice clusterizado da tabela não precisa ser uma coluna de chave ou incluída na definição do índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="46107-559">A chave de índice clusterizado é incluída automaticamente em todos os índices não clusterizados, inclusive índices filtrados.</span><span class="sxs-lookup"><span data-stu-id="46107-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="46107-560">Operadores de conversão de dados no predicado do filtro</span><span class="sxs-lookup"><span data-stu-id="46107-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="46107-561">Se o operador de comparação especificado na expressão do índice filtrado resultar em uma conversão de dados implícita ou explícita, ocorrerá um erro se a conversão ocorrer à esquerda do operador de comparação.</span><span class="sxs-lookup"><span data-stu-id="46107-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="46107-562">Uma solução seria gravar a expressão do índice filtrado com o operador de conversão de dados (CAST ou CONVERT) à direita do operador de comparação.</span><span class="sxs-lookup"><span data-stu-id="46107-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="46107-563">O exemplo a seguir cria uma tabela com diversos tipos de dados.</span><span class="sxs-lookup"><span data-stu-id="46107-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="46107-564">Na definição de índice filtrado a seguir, a coluna `b` é convertida implicitamente em um tipo de dados de número inteiro para comparação com a constante 1.</span><span class="sxs-lookup"><span data-stu-id="46107-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="46107-565">Isso gera a mensagem de erro 10611 porque a conversão ocorre à esquerda do operador no predicado filtrado.</span><span class="sxs-lookup"><span data-stu-id="46107-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="46107-566">A solução é converter a constante à direita para o mesmo tipo da coluna `b`, como mostra o seguinte exemplo:</span><span class="sxs-lookup"><span data-stu-id="46107-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="46107-567">A movimentação da conversão de dados da esquerda para a direita de um operador de comparação pode alterar o significado da conversão.</span><span class="sxs-lookup"><span data-stu-id="46107-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="46107-568">No exemplo anterior, quando o operador CONVERT foi adicionado à direita, a comparação mudou de uma comparação de número inteiro para uma comparação `varbinary`.</span><span class="sxs-lookup"><span data-stu-id="46107-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="46107-569">![Ícone de seta usado com o link voltar ao início](media/uparrow16x16.gif "Ícone de seta usado com o link Voltar ao Início") [neste guia](#Top)</span><span class="sxs-lookup"><span data-stu-id="46107-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="46107-570">Leitura adicional</span><span class="sxs-lookup"><span data-stu-id="46107-570">Additional Reading</span></span>  

 <span data-ttu-id="46107-571">[Melhorando o desempenho com exibições indexadas do SQL Server 2008](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="46107-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="46107-572">Tabelas e índices particionados</span><span class="sxs-lookup"><span data-stu-id="46107-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  
