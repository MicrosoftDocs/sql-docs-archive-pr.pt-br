---
title: Tipos de dados XPath (SQLXML 4,0) | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: rothja
ms.author: jroth
ms.openlocfilehash: 846fc5a17ac97d30b6f0ab65fee176ac459c20cc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87575737"
---
# <a name="xpath-data-types-sqlxml-40"></a><span data-ttu-id="cd7f1-102">Tipos de dados XPath (SQLXML 4.0)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-102">XPath Data Types (SQLXML 4.0)</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="cd7f1-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath e XSD (esquema XML) têm tipos de dados muito diferentes.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath, and XML Schema (XSD) have very different data types.</span></span> <span data-ttu-id="cd7f1-104">Por exemplo, o XPath não tem tipos de dados de data ou inteiros, mas o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] e o XSD têm muitos.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-104">For example, XPath does not have integer or date data types, but [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and XSD have many.</span></span> <span data-ttu-id="cd7f1-105">O XSD usa precisão de nanossegundos para valores de tempo, e o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] usa precisão de no máximo 1/300 segundo.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-105">XSD uses nanosecond precision for time values, and [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses at most 1/300-second precision.</span></span> <span data-ttu-id="cd7f1-106">Consequentemente, o mapeamento de um tipo de dados para outro nem sempre é possível.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-106">Consequently, mapping one data type to another is not always possible.</span></span> <span data-ttu-id="cd7f1-107">Para obter mais informações sobre mapeamento [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] de tipos de dados para tipos de dados XSD, consulte [coerção de tipo de dados e a anotação sql: DataType &#40;SQLXML 4,0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span><span class="sxs-lookup"><span data-stu-id="cd7f1-107">For more information about mapping [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types to XSD data types, see [Data Type Coercions and the sql:datatype Annotation &#40;SQLXML 4.0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span></span>  
  
 <span data-ttu-id="cd7f1-108">O XPath tem três tipos de dados: `string`, `number` e `boolean`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-108">XPath has three data types: `string`, `number`, and `boolean`.</span></span> <span data-ttu-id="cd7f1-109">O tipo de dados `number` sempre é um ponto flutuante de precisão dupla IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-109">The `number` data type is always an IEEE 754 double-precision floating-point.</span></span> <span data-ttu-id="cd7f1-110">O [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `float(53)` tipo de dados é o mais próximo do XPath `number` .</span><span class="sxs-lookup"><span data-stu-id="cd7f1-110">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`float(53)` data type is the closest to XPath `number`.</span></span> <span data-ttu-id="cd7f1-111">Entretanto, o `float(53)` não é exatamente igual ao IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-111">However, `float(53)` is not exactly IEEE 754.</span></span> <span data-ttu-id="cd7f1-112">Por exemplo, nem NaN (não é um número) nem infinidade é usado.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-112">For example, neither NaN (Not-a-Number) nor infinity is used.</span></span> <span data-ttu-id="cd7f1-113">Tentar converter uma cadeia de caracteres não numérica em `number` e tentar dividir por zero resulta em erro.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-113">Attempting to convert a nonnumeric string to `number` and trying to divide by zero results in an error.</span></span>  
  
## <a name="xpath-conversions"></a><span data-ttu-id="cd7f1-114">Conversões do XPath</span><span class="sxs-lookup"><span data-stu-id="cd7f1-114">XPath Conversions</span></span>  
 <span data-ttu-id="cd7f1-115">Quando você usa uma consulta do XPath como `OrderDetail[@UnitPrice > "10.0"]`, conversões de tipos de dados implícitas e explícitas podem alterar sutilmente o significado da consulta.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-115">When you use an XPath query such as `OrderDetail[@UnitPrice > "10.0"]`, implicit and explicit data type conversions can change the meaning of the query in subtle ways.</span></span> <span data-ttu-id="cd7f1-116">Por isso, é importante entender como são implementados os tipos de dados XPath.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-116">Therefore, it is important to understand how XPath data types are implemented.</span></span> <span data-ttu-id="cd7f1-117">A especificação de linguagem XPath, o XPath (XML Path Language) versão 1,0, recomendação proposta de 8 de outubro de 1999, pode ser encontrada no site da W3C em http://www.w3.org/TR/1999/PR-xpath-19991008.html .</span><span class="sxs-lookup"><span data-stu-id="cd7f1-117">The XPath language specification, XML Path Language (XPath) version 1.0 W3C Proposed Recommendation 8 October 1999, can be found at the W3C Web site at http://www.w3.org/TR/1999/PR-xpath-19991008.html.</span></span>  
  
 <span data-ttu-id="cd7f1-118">Os operadores de XPath são divididos em quatro categorias:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-118">XPath operators are divided into four categories:</span></span>  
  
-   <span data-ttu-id="cd7f1-119">Operadores boolianos (e, ou)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-119">Boolean operators (and, or)</span></span>  
  
-   <span data-ttu-id="cd7f1-120">Operadores relacionais ( \<, > , \<=, > =)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-120">Relational operators (\<, >, \<=, >=)</span></span>  
  
-   <span data-ttu-id="cd7f1-121">Operadores de igualdade (=, !=)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-121">Equality operators (=, !=)</span></span>  
  
-   <span data-ttu-id="cd7f1-122">Operadores aritméticos (+, -, \*, div, mod)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-122">Arithmetic operators (+, -, \*, div, mod)</span></span>  
  
 <span data-ttu-id="cd7f1-123">Cada categoria de operador converte os respectivos operandos de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-123">Each category of operator converts its operands differently.</span></span> <span data-ttu-id="cd7f1-124">Os operadores de XPath convertem implicitamente seus operandos se necessário.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-124">XPath operators implicitly convert their operands if necessary.</span></span> <span data-ttu-id="cd7f1-125">Os operadores aritméticos convertem seus operandos em `number` e resultam em um valor numérico.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-125">Arithmetic operators convert their operands to `number`, and result in a number value.</span></span> <span data-ttu-id="cd7f1-126">Os operadores boolianos convertem seus operandos em `boolean` e resultam em um valor booliano.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-126">Boolean operators convert their operands to `boolean`, and result in a Boolean value.</span></span> <span data-ttu-id="cd7f1-127">Os operadores relacionais e operadores de igualdade resultam em um valor booliano.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-127">Relational operators and equality operators result in a Boolean value.</span></span> <span data-ttu-id="cd7f1-128">Entretanto, eles têm diferentes regras de conversão dependendo dos tipos de dados originais dos respectivos operandos, conforme mostra esta tabela.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-128">However, they have different conversion rules depending on the original data types of their operands, as shown in this table.</span></span>  
  
|<span data-ttu-id="cd7f1-129">Operando</span><span class="sxs-lookup"><span data-stu-id="cd7f1-129">Operand</span></span>|<span data-ttu-id="cd7f1-130">Operador relacional</span><span class="sxs-lookup"><span data-stu-id="cd7f1-130">Relational operator</span></span>|<span data-ttu-id="cd7f1-131">Operador de igualdade</span><span class="sxs-lookup"><span data-stu-id="cd7f1-131">Equality operator</span></span>|  
|-------------|-------------------------|-----------------------|  
|<span data-ttu-id="cd7f1-132">Ambos os operandos são conjuntos de nós.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-132">Both operands are node-sets.</span></span>|<span data-ttu-id="cd7f1-133">TRUE se e somente se houver um nó em um conjunto e um nó no segundo conjunto de modo que a comparação de seus valores de `string` seja TRUE.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-133">TRUE if and only if there is a node in one set and a node in the second set such that the comparison of their `string` values is TRUE.</span></span>|<span data-ttu-id="cd7f1-134">Idem.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-134">Same.</span></span>|  
|<span data-ttu-id="cd7f1-135">Um é um conjunto de nós, o outro é uma `string`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-135">One is a node-set, the other a `string`.</span></span>|<span data-ttu-id="cd7f1-136">TRUE se e somente se houver um nó no conjunto de nós de modo que, quando convertido em `number`, a comparação dele com a `string` convertida em `number` seja TRUE.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-136">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `string` converted to `number` is TRUE.</span></span>|<span data-ttu-id="cd7f1-137">TRUE se e somente se houver um nó no conjunto de nós de modo que, quando convertido em `string`, a comparação dele com a `string` seja TRUE.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-137">TRUE if and only if there is a node in the node-set such that when converted to `string`, the comparison of it with the `string` is TRUE.</span></span>|  
|<span data-ttu-id="cd7f1-138">Um é um conjunto de nós, o outro é uma `number`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-138">One is a node-set, the other a `number`.</span></span>|<span data-ttu-id="cd7f1-139">TRUE se e somente se houver um nó no conjunto de nós de modo que, quando convertido em `number`, a comparação dele com a `number` seja TRUE.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-139">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `number` is TRUE.</span></span>|<span data-ttu-id="cd7f1-140">Idem.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-140">Same.</span></span>|  
|<span data-ttu-id="cd7f1-141">Um é um conjunto de nós, o outro é uma `boolean`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-141">One is a node-set, the other a `boolean`.</span></span>|<span data-ttu-id="cd7f1-142">TRUE se e somente se houver um nó no conjunto de nós de modo que, quando convertido em `boolean` e depois em `number`, a comparação dele com o `boolean` convertido em `number` seja TRUE.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-142">TRUE if and only if there is a node in the node-set such that when converted to `boolean` and then to `number`, the comparison of it with the `boolean` converted to `number` is TRUE.</span></span>|<span data-ttu-id="cd7f1-143">TRUE se e somente se houver um nó no conjunto de nós de modo que, quando convertido em `boolean`, a comparação dele com a `boolean` seja TRUE.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-143">TRUE if and only if there is a node in the node-set such that when converted to `boolean`, the comparison of it with the `boolean` is TRUE.</span></span>|  
|<span data-ttu-id="cd7f1-144">Nenhum é um conjunto de nós.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-144">Neither is a node-set.</span></span>|<span data-ttu-id="cd7f1-145">Converta ambos os operandos em `number` e compare.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-145">Convert both operands to `number` and then compare.</span></span>|<span data-ttu-id="cd7f1-146">Converta ambos os operandos em um tipo comum e compare.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-146">Convert both operands to a common type and then compare.</span></span> <span data-ttu-id="cd7f1-147">Converta em `boolean` se qualquer um dos dois for `boolean` e em `number` se qualquer um dos dois for `number`; caso contrário, converta em `string`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-147">Convert to `boolean` if either is `boolean`, `number` if either is `number`; otherwise, convert to `string`.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="cd7f1-148">Como os operadores relacionais de XPath sempre convertem seus operandos em `number`, comparações de `string` não são possíveis.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-148">Because XPath relational operators always convert their operands to `number`, `string` comparisons are not possible.</span></span> <span data-ttu-id="cd7f1-149">Para incluir comparações de data, o SQL Server 2000 oferece essa variação da especificação do XPath: quando um operador relacional compara uma `string` com uma `string`, um conjunto de nós com uma `string` ou um conjunto de nós de valor de cadeia de caracteres com um conjunto de nós de valor de cadeia de caracteres, é executada uma comparação de `string` (e não uma comparação de `number`).</span><span class="sxs-lookup"><span data-stu-id="cd7f1-149">To include date comparisons, SQL Server 2000 offers this variation to the XPath specification: When a relational operator compares a `string` to a `string`, a node-set to a `string`, or a string-valued node-set to a string-valued node-set, a `string` comparison (not a `number` comparison) is performed.</span></span>  
  
## <a name="node-set-conversions"></a><span data-ttu-id="cd7f1-150">Conversões de conjuntos de nós</span><span class="sxs-lookup"><span data-stu-id="cd7f1-150">Node-Set Conversions</span></span>  
 <span data-ttu-id="cd7f1-151">As conversões de conjuntos de nós nem sempre são intuitivas.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-151">Node-set conversions are not always intuitive.</span></span> <span data-ttu-id="cd7f1-152">Um conjunto de nós é convertido em `string` obtendo o valor da cadeia de caracteres somente do primeiro nó do conjunto.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-152">A node-set is converted to a `string` by taking the string value of only the first node in the set.</span></span> <span data-ttu-id="cd7f1-153">Um conjunto de nós é convertido em `number` convertendo-o em `string` e convertendo `string` em `number`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-153">A node-set is converted to `number` by converting it to `string`, and then converting `string` to `number`.</span></span> <span data-ttu-id="cd7f1-154">Um conjunto de nós é convertido em `boolean` testando sua existência.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-154">A node-set is converted to `boolean` by testing for its existence.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="cd7f1-155">O [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] não executa a seleção posicional nos conjuntos de nós: por exemplo, a consulta do XPath `Customer[3]` significa o terceiro cliente; não há suporte a esse tipo de seleção posicional no [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="cd7f1-155">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] does not perform positional selection on node-sets: for example, the XPath query `Customer[3]` means the third customer; this type of positional selection is not supported in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="cd7f1-156">Portanto, as conversões de conjunto de nós em `string` ou de conjunto de nós em `number` conforme descritas pela especificação do XPath não são implementadas.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-156">Therefore, the node-set-to-`string` or node-set-to-`number` conversions as described by the XPath specification are not implemented.</span></span> <span data-ttu-id="cd7f1-157">O [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] usa "qualquer" semântica sempre que a especificação do XPath define "primeira" semântica.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-157">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses "any" semantics wherever the XPath specification specifies "first" semantics.</span></span> <span data-ttu-id="cd7f1-158">Por exemplo, com base na especificação XPath do W3C, a consulta XPath `Order[OrderDetail/@UnitPrice > 10.0]` seleciona esses pedidos com a primeira **OrderDetail** com **PreçoUnitário** maior que 10,0.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-158">For example, based on the W3C XPath specification, the XPath query `Order[OrderDetail/@UnitPrice > 10.0]` selects those orders with the first **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span> <span data-ttu-id="cd7f1-159">No [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , essa consulta XPath seleciona esses pedidos com qualquer **OrderDetail** que tenha um **PreçoUnitário** maior que 10,0.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], this XPath query selects those orders with any **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span>  
  
 <span data-ttu-id="cd7f1-160">A conversão em `boolean` gera um teste de existência; por isso, a consulta do XPath `Products[@Discontinued=true()]` é equivalente à expressão SQL "Products.Discontinued is not null", e não à expressão SQL "Products.Discontinued = 1".</span><span class="sxs-lookup"><span data-stu-id="cd7f1-160">Conversion to `boolean` generates an existence test; therefore, the XPath query `Products[@Discontinued=true()]` is equivalent to the SQL expression "Products.Discontinued is not null", not the SQL expression "Products.Discontinued = 1".</span></span> <span data-ttu-id="cd7f1-161">Para tornar a consulta equivalente a essa última expressão SQL, primeiro converta o conjunto de nós em um tipo não `boolean`, como `number`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-161">To make the query equivalent to the latter SQL expression, first convert the node-set to a non-`boolean` type, such as `number`.</span></span> <span data-ttu-id="cd7f1-162">Por exemplo, `Products[number(@Discontinued) = true()]`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-162">For example, `Products[number(@Discontinued) = true()]`.</span></span>  
  
 <span data-ttu-id="cd7f1-163">Como a maioria dos operadores é definida como TRUE se é TRUE para qualquer um ou para um dos nós do conjunto, essas operações sempre avaliam como FALSE se o conjunto está vazio.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-163">Because most operators are defined to be TRUE if they are TRUE for any or one of the nodes in the node-set, these operations always evaluate to FALSE if the node-set is empty.</span></span> <span data-ttu-id="cd7f1-164">Assim, se A está vazio, tanto `A = B` quanto `A != B` são FALSE, e `not(A=B)` e `not(A!=B)` são TRUE.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-164">Thus, if A is empty, both `A = B` and `A != B` are FALSE, and `not(A=B)` and `not(A!=B)` are TRUE.</span></span>  
  
 <span data-ttu-id="cd7f1-165">Normalmente, um atributo ou elemento que mapeia para uma coluna existe se o valor dessa coluna no banco de dados não é `null`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-165">Usually, an attribute or element that maps to a column exists if the value of that column in the database is not `null`.</span></span> <span data-ttu-id="cd7f1-166">Os elementos que fazem o mapeamento para linhas existirão se qualquer um dos filhos existir.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-166">Elements that map to rows exist if any of their children exist.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="cd7f1-167">Elementos anotados com `is-constant` sempre existem.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-167">Elements annotated with `is-constant` always exist.</span></span> <span data-ttu-id="cd7f1-168">Consequentemente, os predicados do XPath não podem ser usados em elementos `is-constant`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-168">Consequently, XPath predicates cannot be used on `is-constant` elements.</span></span>  
  
 <span data-ttu-id="cd7f1-169">Quando um conjunto de nós é convertido em `string` ou `number`, seu tipo XDR (se houver) é inspecionado no esquema anotado e esse tipo é usado para determinar a conversão necessária.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-169">When a node-set is converted to `string` or `number`, its XDR type (if any) is inspected in the annotated schema and that type is used to determine the conversion that is required.</span></span>  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a><span data-ttu-id="cd7f1-170">Mapeando tipos de dados XDR para tipos de dados XPath</span><span class="sxs-lookup"><span data-stu-id="cd7f1-170">Mapping XDR Data Types to XPath Data Types</span></span>  
 <span data-ttu-id="cd7f1-171">O tipo de dados XPath de um nó é derivado do tipo de dados XDR no esquema, conforme mostrado na tabela a seguir (o nó **EmployeeID** é usado para fins ilustrativos).</span><span class="sxs-lookup"><span data-stu-id="cd7f1-171">The XPath data type of a node is derived from the XDR data type in the schema, as shown in the following table (the node **EmployeeID** is used for illustrative purpose).</span></span>  
  
|<span data-ttu-id="cd7f1-172">Tipo de dados XDR</span><span class="sxs-lookup"><span data-stu-id="cd7f1-172">XDR data type</span></span>|<span data-ttu-id="cd7f1-173">Equivalente</span><span class="sxs-lookup"><span data-stu-id="cd7f1-173">Equivalent</span></span><br /><br /> <span data-ttu-id="cd7f1-174">tipos de dados XPath</span><span class="sxs-lookup"><span data-stu-id="cd7f1-174">XPath data type</span></span>|<span data-ttu-id="cd7f1-175">Conversão do SQL Server usada</span><span class="sxs-lookup"><span data-stu-id="cd7f1-175">SQL Server conversion used</span></span>|  
|-------------------|------------------------------------|--------------------------------|  
|<span data-ttu-id="cd7f1-176">Nonebin.base64bin.hex</span><span class="sxs-lookup"><span data-stu-id="cd7f1-176">Nonebin.base64bin.hex</span></span>|<span data-ttu-id="cd7f1-177">N/D</span><span class="sxs-lookup"><span data-stu-id="cd7f1-177">N/A</span></span>|<span data-ttu-id="cd7f1-178">NoneEmployeeID</span><span class="sxs-lookup"><span data-stu-id="cd7f1-178">NoneEmployeeID</span></span>|  
|<span data-ttu-id="cd7f1-179">booleano</span><span class="sxs-lookup"><span data-stu-id="cd7f1-179">boolean</span></span>|<span data-ttu-id="cd7f1-180">booleano</span><span class="sxs-lookup"><span data-stu-id="cd7f1-180">boolean</span></span>|<span data-ttu-id="cd7f1-181">CONVERT(bit, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-181">CONVERT(bit, EmployeeID)</span></span>|  
|<span data-ttu-id="cd7f1-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span><span class="sxs-lookup"><span data-stu-id="cd7f1-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span></span>|<span data-ttu-id="cd7f1-183">número</span><span class="sxs-lookup"><span data-stu-id="cd7f1-183">number</span></span>|<span data-ttu-id="cd7f1-184">CONVERT(float(53), EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-184">CONVERT(float(53), EmployeeID)</span></span>|  
|<span data-ttu-id="cd7f1-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span><span class="sxs-lookup"><span data-stu-id="cd7f1-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span></span>|<span data-ttu-id="cd7f1-186">string</span><span class="sxs-lookup"><span data-stu-id="cd7f1-186">string</span></span>|<span data-ttu-id="cd7f1-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span></span>|  
|<span data-ttu-id="cd7f1-188">fixed14.4</span><span class="sxs-lookup"><span data-stu-id="cd7f1-188">fixed14.4</span></span>|<span data-ttu-id="cd7f1-189">N/D (não há nenhum tipo de dados no XPath equivalente ao tipo de dados XDR fixed14.4)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-189">N/A(There is no data type in XPath that is equivalent to the fixed14.4 XDR data type)</span></span>|<span data-ttu-id="cd7f1-190">CONVERT(money, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-190">CONVERT(money, EmployeeID)</span></span>|  
|<span data-ttu-id="cd7f1-191">date</span><span class="sxs-lookup"><span data-stu-id="cd7f1-191">date</span></span>|<span data-ttu-id="cd7f1-192">string</span><span class="sxs-lookup"><span data-stu-id="cd7f1-192">string</span></span>|<span data-ttu-id="cd7f1-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span></span>|  
|<span data-ttu-id="cd7f1-194">time</span><span class="sxs-lookup"><span data-stu-id="cd7f1-194">time</span></span><br /><br /> <span data-ttu-id="cd7f1-195">time.tz</span><span class="sxs-lookup"><span data-stu-id="cd7f1-195">time.tz</span></span>|<span data-ttu-id="cd7f1-196">string</span><span class="sxs-lookup"><span data-stu-id="cd7f1-196">string</span></span>|<span data-ttu-id="cd7f1-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span></span>|  
  
 <span data-ttu-id="cd7f1-198">As conversões de data e hora são projetadas para funcionar independentemente de o valor ser armazenado no banco de dados do usando o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` tipo ou um `string` .</span><span class="sxs-lookup"><span data-stu-id="cd7f1-198">The date and time conversions are designed to work whether the value is stored in the database using the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type or a `string`.</span></span> <span data-ttu-id="cd7f1-199">Observe que o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` tipo de dados não usa `timezone` e tem uma precisão menor do que o `time` tipo de dados XML.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-199">Note that the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type does not use `timezone` and has a smaller precision than the XML `time` data type.</span></span> <span data-ttu-id="cd7f1-200">Para incluir o tipo de dados `timezone` ou precisão adicional, armazene os dados no [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] usando um tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-200">To include the `timezone` data type or additional precision, store the data in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] using a `string` type.</span></span>  
  
 <span data-ttu-id="cd7f1-201">Quando um nó é convertido do tipo de dados XDR no tipo de dados XPath, às vezes é necessária conversão adicional (de um tipo de dados XPath para outro tipo de dados XPath).</span><span class="sxs-lookup"><span data-stu-id="cd7f1-201">When a node is converted from its XDR data type to the XPath data type, additional conversion is sometimes necessary (from one XPath data type to another XPath data type).</span></span> <span data-ttu-id="cd7f1-202">Por exemplo, considere esta consulta do XPath:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-202">For example, consider this XPath query:</span></span>  
  
```  
(@m + 3) = 4  
```  
  
 <span data-ttu-id="cd7f1-203">Se @m for do `fixed14.4` tipo de dados XDR, a conversão do tipo de dados XDR para tipo de dados XPath será realizada usando:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-203">If @m is of the `fixed14.4` XDR data type, the conversion from XDR data type to XPath data type is accomplished using:</span></span>  
  
```  
CONVERT(money, m)  
```  
  
 <span data-ttu-id="cd7f1-204">Nessa conversão, o nó `m` é convertido de `fixed14.4` em `money`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-204">In this conversion, the node `m` is converted from `fixed14.4` to `money`.</span></span> <span data-ttu-id="cd7f1-205">Porém, a adição do valor de 3 exige conversão adicional:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-205">However, adding the value of 3, requires additional conversion:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 <span data-ttu-id="cd7f1-206">A expressão do XPath é avaliada como:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-206">The XPath expression is evaluated as:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 <span data-ttu-id="cd7f1-207">Conforme mostra a tabela a seguir, essa é a mesma conversão aplicada para outras expressões do XPath (como literais ou expressões compostas).</span><span class="sxs-lookup"><span data-stu-id="cd7f1-207">As shown in the following table, this is the same conversion that is applied for other XPath expressions (such as literals or compound expressions).</span></span>  
  
||||||  
|-|-|-|-|-|  
||<span data-ttu-id="cd7f1-208">X é a incógnita</span><span class="sxs-lookup"><span data-stu-id="cd7f1-208">X is unknown</span></span>|<span data-ttu-id="cd7f1-209">X é `string`</span><span class="sxs-lookup"><span data-stu-id="cd7f1-209">X is `string`</span></span>|<span data-ttu-id="cd7f1-210">X é `number`</span><span class="sxs-lookup"><span data-stu-id="cd7f1-210">X is `number`</span></span>|<span data-ttu-id="cd7f1-211">X é `boolean`</span><span class="sxs-lookup"><span data-stu-id="cd7f1-211">X is `boolean`</span></span>|  
|<span data-ttu-id="cd7f1-212">string(X)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-212">string(X)</span></span>|<span data-ttu-id="cd7f1-213">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-213">CONVERT (nvarchar(4000), X, 126)</span></span>|-|<span data-ttu-id="cd7f1-214">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-214">CONVERT (nvarchar(4000), X, 126)</span></span>|<span data-ttu-id="cd7f1-215">CASE WHEN X THEN N'true' ELSE N'false' END</span><span class="sxs-lookup"><span data-stu-id="cd7f1-215">CASE WHEN X THEN N'true' ELSE N'false' END</span></span>|  
|<span data-ttu-id="cd7f1-216">number(X)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-216">number(X)</span></span>|<span data-ttu-id="cd7f1-217">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-217">CONVERT (float(53), X)</span></span>|<span data-ttu-id="cd7f1-218">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-218">CONVERT (float(53), X)</span></span>|-|<span data-ttu-id="cd7f1-219">CASE WHEN X THEN 1 ELSE 0 END</span><span class="sxs-lookup"><span data-stu-id="cd7f1-219">CASE WHEN X THEN 1 ELSE 0 END</span></span>|  
|<span data-ttu-id="cd7f1-220">boolean(X)</span><span class="sxs-lookup"><span data-stu-id="cd7f1-220">boolean(X)</span></span>|-|<span data-ttu-id="cd7f1-221">LEN (X) > 0</span><span class="sxs-lookup"><span data-stu-id="cd7f1-221">LEN(X) > 0</span></span>|<span data-ttu-id="cd7f1-222">X != 0</span><span class="sxs-lookup"><span data-stu-id="cd7f1-222">X != 0</span></span>|-|  
  
## <a name="examples"></a><span data-ttu-id="cd7f1-223">Exemplos</span><span class="sxs-lookup"><span data-stu-id="cd7f1-223">Examples</span></span>  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a><span data-ttu-id="cd7f1-224">a.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-224">A.</span></span> <span data-ttu-id="cd7f1-225">Converter um tipo de dados em uma consulta do XPath</span><span class="sxs-lookup"><span data-stu-id="cd7f1-225">Convert a data type in an XPath query</span></span>  
 <span data-ttu-id="cd7f1-226">Na consulta XPath a seguir especificada em um esquema XSD anotado, a consulta seleciona todos os nós de **funcionário** com o valor de atributo **EmployeeID** de e-1, em que "E-" é o prefixo especificado usando a `sql:id-prefix` anotação.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-226">In the following XPath query specified against an annotated XSD schema, the query selects all **Employee** nodes with the **EmployeeID** attribute value of E-1, where "E-" is the prefix specified using the `sql:id-prefix` annotation.</span></span>  
  
 `Employee[@EmployeeID="E-1"]`  
  
 <span data-ttu-id="cd7f1-227">O predicado na consulta é equivalente à expressão SQL:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-227">The predicate in the query is equivalent to the SQL expression:</span></span>  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 <span data-ttu-id="cd7f1-228">Como **EmployeeID** é um dos `id` valores de `idref` tipo de dados (, `idrefs` ,, `nmtoken` `nmtokens` e assim por diante) no esquema XSD, **EmployeeID** é convertido para o `string` tipo de dados XPath usando as regras de conversão descritas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-228">Because **EmployeeID** is one of the `id` (`idref`, `idrefs`, `nmtoken`, `nmtokens`, and so on) data type values in the XSD schema, **EmployeeID** is converted to the `string` XPath data type using the conversion rules described previously.</span></span>  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 <span data-ttu-id="cd7f1-229">O prefixo "E -" é adicionado à cadeia de caracteres, e o resultado é comparado com `N'E-1'`.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-229">The "E-" prefix is added to the string, and the result is then compared with `N'E-1'`.</span></span>  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a><span data-ttu-id="cd7f1-230">B.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-230">B.</span></span> <span data-ttu-id="cd7f1-231">Executar várias conversões de tipo de dados em uma consulta do XPath</span><span class="sxs-lookup"><span data-stu-id="cd7f1-231">Perform several data type conversions in an XPath query</span></span>  
 <span data-ttu-id="cd7f1-232">Considere esta consulta do XPath especificada com base em um esquema XSD anotado: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span><span class="sxs-lookup"><span data-stu-id="cd7f1-232">Consider this XPath query specified against an annotated XSD schema: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span></span>  
  
 <span data-ttu-id="cd7f1-233">Essa consulta XPath retorna todos os **\<OrderDetail>** elementos que atendem ao predicado `@UnitPrice * @OrderQty > 98` .</span><span class="sxs-lookup"><span data-stu-id="cd7f1-233">This XPath query returns all the **\<OrderDetail>** elements satisfying the predicate `@UnitPrice * @OrderQty > 98`.</span></span> <span data-ttu-id="cd7f1-234">Se o **PreçoUnitário** for anotado com um `fixed14.4` tipo de dados no esquema anotado, esse predicado será equivalente à expressão SQL:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-234">If the **UnitPrice** is annotated with a `fixed14.4` data type in the annotated schema, this predicate is equivalent to the SQL expression:</span></span>  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 <span data-ttu-id="cd7f1-235">Ao converter os valores na consulta do XPath, ocorre a primeira conversão do tipo de dados XDR no tipo de dados XPath.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-235">In converting the values in the XPath query, the first conversion converts the XDR data type to the XPath data type.</span></span> <span data-ttu-id="cd7f1-236">Como o tipo de dados XSD de **PreçoUnitário** é `fixed14.4` , conforme descrito na tabela anterior, esta é a primeira conversão que é usada:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-236">Because the XSD data type of **UnitPrice** is `fixed14.4`, as described in the previous table, this is the first conversion that is used:</span></span>  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="cd7f1-237">Como os operadores aritméticos convertem os operandos no tipo de dados XPath `number`, a segunda conversão (de um tipo de dados XPath em outro tipo de dados XPath) é aplicada, no qual o valor é convertido em `float(53)` (`float(53)` está próximo ao tipo de dados `number` do XPath):</span><span class="sxs-lookup"><span data-stu-id="cd7f1-237">Because the arithmetic operators convert their operands to the `number` XPath data type, the second conversion (from one XPath data type to another XPath data type) is applied in which the value is converted to `float(53)` (`float(53)` is close to the XPath `number` data type):</span></span>  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="cd7f1-238">Supondo que o atributo **OrderQty** não tenha nenhum tipo de dados XSD, **OrderQty** é convertido em um `number` tipo de dados XPath em uma única conversão:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-238">Assuming the **OrderQty** attribute has no XSD data type, **OrderQty** is converted to a `number` XPath data type in a single conversion:</span></span>  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 <span data-ttu-id="cd7f1-239">Da mesma maneira, o valor 98 é convertido no tipo de dados XPath `number`:</span><span class="sxs-lookup"><span data-stu-id="cd7f1-239">Similarly, the value 98 is converted to the `number` XPath data type:</span></span>  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  <span data-ttu-id="cd7f1-240">Se o tipo de dados XSD usado no esquema for incompatível com o tipo de dados subjacente do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] no banco de dados ou se for executada uma conversão impossível de tipo de dados XPath, o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] poderá retornar um erro.</span><span class="sxs-lookup"><span data-stu-id="cd7f1-240">If the XSD data type used in the schema is incompatible with the underlying [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data type in the database, or if an impossible XPath data type conversion is performed, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] may return an error.</span></span> <span data-ttu-id="cd7f1-241">Por exemplo, se o atributo **EmployeeID** for anotado com `id-prefix` anotação, o XPath `Employee[@EmployeeID=1]` gerará um erro, pois **EmployeeID** tem a `id-prefix` anotação e não pode ser convertido em `number` .</span><span class="sxs-lookup"><span data-stu-id="cd7f1-241">For example, if the **EmployeeID** attribute is annotated with `id-prefix` annotation, the XPath `Employee[@EmployeeID=1]` generates an error, because **EmployeeID** has the `id-prefix` annotation and cannot be converted to `number`.</span></span>  
  
  
