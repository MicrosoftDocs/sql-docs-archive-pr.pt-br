---
title: Desempenho da integração CLR | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- common language runtime [SQL Server], performance
- common language runtime [SQL Server], compilation process
- performance [CLR integration]
ms.assetid: 7ce2dfc0-4b1f-4dcb-a979-2c4f95b4cb15
author: rothja
ms.author: jroth
ms.openlocfilehash: 33e45039ed98ea3df607df1714b3c6108ec17c35
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87682277"
---
# <a name="performance-of-clr-integration"></a><span data-ttu-id="e387a-102">Desempenho da integração CLR</span><span class="sxs-lookup"><span data-stu-id="e387a-102">Performance of CLR Integration</span></span>
  <span data-ttu-id="e387a-103">Este tópico discute algumas das opções de design que aprimoram o desempenho da [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integração com o [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="e387a-103">This topic discusses some of the design choices that enhance the performance of [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integration with the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR).</span></span>  
  
## <a name="the-compilation-process"></a><span data-ttu-id="e387a-104">O processo de compilação</span><span class="sxs-lookup"><span data-stu-id="e387a-104">The Compilation Process</span></span>  
 <span data-ttu-id="e387a-105">Durante a compilação de expressões SQL, quando é encontrada uma referência a uma rotina, é gerado um stub do MSIL ([!INCLUDE[msCoName](../../../includes/msconame-md.md)] Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="e387a-105">During compilation of SQL expressions, when a reference to a managed routine is encountered, a [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL) stub is generated.</span></span> <span data-ttu-id="e387a-106">Esse stub inclui código para realizar marshaling dos parâmetros de rotina do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] para o CLR, invocar a função e retornar o resultado.</span><span class="sxs-lookup"><span data-stu-id="e387a-106">This stub includes code to marshal the routine parameters from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to the CLR, invoke the function, and return the result.</span></span> <span data-ttu-id="e387a-107">Este código de "cola" se baseia no tipo de parâmetro e na direção do parâmetro (de entrada, de saída ou de referência).</span><span class="sxs-lookup"><span data-stu-id="e387a-107">This "glue" code is based on the type of parameter and on parameter direction (in, out, or reference).</span></span>  
  
 <span data-ttu-id="e387a-108">O código cola permite otimizações específicas do tipo e assegura a imposição eficiente da semântica do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], como a nulidade, a restrição de facetas, o tratamento de exceções por valor e padrão.</span><span class="sxs-lookup"><span data-stu-id="e387a-108">The glue code enables type-specific optimizations and ensures efficient enforcement of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] semantics, such as nullability, constraining facets, by-value, and standard exception handling.</span></span> <span data-ttu-id="e387a-109">Ao gerar código para os tipos exatos dos argumentos, você evita a coerção de tipos ou custos com a criação de objetos wrapper (o chamado "boxing") além do limite de invocação.</span><span class="sxs-lookup"><span data-stu-id="e387a-109">By generating code for the exact types of the arguments, you avoid type coercion or wrapper object creation costs (called "boxing") across the invocation boundary.</span></span>  
  
 <span data-ttu-id="e387a-110">O stub gerado é então compilado em código nativo e otimizado para a arquitetura de hardware específica na qual o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] é executado, usando os serviços de compilação JIT (just-in-time) do CLR.</span><span class="sxs-lookup"><span data-stu-id="e387a-110">The generated stub is then compiled to native code and optimized for the particular hardware architecture on which [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] executes, using the JIT (just-in-time) compilation services of the CLR.</span></span> <span data-ttu-id="e387a-111">Os serviços JIT são invocados no nível de método e permitem que o ambiente de hospedagem do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] crie uma única unidade de compilação que se estende pelas execuções do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] e do CLR.</span><span class="sxs-lookup"><span data-stu-id="e387a-111">The JIT services are invoked at the method level and allow the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hosting environment to create a single compilation unit that spans both [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and CLR execution.</span></span> <span data-ttu-id="e387a-112">Depois que o stub é compilado, o ponteiro de função resultante se torna a implementação em tempo de execução da função.</span><span class="sxs-lookup"><span data-stu-id="e387a-112">Once the stub is compiled, the resulting function pointer becomes the run-time implementation of the function.</span></span> <span data-ttu-id="e387a-113">Essa abordagem da geração de código assegura que não haja custos adicionais com a invocação relacionados com a reflexão ou o acesso de metadados em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="e387a-113">This code generation approach ensures that there are no additional invocation costs related to reflection or metadata access at run time.</span></span>  
  
### <a name="fast-transitions-between-sql-server-and-clr"></a><span data-ttu-id="e387a-114">Transições rápidas entre o SQL Server e o CLR</span><span class="sxs-lookup"><span data-stu-id="e387a-114">Fast Transitions Between SQL Server and CLR</span></span>  
 <span data-ttu-id="e387a-115">O processo de compilação gera um ponteiro de função que pode ser chamado em tempo de execução a partir do código nativo.</span><span class="sxs-lookup"><span data-stu-id="e387a-115">The compilation process yields a function pointer that can be called at run time from native code.</span></span> <span data-ttu-id="e387a-116">No caso de funções definidas pelo usuário com valor escalar, essa invocação de função ocorre por linha.</span><span class="sxs-lookup"><span data-stu-id="e387a-116">In the case of scalar-valued user-defined functions, this function invocation happens on a per-row basis.</span></span> <span data-ttu-id="e387a-117">A fim de minimizar o custo da transição entre o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] e o CLR, as instruções que contêm qualquer invocação gerenciada têm uma etapa de inicialização para identificar o domínio do aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="e387a-117">To minimize the cost of transitioning between [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR, statements that contain any managed invocation have a startup step to identify the target application domain.</span></span> <span data-ttu-id="e387a-118">Essa etapa de identificação reduz o custo de transição de cada linha.</span><span class="sxs-lookup"><span data-stu-id="e387a-118">This identification step reduces the cost of transitioning for each row.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="e387a-119">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="e387a-119">Performance Considerations</span></span>  
 <span data-ttu-id="e387a-120">Segue um resumo das considerações de desempenho específicas da integração CLR no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e387a-120">The following summarizes performance considerations specific to CLR integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="e387a-121">Informações mais detalhadas podem ser encontradas em "[usando a integração CLR no SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" no site do MSDN.</span><span class="sxs-lookup"><span data-stu-id="e387a-121">More detailed information can be found in "[Using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" on the MSDN Web site.</span></span> <span data-ttu-id="e387a-122">Informações gerais sobre o desempenho do código gerenciado podem ser encontradas em "[melhorando o desempenho e a escalabilidade do aplicativo .net](https://go.microsoft.com/fwlink/?LinkId=50333)" no site do MSDN.</span><span class="sxs-lookup"><span data-stu-id="e387a-122">General information regarding managed code performance can be found in "[Improving .NET Application Performance and Scalability](https://go.microsoft.com/fwlink/?LinkId=50333)" on the MSDN Web site.</span></span>  
  
### <a name="user-defined-functions"></a><span data-ttu-id="e387a-123">Funções definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="e387a-123">User-Defined Functions</span></span>  
 <span data-ttu-id="e387a-124">As funções CLR se beneficiam de um caminho de invocação mais rápido que o das funções definidas pelo usuário do [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e387a-124">CLR functions benefit from a quicker invocation path than that of [!INCLUDE[tsql](../../../includes/tsql-md.md)] user-defined functions.</span></span> <span data-ttu-id="e387a-125">Além disso, o código gerenciado tem uma vantagem de desempenho decisiva sobre o [!INCLUDE[tsql](../../../includes/tsql-md.md)] em termos de código de procedimento, computação e manipulação de cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="e387a-125">Additionally, managed code has a decisive performance advantage over [!INCLUDE[tsql](../../../includes/tsql-md.md)] in terms of procedural code, computation, and string manipulation.</span></span> <span data-ttu-id="e387a-126">As funções CLR que utilizam muitos recursos de computação e que não executam acesso a dados são melhor escritas em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="e387a-126">CLR functions that are computing-intensive and that do not perform data access are better written in managed code.</span></span> <span data-ttu-id="e387a-127">Entretanto, as funções [!INCLUDE[tsql](../../../includes/tsql-md.md)] executam o acesso a dados de forma mais eficiente que a integração CLR.</span><span class="sxs-lookup"><span data-stu-id="e387a-127">[!INCLUDE[tsql](../../../includes/tsql-md.md)] functions do, however, perform data access more efficiently than CLR integration.</span></span>  
  
### <a name="user-defined-aggregates"></a><span data-ttu-id="e387a-128">Agregações definidas pelo usuário</span><span class="sxs-lookup"><span data-stu-id="e387a-128">User-Defined Aggregates</span></span>  
 <span data-ttu-id="e387a-129">O código gerenciado pode ter um desempenho significativamente melhor que a agregação baseada em cursor.</span><span class="sxs-lookup"><span data-stu-id="e387a-129">Managed code can significantly outperform cursor-based aggregation.</span></span> <span data-ttu-id="e387a-130">Em geral, o desempenho do código gerenciado é um pouco mais lento que o das funções de agregação internas do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e387a-130">Managed code generally performs slightly slower than built-in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aggregate functions.</span></span> <span data-ttu-id="e387a-131">Se houver uma função de agregação interna nativa, é recomendável utilizá-la.</span><span class="sxs-lookup"><span data-stu-id="e387a-131">We recommend that if a native built-in aggregate function exists, you should use it.</span></span> <span data-ttu-id="e387a-132">Nos casos em que não há suporte nativo para a agregação necessária, por motivos de desempenho, considere uma agregação CLR definida pelo usuário como superior a uma implementação baseada em cursor.</span><span class="sxs-lookup"><span data-stu-id="e387a-132">In cases in which the needed aggregation is not natively supported, consider a CLR user-defined aggregate over a cursor-based implementation for performance reasons.</span></span>  
  
### <a name="streaming-table-valued-functions"></a><span data-ttu-id="e387a-133">Funções de streaming com valor de tabela</span><span class="sxs-lookup"><span data-stu-id="e387a-133">Streaming Table-Valued Functions</span></span>  
 <span data-ttu-id="e387a-134">Frequentemente, os aplicativos precisam retornar uma tabela como resultado da invocação de uma função.</span><span class="sxs-lookup"><span data-stu-id="e387a-134">Applications often need to return a table as a result of invoking a function.</span></span> <span data-ttu-id="e387a-135">Exemplos incluem a leitura de dados tabulares de um arquivo como parte de uma operação de importação e a conversão de valores separados por vírgula em uma representação relacional.</span><span class="sxs-lookup"><span data-stu-id="e387a-135">Examples include reading tabular data from a file as part of an import operation, and converting comma-separated-values to a relational representation.</span></span> <span data-ttu-id="e387a-136">Normalmente, isso pode ser feito materializando e preenchendo a tabela de resultados antes de ela poder ser consumida pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="e387a-136">Typically, you can accomplish this by materializing and populating the result table before it can be consumed by the caller.</span></span> <span data-ttu-id="e387a-137">A integração do CLR no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduz um novo mecanismo de extensibilidade chamado STVF (função de streaming com valor de tabela).</span><span class="sxs-lookup"><span data-stu-id="e387a-137">The integration of the CLR into [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduces a new extensibility mechanism called a streaming table-valued function (STVF).</span></span> <span data-ttu-id="e387a-138">As STVFs gerenciadas têm um desempenho melhor que o de implementações de procedimentos armazenados estendidos comparáveis.</span><span class="sxs-lookup"><span data-stu-id="e387a-138">Managed STVFs perform better than comparable extended stored procedure implementations.</span></span>  
  
 <span data-ttu-id="e387a-139">As STVFs são funções gerenciadas que retornam uma interface `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="e387a-139">STVFs are managed functions that return an `IEnumerable` interface.</span></span> <span data-ttu-id="e387a-140">A `IEnumerable` tem métodos para navegar pelo conjunto de resultados retornado pela STVF.</span><span class="sxs-lookup"><span data-stu-id="e387a-140">`IEnumerable` has methods to navigate the result set returned by the STVF.</span></span> <span data-ttu-id="e387a-141">Quando a STVF é invocada, a `IEnumerable` retornada é conectada diretamente ao plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="e387a-141">When the STVF is invoked, the returned `IEnumerable` is directly connected to the query plan.</span></span> <span data-ttu-id="e387a-142">O plano de consulta chamará métodos de `IEnumerable` quando for necessário buscar linhas.</span><span class="sxs-lookup"><span data-stu-id="e387a-142">The query plan calls `IEnumerable` methods when it needs to fetch rows.</span></span> <span data-ttu-id="e387a-143">Esse modelo de iteração permite que os resultados sejam consumidos imediatamente depois que a primeira linha é gerada, em vez de aguardar até que toda a tabela seja preenchida.</span><span class="sxs-lookup"><span data-stu-id="e387a-143">This iteration model allows results to be consumed immediately after the first row is produced, instead of waiting until the entire table is populated.</span></span> <span data-ttu-id="e387a-144">Ele também reduz significativamente a memória consumida ao invocar a função.</span><span class="sxs-lookup"><span data-stu-id="e387a-144">It also significantly reduces the memory consumed by invoking the function.</span></span>  
  
### <a name="arrays-vs-cursors"></a><span data-ttu-id="e387a-145">Matrizes vs. cursores</span><span class="sxs-lookup"><span data-stu-id="e387a-145">Arrays vs. Cursors</span></span>  
 <span data-ttu-id="e387a-146">Quando os cursores [!INCLUDE[tsql](../../../includes/tsql-md.md)] devem atravessar dados que são expressos mais facilmente como uma matriz, é possível usar código gerenciado com ganhos de desempenho significativos.</span><span class="sxs-lookup"><span data-stu-id="e387a-146">When [!INCLUDE[tsql](../../../includes/tsql-md.md)] cursors must traverse data that is more easily expressed as an array, managed code can be used with significant performance gains.</span></span>  
  
### <a name="string-data"></a><span data-ttu-id="e387a-147">Dados de cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="e387a-147">String Data</span></span>  
 <span data-ttu-id="e387a-148">Em funções gerenciadas, os dados de caracteres do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], como `varchar`, podem ser do tipo SqlString ou SqlChars.</span><span class="sxs-lookup"><span data-stu-id="e387a-148">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] character data, such as `varchar`, can be of the type SqlString or SqlChars in managed functions.</span></span> <span data-ttu-id="e387a-149">As variáveis SqlString criam uma instância do valor inteiro na memória.</span><span class="sxs-lookup"><span data-stu-id="e387a-149">SqlString variables create an instance of the entire value into memory.</span></span> <span data-ttu-id="e387a-150">As variáveis SqlChars fornecem uma interface de streaming que pode ser usada para obter um melhor desempenho e escalabilidade por não criar uma instância do valor inteiro na memória.</span><span class="sxs-lookup"><span data-stu-id="e387a-150">SqlChars variables provide a streaming interface that can be used to achieve better performance and scalability by not creating an instance of the entire value into memory.</span></span> <span data-ttu-id="e387a-151">Isso se torna especialmente importante no caso de dados LOB (objeto grande).</span><span class="sxs-lookup"><span data-stu-id="e387a-151">This becomes particularly important for large object (LOB) data.</span></span> <span data-ttu-id="e387a-152">Além disso, os dados XML do servidor podem ser acessados por meio de uma interface de streaming retornada por `SqlXml.CreateReader()`.</span><span class="sxs-lookup"><span data-stu-id="e387a-152">Additionally, server XML data can be accessed through a streaming interface returned by `SqlXml.CreateReader()`.</span></span>  
  
### <a name="clr-vs-extended-stored-procedures"></a><span data-ttu-id="e387a-153">CLR vs. procedimentos armazenados estendidos</span><span class="sxs-lookup"><span data-stu-id="e387a-153">CLR vs. Extended Stored Procedures</span></span>  
 <span data-ttu-id="e387a-154">As APIs Microsoft.SqlServer.Server que permitem que procedimentos gerenciados enviem conjuntos de resultados de volta ao cliente têm um desempenho melhor que as APIs ODS (Open Data Services) usadas por procedimentos armazenados estendidos.</span><span class="sxs-lookup"><span data-stu-id="e387a-154">The Microsoft.SqlServer.Server application programming interfaces (APIs) that allow managed procedures to send result sets back to the client perform better than the Open Data Services (ODS) APIs used by extended stored procedures.</span></span> <span data-ttu-id="e387a-155">Além disso, as APIs System.Data.SqlServer dão suporte a tipos de dados como `xml`, `varchar(max)`, `nvarchar(max)` e `varbinary(max)`, introduzidos no [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], enquanto as APIs ODS não foram estendidas para dar suporte aos novos tipos de dados.</span><span class="sxs-lookup"><span data-stu-id="e387a-155">Furthermore, the System.Data.SqlServer APIs support data types such as `xml`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)`, introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], while the ODS APIs have not been extended to support the new data types.</span></span>  
  
 <span data-ttu-id="e387a-156">Com o código gerenciado, o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] gerencia o uso de recursos como a memória, os threads e a sincronização.</span><span class="sxs-lookup"><span data-stu-id="e387a-156">With managed code, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] manages use of resources such as memory, threads, and synchronization.</span></span> <span data-ttu-id="e387a-157">Isso se deve ao fato de as APIs gerenciadas que expõem esses recursos serem implementadas sobre o gerenciador de recursos do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e387a-157">This is because the managed APIs that expose these resources are implemented on top of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] resource manager.</span></span> <span data-ttu-id="e387a-158">Por outro lado, o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] não tem nenhuma exibição ou controle sobre o uso de recursos do procedimento armazenado estendido.</span><span class="sxs-lookup"><span data-stu-id="e387a-158">Conversely, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has no view or control over the resource usage of the extended stored procedure.</span></span> <span data-ttu-id="e387a-159">Por exemplo, se um procedimento armazenado estendido consumir muitos recursos de CPU ou de memória, não há uma forma de detectá-lo ou controlá-lo com o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e387a-159">For example, if an extended stored procedure consumes too much CPU or memory resources, there is no way to detect or control this with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="e387a-160">Contudo, com o código gerenciado, o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] pode detectar que um determinado thread não teve resultados por um longo período e então forçar a geração da tarefa, de forma que outros trabalhos possam ser agendados.</span><span class="sxs-lookup"><span data-stu-id="e387a-160">With managed code, however, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can detect that a given thread has not yielded for a long period of time, and then force the task to yield so that other work can be scheduled.</span></span> <span data-ttu-id="e387a-161">Consequentemente, o uso do código gerenciado fornece uma escalabilidade e um uso de recursos do sistema melhores.</span><span class="sxs-lookup"><span data-stu-id="e387a-161">Consequently, using managed code provides for better scalability and system resource usage.</span></span>  
  
 <span data-ttu-id="e387a-162">O código gerenciado pode incorrer em uma sobrecarga adicional necessária para manter o ambiente de execução e executar verificações de segurança.</span><span class="sxs-lookup"><span data-stu-id="e387a-162">Managed code may incur additional overhead necessary to maintain the execution environment and perform security checks.</span></span> <span data-ttu-id="e387a-163">Isso ocorre, por exemplo, ao executar no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] quando várias transições do código gerenciado para o código nativo são necessárias (porque o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] precisa executar uma manutenção adicional em configurações específicas de threads ao passar para o código nativo e voltar).</span><span class="sxs-lookup"><span data-stu-id="e387a-163">This is the case, for example, when running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and numerous transitions from managed to native code are required (because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] needs to do additional maintenance on thread-specific settings when moving out to native code and back).</span></span> <span data-ttu-id="e387a-164">Consequentemente, os procedimentos armazenados estendidos podem ter um desempenho significativamente melhor que o código gerenciado executado no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], nos casos em que há transições frequentes entre o código gerenciado e o código nativo.</span><span class="sxs-lookup"><span data-stu-id="e387a-164">Consequently, extended stored procedures can significantly outperform managed code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for cases in which there are frequent transitions between managed and native code.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="e387a-165">É recomendável não desenvolver novos procedimentos armazenados estendidos, pois esse recurso foi preterido.</span><span class="sxs-lookup"><span data-stu-id="e387a-165">It is recommended that you do not develop new extended stored procedures, because this feature has been deprecated.</span></span>  
  
### <a name="native-serialization-for-user-defined-types"></a><span data-ttu-id="e387a-166">Serialização nativa para tipos definidos pelo usuário</span><span class="sxs-lookup"><span data-stu-id="e387a-166">Native Serialization for User-Defined Types</span></span>  
 <span data-ttu-id="e387a-167">Os UDTs (tipos definidos pelo usuário) são criados como um mecanismo de extensibilidade para o sistema de tipo de escalar.</span><span class="sxs-lookup"><span data-stu-id="e387a-167">User-defined types (UDTs) are designed as an extensibility mechanism for the scalar type system.</span></span> <span data-ttu-id="e387a-168">O [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] implementa um formato de serialização para UDTs chamado `Format.Native`.</span><span class="sxs-lookup"><span data-stu-id="e387a-168">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] implements a serialization format for UDTs called `Format.Native`.</span></span> <span data-ttu-id="e387a-169">Durante a compilação, a estrutura do tipo é examinada para gerar MSIL personalizado para esta definição de tipo de particular.</span><span class="sxs-lookup"><span data-stu-id="e387a-169">During compilation, the structure of the type is examined to generate MSIL that is customized for that particular type definition.</span></span>  
  
 <span data-ttu-id="e387a-170">A serialização nativa é a implementação padrão do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e387a-170">Native serialization is the default implementation for [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="e387a-171">A serialização definida pelo usuário invoca um método definido pelo autor do tipo para fazer a serialização.</span><span class="sxs-lookup"><span data-stu-id="e387a-171">User-defined serialization invokes a method defined by the type author to do the serialization.</span></span> <span data-ttu-id="e387a-172">A serialização `Format.Native` dever ser usada quando possível para obter um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="e387a-172">`Format.Native` serialization should be used when possible for best performance.</span></span>  
  
### <a name="normalization-of-comparable-udts"></a><span data-ttu-id="e387a-173">Normalização de UDTs comparáveis</span><span class="sxs-lookup"><span data-stu-id="e387a-173">Normalization of Comparable UDTs</span></span>  
 <span data-ttu-id="e387a-174">As operações relacionais, como a classificação e a comparação de UDTs, funcionam diretamente na representação binária do valor.</span><span class="sxs-lookup"><span data-stu-id="e387a-174">Relational operations, such as sorting and comparing UDTs, operate directly on the binary representation of the value.</span></span> <span data-ttu-id="e387a-175">Isto é realizado armazenando uma representação normalizada (em ordem binária) do estado do UDT no disco.</span><span class="sxs-lookup"><span data-stu-id="e387a-175">This is accomplished by storing a normalized (binary ordered) representation of the state of the UDT on disk.</span></span>  
  
 <span data-ttu-id="e387a-176">A normalização tem duas vantagens: torna a operação de comparação consideravelmente menos cara por evitar a construção da instância de tipo e a sobrecarga de invocação do método, além de criar um domínio binário para o UDT, permitindo a construção de histogramas, índices e histogramas de valores do tipo.</span><span class="sxs-lookup"><span data-stu-id="e387a-176">Normalization has two benefits: it makes the comparison operation considerably less expensive by avoiding the construction of the type instance and the method invocation overhead; and it creates a binary domain for the UDT, enabling the construction of histograms, indexes, and histograms for values of the type.</span></span> <span data-ttu-id="e387a-177">Consequentemente, os UDTs normalizados têm um perfil de desempenho muito semelhante ao dos tipos internos nativos para operações que não envolvem a invocação do método.</span><span class="sxs-lookup"><span data-stu-id="e387a-177">Consequently, normalized UDTs have a very similar performance profile to the native built-in types for operations that do not involve method invocation.</span></span>  
  
### <a name="scalable-memory-usage"></a><span data-ttu-id="e387a-178">Uso da memória escalonável</span><span class="sxs-lookup"><span data-stu-id="e387a-178">Scalable Memory Usage</span></span>  
 <span data-ttu-id="e387a-179">Para que coleta de lixo gerenciada seja executada e bem-escalada no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], evite uma única alocação grande.</span><span class="sxs-lookup"><span data-stu-id="e387a-179">In order for managed garbage collection to perform and scale well in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], avoid large, single allocation.</span></span> <span data-ttu-id="e387a-180">As alocações com mais de 88 quilobytes (KB) serão colocadas no heap de objetos grandes, que fará o desempenho e a escala da coleta de lixo serem muito piores que no caso de várias alocações menores.</span><span class="sxs-lookup"><span data-stu-id="e387a-180">Allocations greater than 88 kilobytes (KB) in size will be placed on the Large Object Heap, which will cause garbage collection to perform and scale much worse than many smaller allocations.</span></span> <span data-ttu-id="e387a-181">Por exemplo, se você precisar alocar uma matriz multidimensional grande, é melhor alocar uma matriz denteada (dispersa).</span><span class="sxs-lookup"><span data-stu-id="e387a-181">For example, if you need to allocate a large multi-dimensional array, it is better to allocate a jagged (scattered) array.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e387a-182">Consulte Também</span><span class="sxs-lookup"><span data-stu-id="e387a-182">See Also</span></span>  
 [<span data-ttu-id="e387a-183">Tipos definido pelo usuário CLR</span><span class="sxs-lookup"><span data-stu-id="e387a-183">CLR User-Defined Types</span></span>](../clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  
