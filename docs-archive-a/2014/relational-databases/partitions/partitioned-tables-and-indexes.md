---
title: Tabelas e índices particionados | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87684675"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="fb181-102">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="fb181-102">Partitioned Tables and Indexes</span></span>
  <span data-ttu-id="fb181-103">O[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] oferece suporte ao particionamento de tabelas e índices.</span><span class="sxs-lookup"><span data-stu-id="fb181-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] supports table and index partitioning.</span></span> <span data-ttu-id="fb181-104">Os dados de tabelas e índices particionados são divididos em unidades que podem ser difundidas por mais de um grupo de arquivos em um banco de dados.</span><span class="sxs-lookup"><span data-stu-id="fb181-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="fb181-105">Os dados são particionados horizontalmente, de forma que os grupos de linhas são mapeados em partições individuais.</span><span class="sxs-lookup"><span data-stu-id="fb181-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="fb181-106">Todas as partições de um único índice ou de uma única tabela devem residir no mesmo banco de dados.</span><span class="sxs-lookup"><span data-stu-id="fb181-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="fb181-107">A tabela ou o índice é tratado como uma única entidade lógica quando são executadas consultas ou atualizações nos dados.</span><span class="sxs-lookup"><span data-stu-id="fb181-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="fb181-108">As tabelas e os índices particionados não estão disponíveis em todas as edições de [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="fb181-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="fb181-109">Para obter uma lista de recursos com suporte nas edições do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], consulte [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span><span class="sxs-lookup"><span data-stu-id="fb181-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="fb181-110">O[!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] oferece suporte a até 15.000 partições por padrão.</span><span class="sxs-lookup"><span data-stu-id="fb181-110">[!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="fb181-111">Nas versões anteriores do [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], o número de partições foi limitado a 1.000 por padrão. Nos sistemas baseados em x86, a criação de uma tabela ou de um índice com mais de 1000 partições é possível, mas não tem suporte.</span><span class="sxs-lookup"><span data-stu-id="fb181-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="fb181-112">Benefícios do particionamento</span><span class="sxs-lookup"><span data-stu-id="fb181-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="fb181-113">O particionamento de tabelas ou índices grandes pode ter a capacidade de gerenciamento e os benefícios de desempenho a seguir.</span><span class="sxs-lookup"><span data-stu-id="fb181-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="fb181-114">Você pode transferir ou acessar subconjuntos de dados de forma rápida e eficaz e, ao mesmo tempo, manter a integridade de uma coleção de dados.</span><span class="sxs-lookup"><span data-stu-id="fb181-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="fb181-115">Por exemplo, uma operação como o carregamento de dados de um sistema OLTP para OLAP leva apenas segundos, em vez dos minutos ou horas necessários quando os dados não estão paticionados.</span><span class="sxs-lookup"><span data-stu-id="fb181-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="fb181-116">Você pode executar operações de manutenção mais rapidamente em uma ou mais partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="fb181-117">As operações são mais eficientes porque elas visam apenas estes subconjuntos de dados, e não a tabela inteira.</span><span class="sxs-lookup"><span data-stu-id="fb181-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="fb181-118">Por exemplo, você pode optar por compactar dados em uma ou mais partições ou recriar uma ou mais partições de um índice.</span><span class="sxs-lookup"><span data-stu-id="fb181-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="fb181-119">Você pode aprimorar o desempenho de consultas com base nos tipos de consultas executadas com frequência e em sua configuração de hardware.</span><span class="sxs-lookup"><span data-stu-id="fb181-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="fb181-120">Por exemplo, o otimizador de consulta pode processar consultas de junção de igualdade entre duas ou mais tabelas particionadas mais rápido quando as colunas de particionamento nas tabelas são iguais, porque as próprias partições podem ser unidas.</span><span class="sxs-lookup"><span data-stu-id="fb181-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="fb181-121">Quando o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] executa classificação de dados para operações de E/S, ele classifica os dados primeiro pela partição.</span><span class="sxs-lookup"><span data-stu-id="fb181-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> <span data-ttu-id="fb181-122">O[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] acessa uma unidade de cada vez e isso pode reduzir o desempenho.</span><span class="sxs-lookup"><span data-stu-id="fb181-122">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="fb181-123">Para melhorar o desempenho da classificação de dados, distribua os arquivos de dados de suas partições em mais de um disco configurando um RAID.</span><span class="sxs-lookup"><span data-stu-id="fb181-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="fb181-124">Dessa maneira, embora o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ainda classifique os dados por partição, ele pode acessar todas as unidades de cada partição ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="fb181-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="fb181-125">Além disso, você pode melhorar o desempenho habilitando o escalonamento de bloqueios em nível de partição em, e não em uma tabela inteira.</span><span class="sxs-lookup"><span data-stu-id="fb181-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="fb181-126">Isso pode reduzir a contenção de bloqueio na tabela.</span><span class="sxs-lookup"><span data-stu-id="fb181-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="fb181-127">Componentes e conceitos</span><span class="sxs-lookup"><span data-stu-id="fb181-127">Components and Concepts</span></span>  
 <span data-ttu-id="fb181-128">As condições a seguir são aplicáveis ao particionamento de tabela e de índice.</span><span class="sxs-lookup"><span data-stu-id="fb181-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="fb181-129">Função de partição</span><span class="sxs-lookup"><span data-stu-id="fb181-129">Partition function</span></span>  
 <span data-ttu-id="fb181-130">Um objeto de banco de dados que define como as linhas de uma tabela ou índice são mapeadas para um conjunto de partições, com base nos valores de determinada coluna, chamada de coluna de particionamento.</span><span class="sxs-lookup"><span data-stu-id="fb181-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="fb181-131">Ou seja, a função de partição define o número de partições que a tabela terá e como serão definidos os limites das partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="fb181-132">Por exemplo, considerando uma tabela que contém dados de ordem de venda, você pode desejar particionar a tabela em doze (mensalmente) partições com base em uma coluna `datetime` como uma data de vendas.</span><span class="sxs-lookup"><span data-stu-id="fb181-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="fb181-133">Esquema de partição</span><span class="sxs-lookup"><span data-stu-id="fb181-133">Partition scheme</span></span>  
 <span data-ttu-id="fb181-134">Um objeto de banco de dados que mapeia as partições de uma função de partição para um conjunto de grupos de arquivos.</span><span class="sxs-lookup"><span data-stu-id="fb181-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="fb181-135">O principal motivo para colocar suas partições em grupos de arquivos separados é para garantir que poderá efetuar operações de backup em partições de forma independente.</span><span class="sxs-lookup"><span data-stu-id="fb181-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="fb181-136">Isso porque se pode executar backups em grupos de arquivos individuais.</span><span class="sxs-lookup"><span data-stu-id="fb181-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="fb181-137">Coluna de particionamento</span><span class="sxs-lookup"><span data-stu-id="fb181-137">Partitioning column</span></span>  
 <span data-ttu-id="fb181-138">A coluna de uma tabela ou índice que uma função de partição usa para particionar a tabela ou índice.</span><span class="sxs-lookup"><span data-stu-id="fb181-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="fb181-139">Colunas computadas que participam de uma função de partição devem ser marcadas explicitamente como PERSISTED.</span><span class="sxs-lookup"><span data-stu-id="fb181-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="fb181-140">Todos os tipos de dados que são válidos para uso como colunas de índice podem ser usados como uma coluna de particionamento, exceto `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="fb181-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="fb181-141">Os tipos de dados `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)` ou `varbinary(max)` não podem ser especificados.</span><span class="sxs-lookup"><span data-stu-id="fb181-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="fb181-142">Também, não podem ser especificados o tipo definido pelo usuário do CLR (Common Language Runtime) do Microsoft .NET Framework e colunas de tipo de dados do alias.</span><span class="sxs-lookup"><span data-stu-id="fb181-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="fb181-143">Índice alinhado</span><span class="sxs-lookup"><span data-stu-id="fb181-143">Aligned index</span></span>  
 <span data-ttu-id="fb181-144">Um índice que é baseado no mesmo esquema de partição que sua tabela correspondente.</span><span class="sxs-lookup"><span data-stu-id="fb181-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="fb181-145">Quando uma tabela e seus índices estão em alinhamento, o SQL Server pode alternar partições rápida e eficientemente e, ao mesmo tempo, manter a estrutura de partição da tabela e de seus índices.</span><span class="sxs-lookup"><span data-stu-id="fb181-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="fb181-146">Um índice não precisa participar na mesma função de partição nomeada para ser alinhado com sua tabela base.</span><span class="sxs-lookup"><span data-stu-id="fb181-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="fb181-147">Entretanto, a função de partição de um índice e a tabela base devem ser essencialmente as mesmas, em que 1) os argumentos das funções de partição têm o mesmo tipo de dados, 2) eles definem o mesmo número de partições, e 3) eles definem os mesmos valores de limite para as partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="fb181-148">Índice não alinhado</span><span class="sxs-lookup"><span data-stu-id="fb181-148">Nonaligned index</span></span>  
 <span data-ttu-id="fb181-149">Um índice particionado independentemente de sua tabela correspondente.</span><span class="sxs-lookup"><span data-stu-id="fb181-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="fb181-150">Quer dizer, o índice tem um esquema de partição diferente ou é colocado em um grupo de arquivos separado da tabela base.</span><span class="sxs-lookup"><span data-stu-id="fb181-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="fb181-151">A criação de um índice particionado não alinhado pode ser útil nos seguintes casos:</span><span class="sxs-lookup"><span data-stu-id="fb181-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="fb181-152">A tabela base não foi particionada.</span><span class="sxs-lookup"><span data-stu-id="fb181-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="fb181-153">A chave de índice é exclusiva e não contém a coluna de particionamento da tabela.</span><span class="sxs-lookup"><span data-stu-id="fb181-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="fb181-154">Você deseja que a tabela base participe de junções colocadas com mais tabelas que usam colunas de junção diferentes.</span><span class="sxs-lookup"><span data-stu-id="fb181-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="fb181-155">Eliminação de partição</span><span class="sxs-lookup"><span data-stu-id="fb181-155">Partition elimination</span></span>  
 <span data-ttu-id="fb181-156">O processo pelo qual o otimizador de consulta acessa apenas as partições relevantes para satisfazer os critérios de filtro da consulta.</span><span class="sxs-lookup"><span data-stu-id="fb181-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="fb181-157">Diretrizes de desempenho</span><span class="sxs-lookup"><span data-stu-id="fb181-157">Performance Guidelines</span></span>  
 <span data-ttu-id="fb181-158">O limite novo, superior de 15.000 partições afeta a memória, operações de índice particionadas, comandos DBCC e consultas.</span><span class="sxs-lookup"><span data-stu-id="fb181-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="fb181-159">Esta seção descreve as implicações de desempenho de aumentar o número de partições acima de 1.000 e fornece soluções alternativas quando necessário.</span><span class="sxs-lookup"><span data-stu-id="fb181-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="fb181-160">Com o limite no número máximo de partições elevado para 15.000, você pode armazenar dados por mais tempo.</span><span class="sxs-lookup"><span data-stu-id="fb181-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="fb181-161">Porém, você só deve reter dados enquanto necessário e manter um equilíbrio entre desempenho e número de partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="fb181-162">Uso de memória e diretrizes</span><span class="sxs-lookup"><span data-stu-id="fb181-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="fb181-163">É recomendável usar pelo menos 16 GB de RAM se um número grande de partições estiver em uso.</span><span class="sxs-lookup"><span data-stu-id="fb181-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="fb181-164">Se o sistema não tiver memória suficiente, instruções DML (linguagem de manipulação de dados), instruções DDL (linguagem de definição de dados) e outras operações poderão falhar devido à memória insuficiente.</span><span class="sxs-lookup"><span data-stu-id="fb181-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="fb181-165">Sistemas com 16 GB de RAM que executam muitos processos com uso intenso de memória podem ficar sem memória em operações executadas em um número grande de partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="fb181-166">Portanto, quanto mais memória você tiver acima de 16 GB, menor será a probabilidade de encontrar problemas de desempenho e memória.</span><span class="sxs-lookup"><span data-stu-id="fb181-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="fb181-167">As limitações de memória podem afetar o desempenho ou a capacidade do SQL Server de criar um índice particionado.</span><span class="sxs-lookup"><span data-stu-id="fb181-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="fb181-168">Este será o caso especialmente quando o índice não está alinhado com sua tabela base ou não está alinhado com o índice clusterizado, se a tabela já tiver um índice clusterizado aplicado a ela.</span><span class="sxs-lookup"><span data-stu-id="fb181-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="fb181-169">Operações de índice particionado</span><span class="sxs-lookup"><span data-stu-id="fb181-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="fb181-170">As limitações de memória podem afetar o desempenho ou a capacidade do SQL Server de criar um índice particionado.</span><span class="sxs-lookup"><span data-stu-id="fb181-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="fb181-171">Este é especialmente o caso com índices não alinhados.</span><span class="sxs-lookup"><span data-stu-id="fb181-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="fb181-172">É possível criar e reconstruir índices não alinhados em uma tabela com mais de 1.000 partições, mas não há suporte para isso.</span><span class="sxs-lookup"><span data-stu-id="fb181-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="fb181-173">Fazer isso pode provocar degradação do desempenho ou consumo excessivo de memória durante essas operações.</span><span class="sxs-lookup"><span data-stu-id="fb181-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="fb181-174">A criação e a recompilação de índices alinhados poderão demorar mais para serem executadas à medida que aumentar o número de partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="fb181-175">É recomendável não executar vários comandos de índice de criação e recriação ao mesmo tempo porque você pode encontrar problemas de desempenho e memória.</span><span class="sxs-lookup"><span data-stu-id="fb181-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="fb181-176">Quando o SQL Server executar uma classificação para criar índices particionados, ele criará primeiro uma tabela de classificação para cada partição.</span><span class="sxs-lookup"><span data-stu-id="fb181-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="fb181-177">Ele criará as tabelas de classificação no respectivo grupo de arquivos de cada partição ou no `tempdb`, se a opção de índice SORT_IN_TEMPDB for especificada.</span><span class="sxs-lookup"><span data-stu-id="fb181-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="fb181-178">Cada tabela de classificação exige uma quantia mínima de memória para construir.</span><span class="sxs-lookup"><span data-stu-id="fb181-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="fb181-179">Quando você estiver construindo um índice particionado que está alinhado com a tabela base, uma tabela de classificação por vez será criada, usando menos memória.</span><span class="sxs-lookup"><span data-stu-id="fb181-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="fb181-180">Porém, quando você estiver construindo um índice particionado não alinhado, as tabelas de classificação serão criadas ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="fb181-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="fb181-181">Como resultado, deve haver memória suficiente para controlar essas classificações simultâneas.</span><span class="sxs-lookup"><span data-stu-id="fb181-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="fb181-182">Quanto maior o número de partições, mais memória será necessária.</span><span class="sxs-lookup"><span data-stu-id="fb181-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="fb181-183">O tamanho mínimo para cada tabela de classificação, para cada partição é de 40 páginas, com 8 quilobites por página.</span><span class="sxs-lookup"><span data-stu-id="fb181-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="fb181-184">Por exemplo, um índice particionado não alinhado com 100 partições requer memória suficiente para classificar serialmente 4.000 (40 x 100) páginas ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="fb181-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="fb181-185">Se essa memória estiver disponível, a operação de construção terá sucesso, mas o desempenho poderá ser afetado.</span><span class="sxs-lookup"><span data-stu-id="fb181-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="fb181-186">Se essa memória não estiver disponível, a operação de criação falhará.</span><span class="sxs-lookup"><span data-stu-id="fb181-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="fb181-187">Como alternativa, um índice particionado alinhado com 100 partições requer apenas memória suficiente para classificar serialmente 40 páginas, porque as classificações não são executadas ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="fb181-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="fb181-188">Para ambos os índices, alinhados e não alinhados, os requisitos de memória poderão ser maiores se o SQL Server aplicar graus de paralelismo à operação de criação em um computador com multiprocessador.</span><span class="sxs-lookup"><span data-stu-id="fb181-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="fb181-189">Isso ocorre porque quanto maior os graus de paralelismo, maior será o requisito de memória.</span><span class="sxs-lookup"><span data-stu-id="fb181-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="fb181-190">Por exemplo, se o SQL Server define os graus de paralelismo como 4, um índice particionado não alinhado com 100 partições requer memória suficiente para quatro processadores para classificar serialmente 4.000 páginas, ao mesmo tempo, ou 16.000 páginas.</span><span class="sxs-lookup"><span data-stu-id="fb181-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="fb181-191">Se o índice particionado for alinhado, o requisito de memória será reduzido para quatro processadores classificando 40 páginas, 160 (4 x 40) páginas.</span><span class="sxs-lookup"><span data-stu-id="fb181-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="fb181-192">Você pode usar a opção de índice MAXDOP para reduzir os graus de paralelismo manualmente.</span><span class="sxs-lookup"><span data-stu-id="fb181-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="fb181-193">Comandos DBCC</span><span class="sxs-lookup"><span data-stu-id="fb181-193">DBCC Commands</span></span>  
 <span data-ttu-id="fb181-194">Com um número maior de partições, os comandos DBCC podem demorar mais para serem executados à medida que aumentar o número de partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="fb181-195">Consultas</span><span class="sxs-lookup"><span data-stu-id="fb181-195">Queries</span></span>  
 <span data-ttu-id="fb181-196">Consultas que usam a eliminação de partição podem ter desempenho comparável ou aprimorado com número maior de partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="fb181-197">Consultas que não usam a eliminação de partição podem levar mais tempo para executar à medida que o número de partições aumenta.</span><span class="sxs-lookup"><span data-stu-id="fb181-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="fb181-198">Por exemplo, digamos que uma tabela tem 100 milhões de linhas e colunas `A`, `B`e `C`.</span><span class="sxs-lookup"><span data-stu-id="fb181-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="fb181-199">No cenário 1, a tabela é dividida em 1.000 partições na coluna `A`.</span><span class="sxs-lookup"><span data-stu-id="fb181-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="fb181-200">No cenário 2, a tabela é dividida em 10.000 partições na coluna `A`.</span><span class="sxs-lookup"><span data-stu-id="fb181-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="fb181-201">Uma consulta na tabela que tem uma cláusula WHERE filtrada na coluna `A` executará a eliminação de partição e examinará uma partição.</span><span class="sxs-lookup"><span data-stu-id="fb181-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="fb181-202">Essa mesma consulta pode ser executada mais rapidamente no cenário 2, pois há menos linhas a serem examinadas em uma partição.</span><span class="sxs-lookup"><span data-stu-id="fb181-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="fb181-203">Uma consulta com uma cláusula WHERE filtrada na coluna B examinará todas as partições.</span><span class="sxs-lookup"><span data-stu-id="fb181-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="fb181-204">A consulta pode ser executada mais rapidamente no cenário 1 do que no cenário 2, pois há menos partições a serem examinadas.</span><span class="sxs-lookup"><span data-stu-id="fb181-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="fb181-205">As consultas que usam operadores como TOP ou MAX/MIN em colunas que não sejam a coluna de particionamento podem sofrer redução do desempenho com o particionamento porque todas as partições precisam ser avaliadas.</span><span class="sxs-lookup"><span data-stu-id="fb181-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="fb181-206">Alterações de comportamento em computação de estatísticas durante operações de índice particionadas</span><span class="sxs-lookup"><span data-stu-id="fb181-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="fb181-207">A partir do [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], as estatísticas não são criadas por meio do exame de todas as linhas da tabela quando um índice particionado é criado ou reconstruído.</span><span class="sxs-lookup"><span data-stu-id="fb181-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="fb181-208">Em vez disso, o otimizador de consultas usa o algoritmo de amostragem padrão para gerar estatísticas.</span><span class="sxs-lookup"><span data-stu-id="fb181-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="fb181-209">Depois de atualizar um banco de dados com índices particionados, você pode notar uma diferença nos dados de histograma destes índices.</span><span class="sxs-lookup"><span data-stu-id="fb181-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="fb181-210">Esta alteração no comportamento pode não afetar o desempenho de consulta.</span><span class="sxs-lookup"><span data-stu-id="fb181-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="fb181-211">Para obter estatísticas em índices particionados por meio do exame de todas as linhas da tabela, use CREATE STATISTICS ou UPDATE STATISTICS com a cláusula FULLSCAN.</span><span class="sxs-lookup"><span data-stu-id="fb181-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="fb181-212">Related Tasks</span><span class="sxs-lookup"><span data-stu-id="fb181-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fb181-213">**Tarefas**</span><span class="sxs-lookup"><span data-stu-id="fb181-213">**Tasks**</span></span>|<span data-ttu-id="fb181-214">**Tópico**</span><span class="sxs-lookup"><span data-stu-id="fb181-214">**Topic**</span></span>|  
|<span data-ttu-id="fb181-215">Descreve como criar funções de partição e esquemas de partição, e depois aplicá-los a uma tabela e índice.</span><span class="sxs-lookup"><span data-stu-id="fb181-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="fb181-216">Criar tabelas e índices particionados</span><span class="sxs-lookup"><span data-stu-id="fb181-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="fb181-217">Conteúdo relacionado</span><span class="sxs-lookup"><span data-stu-id="fb181-217">Related Content</span></span>  
 <span data-ttu-id="fb181-218">Você pode localizar os livros brancos a seguir em estratégias e implementações úteis de tabelas e índices particionados.</span><span class="sxs-lookup"><span data-stu-id="fb181-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="fb181-219">[Estratégias de tabelas e índices particionados usando o SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="fb181-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="fb181-220">[Como implementar uma janela deslizante automática](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="fb181-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="fb181-221">Carregamento em massa em uma tabela particionada</span><span class="sxs-lookup"><span data-stu-id="fb181-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="fb181-222">Aperfeiçoamentos de processamento de consultas em tabelas e índices particionados</span><span class="sxs-lookup"><span data-stu-id="fb181-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="fb181-223">10 principais práticas recomendadas para a criação de um Data Warehouse relacional em grande escala</span><span class="sxs-lookup"><span data-stu-id="fb181-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
