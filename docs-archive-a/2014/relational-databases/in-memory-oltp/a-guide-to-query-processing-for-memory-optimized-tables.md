---
title: Um guia para processamento de consulta de tabelas com otimização de memória | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 065296fe-6711-4837-965e-252ef6c13a0f
author: rothja
ms.author: jroth
ms.openlocfilehash: 93489e5dea295964826005e081bcffe889cb7586
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87581821"
---
# <a name="a-guide-to-query-processing-for-memory-optimized-tables"></a><span data-ttu-id="05054-102">Um guia para processamento de consulta de tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="05054-102">A Guide to Query Processing for Memory-Optimized Tables</span></span>
  <span data-ttu-id="05054-103">O OLTP na memória incorpora as tabelas com otimização de memória e os procedimentos armazenados compilados nativamente no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="05054-103">In-Memory OLTP introduces memory-optimized tables and natively compiled stored procedures in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="05054-104">Este artigo fornece uma visão geral do processamento de consulta para tabelas com otimização de memória e procedimentos armazenados compilados nativamente.</span><span class="sxs-lookup"><span data-stu-id="05054-104">This article gives an overview of query processing for both memory-optimized tables and natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="05054-105">O documento explica como as consultas em tabelas com otimização de memória são compiladas e executadas, incluindo:</span><span class="sxs-lookup"><span data-stu-id="05054-105">The document explains how queries on memory-optimized tables are compiled and executed, including:</span></span>  
  
-   <span data-ttu-id="05054-106">O pipeline do processamento de consulta no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] para tabelas baseadas em disco.</span><span class="sxs-lookup"><span data-stu-id="05054-106">The query processing pipeline in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for disk-based tables.</span></span>  
  
-   <span data-ttu-id="05054-107">Otimização de consulta; a função de estatísticas sobre tabelas com otimização de memória, bem como diretrizes para solucionar problemas de planos de consulta incorretos.</span><span class="sxs-lookup"><span data-stu-id="05054-107">Query optimization; the role of statistics on memory-optimized tables as well as guidelines for troubleshooting bad query plans.</span></span>  
  
-   <span data-ttu-id="05054-108">O uso do [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado para acessar tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="05054-108">The use of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] to access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="05054-109">Considerações sobre a otimização de consulta no acesso à tabela com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="05054-109">Considerations about query optimization for memory-optimized table access.</span></span>  
  
-   <span data-ttu-id="05054-110">Compilação e processamento do procedimento armazenado originalmente compilado.</span><span class="sxs-lookup"><span data-stu-id="05054-110">Natively compiled stored procedure compilation and processing.</span></span>  
  
-   <span data-ttu-id="05054-111">Estatísticas que são usadas para estimativa de custo pelo otimizador.</span><span class="sxs-lookup"><span data-stu-id="05054-111">Statistics that are used for cost estimation by the optimizer.</span></span>  
  
-   <span data-ttu-id="05054-112">Modos de corrigir planos de consulta incorretos.</span><span class="sxs-lookup"><span data-stu-id="05054-112">Ways to fix bad query plans.</span></span>  
  
## <a name="example-query"></a><span data-ttu-id="05054-113">Consulta de exemplo</span><span class="sxs-lookup"><span data-stu-id="05054-113">Example Query</span></span>  
 <span data-ttu-id="05054-114">O exemplo a seguir será usado para ilustrar conceitos de processamento de consulta discutidos neste artigo.</span><span class="sxs-lookup"><span data-stu-id="05054-114">The following example will be used to illustrate the query processing concepts discussed in this article.</span></span>  
  
 <span data-ttu-id="05054-115">Vamos considerar duas tabelas, Customer e Order.</span><span class="sxs-lookup"><span data-stu-id="05054-115">We consider two tables, Customer and Order.</span></span> <span data-ttu-id="05054-116">O script [!INCLUDE[tsql](../../../includes/tsql-md.md)] a seguir contém as definições dessas duas tabelas e os índices associados, em seu formato baseado em disco (tradicional):</span><span class="sxs-lookup"><span data-stu-id="05054-116">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains the definitions for these two tables and associated indexes, in their (traditional) disk-based form:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY,  
  ContactName nvarchar (30) NOT NULL   
)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY,  
  CustomerID nchar (5) NOT NULL,  
  OrderDate date NOT NULL  
)  
GO  
CREATE INDEX IX_CustomerID ON dbo.[Order](CustomerID)  
GO  
CREATE INDEX IX_OrderDate ON dbo.[Order](OrderDate)  
GO  
```  
  
 <span data-ttu-id="05054-117">Para construir os planos de consulta mostrados neste artigo, as duas tabelas foram populadas com dados de exemplo do banco de dados de exemplo Northwind, que você pode baixar em [Bancos de dados de exemplo Northwind e pubs do SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span><span class="sxs-lookup"><span data-stu-id="05054-117">For constructing the query plans shown in this article, the two tables were populated with sample data from the Northwind sample database, which you can download from [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span></span>  
  
 <span data-ttu-id="05054-118">Considere a consulta a seguir, que une as tabelas Customer e Order e retorna a ID da ordem e as informações de cliente associadas:</span><span class="sxs-lookup"><span data-stu-id="05054-118">Consider the following query, which joins the tables Customer and Order and returns the ID of the order and the associated customer information:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="05054-119">O plano de execução estimado, conforme exibido pelo [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] é como segue</span><span class="sxs-lookup"><span data-stu-id="05054-119">The estimated execution plan as displayed by [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] is as follows</span></span>  
  
 <span data-ttu-id="05054-120">![Plano de consulta para a junção de tabelas com base em disco.](../../database-engine/media/hekaton-query-plan-1.gif "Plano de consulta para a junção de tabelas com base em disco.")</span><span class="sxs-lookup"><span data-stu-id="05054-120">![Query plan for join of disk-based tables.](../../database-engine/media/hekaton-query-plan-1.gif "Query plan for join of disk-based tables.")</span></span>  
<span data-ttu-id="05054-121">Plano de consulta para a junção de tabelas com base em disco.</span><span class="sxs-lookup"><span data-stu-id="05054-121">Query plan for join of disk-based tables.</span></span>  
  
 <span data-ttu-id="05054-122">Sobre esse plano de consulta:</span><span class="sxs-lookup"><span data-stu-id="05054-122">About this query plan:</span></span>  
  
-   <span data-ttu-id="05054-123">As linhas da tabela Customer são recuperadas do índice clusterizado, que é a estrutura de dados primária e tem os dados de tabela completos.</span><span class="sxs-lookup"><span data-stu-id="05054-123">The rows from the Customer table are retrieved from the clustered index, which is the primary data structure and has the full table data.</span></span>  
  
-   <span data-ttu-id="05054-124">Os dados da tabela Order são recuperados usando o índice não clusterizado na coluna CustomerID.</span><span class="sxs-lookup"><span data-stu-id="05054-124">Data from the Order table is retrieved using the nonclustered index on the CustomerID column.</span></span> <span data-ttu-id="05054-125">Esse índice contém a coluna CustomerID, que é usada para a junção, e a coluna de chave primária OrderID, que é retornada ao usuário.</span><span class="sxs-lookup"><span data-stu-id="05054-125">This index contains both the CustomerID column, which is used for the join, and the primary key column OrderID, which is returned to the user.</span></span> <span data-ttu-id="05054-126">O retorno de colunas adicionais da tabela Order exigiria pesquisas no índice clusterizado da tabela Order.</span><span class="sxs-lookup"><span data-stu-id="05054-126">Returning additional columns from the Order table would require lookups in the clustered index for the Order table.</span></span>  
  
-   <span data-ttu-id="05054-127">O operador lógico `Inner Join` é implementado pelo operador físico `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="05054-127">The logical operator `Inner Join` is implemented by the physical operator `Merge Join`.</span></span> <span data-ttu-id="05054-128">Os outros tipos de junção física são `Nested Loops` e `Hash Join`.</span><span class="sxs-lookup"><span data-stu-id="05054-128">The other physical join types are `Nested Loops` and `Hash Join`.</span></span> <span data-ttu-id="05054-129">O operador `Merge Join` aproveita o fato de que ambos os índices são classificados na coluna de junção CustomerID.</span><span class="sxs-lookup"><span data-stu-id="05054-129">The `Merge Join` operator takes advantage of the fact that both indexes are sorted on the join column CustomerID.</span></span>  
  
 <span data-ttu-id="05054-130">Considere uma ligeira variação nessa consulta, que retorna todas as linhas da tabela Order, não apenas OrderID:</span><span class="sxs-lookup"><span data-stu-id="05054-130">Consider a slight variation on this query, which returns all rows from the Order table, not only OrderID:</span></span>  
  
```sql  
SELECT o.*, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="05054-131">O plano estimado para essa consulta é:</span><span class="sxs-lookup"><span data-stu-id="05054-131">The estimated plan for this query is:</span></span>  
  
 <span data-ttu-id="05054-132">![Plano de consulta para uma junção hash de tabelas com base em disco.](../../database-engine/media/hekaton-query-plan-2.gif "Plano de consulta para uma junção hash de tabelas com base em disco.")</span><span class="sxs-lookup"><span data-stu-id="05054-132">![Query plan for a hash join of disk-based tables.](../../database-engine/media/hekaton-query-plan-2.gif "Query plan for a hash join of disk-based tables.")</span></span>  
<span data-ttu-id="05054-133">Plano de consulta para uma junção hash de tabelas com base em disco.</span><span class="sxs-lookup"><span data-stu-id="05054-133">Query plan for a hash join of disk-based tables.</span></span>  
  
 <span data-ttu-id="05054-134">Nessa consulta, as linhas da tabela Order são recuperadas usando o índice clusterizado.</span><span class="sxs-lookup"><span data-stu-id="05054-134">In this query, rows from the Order table are retrieved using the clustered index.</span></span> <span data-ttu-id="05054-135">O operador físico `Hash Match` agora é usado para `Inner Join`.</span><span class="sxs-lookup"><span data-stu-id="05054-135">The `Hash Match` physical operator is now used for the `Inner Join`.</span></span> <span data-ttu-id="05054-136">O índice clusterizado em Order não é classificado em CustomerID e, portanto, `Merge Join` exigiria um operador de classificação, o que afetaria o desempenho.</span><span class="sxs-lookup"><span data-stu-id="05054-136">The clustered index on Order is not sorted on CustomerID, and so a `Merge Join` would require a sort operator, which would affect performance.</span></span> <span data-ttu-id="05054-137">Observe o custo relativo do operador `Hash Match` (75%) comparado com o custo do operador `Merge Join` no exemplo anterior (46%).</span><span class="sxs-lookup"><span data-stu-id="05054-137">Note the relative cost of the `Hash Match` operator (75%) compared with the cost of the `Merge Join` operator in the previous example (46%).</span></span> <span data-ttu-id="05054-138">O otimizador consideraria o operador `Hash Match` também no exemplo anterior, mas concluiu que o operador `Merge Join` forneceu melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="05054-138">The optimizer would have considered the `Hash Match` operator also in the previous example, but concluded that the `Merge Join` operator gave better performance.</span></span>  
  
## <a name="ssnoversion-query-processing-for-disk-based-tables"></a>[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="05054-139">Processamento de consulta para tabelas baseadas em disco</span><span class="sxs-lookup"><span data-stu-id="05054-139">Query Processing for Disk-Based Tables</span></span>  
 <span data-ttu-id="05054-140">O diagrama a seguir descreve o fluxo de processamento de consulta no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] para consultas ad hoc:</span><span class="sxs-lookup"><span data-stu-id="05054-140">The following diagram outlines the query processing flow in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for ad hoc queries:</span></span>  
  
 <span data-ttu-id="05054-141">![Pipeline do processamento de consulta do SQL Server.](../../database-engine/media/hekaton-query-plan-3.gif "Pipeline do processamento de consulta do SQL Server.")</span><span class="sxs-lookup"><span data-stu-id="05054-141">![SQL Server query processing pipeline.](../../database-engine/media/hekaton-query-plan-3.gif "SQL Server query processing pipeline.")</span></span>  
<span data-ttu-id="05054-142">Pipeline do processamento de consulta do SQL Server.</span><span class="sxs-lookup"><span data-stu-id="05054-142">SQL Server query processing pipeline.</span></span>  
  
 <span data-ttu-id="05054-143">Neste cenário:</span><span class="sxs-lookup"><span data-stu-id="05054-143">In this scenario:</span></span>  
  
1.  <span data-ttu-id="05054-144">O usuário emite uma consulta.</span><span class="sxs-lookup"><span data-stu-id="05054-144">The user issues a query.</span></span>  
  
2.  <span data-ttu-id="05054-145">O analisador e o algebrista constroem uma árvore de consulta com operadores lógicos de acordo com o texto [!INCLUDE[tsql](../../../includes/tsql-md.md)] enviado pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="05054-145">The parser and algebrizer construct a query tree with logical operators based on the [!INCLUDE[tsql](../../../includes/tsql-md.md)] text submitted by the user.</span></span>  
  
3.  <span data-ttu-id="05054-146">O otimizador cria um plano de consulta otimizado que contém operadores físicos (por exemplo, junção de loops aninhados).</span><span class="sxs-lookup"><span data-stu-id="05054-146">The optimizer creates an optimized query plan containing physical operators (for example, nested-loops join).</span></span> <span data-ttu-id="05054-147">Depois da otimização, o plano pode ser armazenado no cache do plano.</span><span class="sxs-lookup"><span data-stu-id="05054-147">After optimization, the plan may be stored in the plan cache.</span></span> <span data-ttu-id="05054-148">Essa etapa será ignorada se o cache do plano já contiver um plano para essa consulta.</span><span class="sxs-lookup"><span data-stu-id="05054-148">This step is bypassed if the plan cache already contains a plan for this query.</span></span>  
  
4.  <span data-ttu-id="05054-149">O mecanismo de execução de consulta processa uma interpretação do plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="05054-149">The query execution engine processes an interpretation of the query plan.</span></span>  
  
5.  <span data-ttu-id="05054-150">Para cada busca de índice, verificação de índice e operador de verificação de tabela, o mecanismo de execução solicita linhas das respectivas estruturas de índice e tabela dos Métodos de Acesso.</span><span class="sxs-lookup"><span data-stu-id="05054-150">For each index seek, index scan, and table scan operator, the execution engine requests rows from the respective index and table structures from Access Methods.</span></span>  
  
6.  <span data-ttu-id="05054-151">Os Métodos de Acesso recuperam as linhas das páginas de dados e de índice no pool de buffers e carregam as páginas do disco no pool de buffers conforme a necessidade.</span><span class="sxs-lookup"><span data-stu-id="05054-151">Access Methods retrieves the rows from the index and data pages in the buffer pool and loads pages from disk into the buffer pool as needed.</span></span>  
  
 <span data-ttu-id="05054-152">Para a primeira consulta de exemplo, o mecanismo de execução solicita dos Métodos de Acesso as linhas no índice clusterizado em Customer e no índice não clusterizado em Order.</span><span class="sxs-lookup"><span data-stu-id="05054-152">For the first example query, the execution engine requests rows in the clustered index on Customer and the nonclustered index on Order from Access Methods.</span></span> <span data-ttu-id="05054-153">Os Métodos de Acesso passam pelas estruturas de índice da árvore B para recuperar as linhas solicitadas.</span><span class="sxs-lookup"><span data-stu-id="05054-153">Access Methods traverses the B-tree index structures to retrieve the requested rows.</span></span> <span data-ttu-id="05054-154">Nesse caso, todas as linhas são recuperadas como os planos de chamada para verificações de índice completo.</span><span class="sxs-lookup"><span data-stu-id="05054-154">In this case all rows are retrieved as the plan calls for full index scans.</span></span>  
  
## <a name="interpreted-tsql-access-to-memory-optimized-tables"></a><span data-ttu-id="05054-155">Acesso do [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado a tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="05054-155">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access to Memory-Optimized Tables</span></span>  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="05054-156">ad hoc também são conhecidos como [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="05054-156">ad hoc batches and stored procedures are also referred to as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="05054-157">Interpretado se refere ao fato de que o plano de consulta é interpretado pelo mecanismo de execução da consulta para cada operador no plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="05054-157">Interpreted refers to the fact that the query plan is interpreted by the query execution engine for each operator in the query plan.</span></span> <span data-ttu-id="05054-158">O mecanismo de execução lê o operador e seus parâmetros e executa a operação.</span><span class="sxs-lookup"><span data-stu-id="05054-158">The execution engine reads the operator and its parameters and performs the operation.</span></span>  
  
 <span data-ttu-id="05054-159">O [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado pode ser usado para acessar tabelas com otimização de memória e baseadas em disco.</span><span class="sxs-lookup"><span data-stu-id="05054-159">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] can be used to access both memory-optimized and disk-based tables.</span></span> <span data-ttu-id="05054-160">A figura a seguir ilustra o processamento de consulta para acesso do [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado a tabelas com otimização de memória:</span><span class="sxs-lookup"><span data-stu-id="05054-160">The following figure illustrates query processing for interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables:</span></span>  
  
 <span data-ttu-id="05054-161">![Pipeline de processamento da consulta para tsql interpretado.](../../database-engine/media/hekaton-query-plan-4.gif "Pipeline de processamento da consulta para tsql interpretado.")</span><span class="sxs-lookup"><span data-stu-id="05054-161">![Query processing pipeline for interpreted tsql.](../../database-engine/media/hekaton-query-plan-4.gif "Query processing pipeline for interpreted tsql.")</span></span>  
<span data-ttu-id="05054-162">Pipeline do processamento de consulta para acesso do Transact-SQL interpretado a tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="05054-162">Query processing pipeline for interpreted Transact-SQL access to memory-optimized tables.</span></span>  
  
 <span data-ttu-id="05054-163">Conforme ilustrado pela figura, na maioria das vezes, o pipeline do processamento de consulta permanece inalterado:</span><span class="sxs-lookup"><span data-stu-id="05054-163">As illustrated by the figure, the query processing pipeline remains mostly unchanged:</span></span>  
  
-   <span data-ttu-id="05054-164">O analisador e o algebrista constroem a árvore de consulta.</span><span class="sxs-lookup"><span data-stu-id="05054-164">The parser and algebrizer construct the query tree.</span></span>  
  
-   <span data-ttu-id="05054-165">O otimizador cria o plano de execução.</span><span class="sxs-lookup"><span data-stu-id="05054-165">The optimizer creates the execution plan.</span></span>  
  
-   <span data-ttu-id="05054-166">O mecanismo de execução de consulta interpresta o plano de execução.</span><span class="sxs-lookup"><span data-stu-id="05054-166">The query execution engine interprets the execution plan.</span></span>  
  
 <span data-ttu-id="05054-167">A principal diferença em relação ao pipeline de processamento de consulta tradicional (figura 2) é que as linhas das tabelas com otimização de memória não são recuperadas no pool de buffers usando os métodos de acesso.</span><span class="sxs-lookup"><span data-stu-id="05054-167">The main difference with the traditional query processing pipeline (figure 2) is that rows for memory-optimized tables are not retrieved from the buffer pool using Access Methods.</span></span> <span data-ttu-id="05054-168">Em vez disso, as linhas são recuperadas nas estruturas de dados na memória pelo mecanismo OLTP na memória.</span><span class="sxs-lookup"><span data-stu-id="05054-168">Instead, rows are retrieved from the in-memory data structures through the In-Memory OLTP engine.</span></span> <span data-ttu-id="05054-169">As diferenças nas estruturas de dados fazem com que o otimizador escolha planos diferentes em alguns casos, conforme ilustrado pelo exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="05054-169">Differences in data structures cause the optimizer to pick different plans in some cases, as illustrated by the following example.</span></span>  
  
 <span data-ttu-id="05054-170">O script [!INCLUDE[tsql](../../../includes/tsql-md.md)] a seguir contém versões com otimização de memória das tabelas Order e Customer, usando índices de hash:</span><span class="sxs-lookup"><span data-stu-id="05054-170">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains memory-optimized versions of the Order and Customer tables, using hash indexes:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY NONCLUSTERED,  
  ContactName nvarchar (30) NOT NULL   
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY NONCLUSTERED,  
  CustomerID nchar (5) NOT NULL INDEX IX_CustomerID HASH(CustomerID) WITH (BUCKET_COUNT=100000),  
  OrderDate date NOT NULL INDEX IX_OrderDate HASH(OrderDate) WITH (BUCKET_COUNT=100000)  
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
```  
  
 <span data-ttu-id="05054-171">Considere a mesma consulta executada em tabelas com otimização de memória:</span><span class="sxs-lookup"><span data-stu-id="05054-171">Consider the same query executed on memory-optimized tables:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="05054-172">O plano estimado é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="05054-172">The estimated plan is as follows:</span></span>  
  
 <span data-ttu-id="05054-173">![Plano de consulta para a junção de tabelas com otimização de memória.](../../database-engine/media/hekaton-query-plan-5.gif "Plano de consulta para a junção de tabelas com otimização de memória.")</span><span class="sxs-lookup"><span data-stu-id="05054-173">![Query plan for join of memory optimized tables.](../../database-engine/media/hekaton-query-plan-5.gif "Query plan for join of memory optimized tables.")</span></span>  
<span data-ttu-id="05054-174">Plano de consulta para a junção de tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="05054-174">Query plan for join of memory-optimized tables.</span></span>  
  
 <span data-ttu-id="05054-175">Observe as seguintes diferenças em relação ao plano para a mesma consulta em tabelas baseadas em disco (figura 1):</span><span class="sxs-lookup"><span data-stu-id="05054-175">Observe the following differences with the plan for the same query on disk-based tables (figure 1):</span></span>  
  
-   <span data-ttu-id="05054-176">Esse plano contém uma verificação de tabela em vez de uma verificação de índice clusterizado para a tabela Customer:</span><span class="sxs-lookup"><span data-stu-id="05054-176">This plan contains a table scan rather than a clustered index scan for the table Customer:</span></span>  
  
    -   <span data-ttu-id="05054-177">A definição da tabela não contém um índice clusterizado.</span><span class="sxs-lookup"><span data-stu-id="05054-177">The definition of the table does not contain a clustered index.</span></span>  
  
    -   <span data-ttu-id="05054-178">Os índices clusterizados não têm suporte nas tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="05054-178">Clustered indexes are not supported with memory-optimized tables.</span></span> <span data-ttu-id="05054-179">Em vez disso, cada tabela com otimização de memória deve ter pelo menos um índice não clusterizado e todos os índices nas tabelas com otimização de memória podem acessar com eficiência todas as colunas da tabela sem ter que armazená-las no índice ou consultar um índice clusterizado.</span><span class="sxs-lookup"><span data-stu-id="05054-179">Instead, every memory-optimized table must have at least one nonclustered index and all indexes on memory-optimized tables can efficiently access all columns in the table without having to store them in the index or refer to a clustered index.</span></span>  
  
-   <span data-ttu-id="05054-180">Esse plano contém `Hash Match` em vez de `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="05054-180">This plan contains a `Hash Match` rather than a `Merge Join`.</span></span> <span data-ttu-id="05054-181">Os índices nas tabelas Order e Customer são índices de hash e, portanto, não são ordenados.</span><span class="sxs-lookup"><span data-stu-id="05054-181">The indexes on both the Order and the Customer table are hash indexes, and are thus not ordered.</span></span> <span data-ttu-id="05054-182">Um `Merge Join` exigiria os operadores de classificação que diminuiriam o desempenho.</span><span class="sxs-lookup"><span data-stu-id="05054-182">A `Merge Join` would require sort operators that would decrease performance.</span></span>  
  
## <a name="natively-compiled-stored-procedures"></a><span data-ttu-id="05054-183">procedimentos armazenados compilados nativamente</span><span class="sxs-lookup"><span data-stu-id="05054-183">Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="05054-184">Os procedimentos armazenados compilados nativamente são procedimentos armazenados [!INCLUDE[tsql](../../../includes/tsql-md.md)] compilados para código de máquina, não sendo interpretados pela mecanismo de execução de consulta.</span><span class="sxs-lookup"><span data-stu-id="05054-184">Natively compiled stored procedures are [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures compiled to machine code, rather than interpreted by the query execution engine.</span></span> <span data-ttu-id="05054-185">O script a seguir cria um procedimento armazenado originalmente compilado que executa a consulta de exemplo (na seção Consulta de exemplo).</span><span class="sxs-lookup"><span data-stu-id="05054-185">The following script creates a natively compiled stored procedure that runs the example query (from the Example Query section).</span></span>  
  
```sql  
CREATE PROCEDURE usp_SampleJoin  
WITH NATIVE_COMPILATION, SCHEMABINDING, EXECUTE AS OWNER  
AS BEGIN ATOMIC WITH   
(  TRANSACTION ISOLATION LEVEL = SNAPSHOT,  
  LANGUAGE = 'english')  
  
  SELECT o.OrderID, c.CustomerID, c.ContactName   
FROM dbo.[Order] o INNER JOIN dbo.[Customer] c   
  ON c.CustomerID = o.CustomerID  
  
END  
```  
  
 <span data-ttu-id="05054-186">Os procedimentos armazenados compilados nativamente são compilados no momento da criação, enquanto os procedimentos armazenados interpretados são compilados no momento da primeira execução.</span><span class="sxs-lookup"><span data-stu-id="05054-186">Natively compiled stored procedures are compiled at create time, whereas interpreted stored procedures are compiled at first execution time.</span></span> <span data-ttu-id="05054-187">(Uma parte da compilação, particularmente de análise e algebrização, ocorre na criação.</span><span class="sxs-lookup"><span data-stu-id="05054-187">(A portion of the compilation, particularly parsing and algebrization, take place at create.</span></span> <span data-ttu-id="05054-188">No entanto, para procedimentos armazenados interpretados, a otimização dos planos de consulta ocorre na primeira execução.) A lógica de recompilação é semelhante.</span><span class="sxs-lookup"><span data-stu-id="05054-188">However, for interpreted stored procedures, optimization of the query plans takes place at first execution.) The recompilation logic is similar.</span></span> <span data-ttu-id="05054-189">Os procedimentos armazenados compilados nativamente são recompilados na primeira execução do procedimento se o servidor for reiniciado.</span><span class="sxs-lookup"><span data-stu-id="05054-189">Natively compiled stored procedures are recompiled on first execution of the procedure if the server is restarted.</span></span> <span data-ttu-id="05054-190">Os procedimentos armazenados interpretados serão recompilados se o plano não estiver mais no cache do plano.</span><span class="sxs-lookup"><span data-stu-id="05054-190">Interpreted stored procedures are recompiled if the plan is no longer in the plan cache.</span></span> <span data-ttu-id="05054-191">A tabela a seguir resume os casos de compilação e recompilação para procedimentos armazenados interpretados e compilados nativamente:</span><span class="sxs-lookup"><span data-stu-id="05054-191">The following table summarizes compilation and recompilation cases for both natively compiled and interpreted stored procedures:</span></span>  
  
||<span data-ttu-id="05054-192">Originalmente compilado</span><span class="sxs-lookup"><span data-stu-id="05054-192">Natively compiled</span></span>|<span data-ttu-id="05054-193">Acesso do</span><span class="sxs-lookup"><span data-stu-id="05054-193">Interpreted</span></span>|  
|-|-----------------------|-----------------|  
|<span data-ttu-id="05054-194">Compilação inicial</span><span class="sxs-lookup"><span data-stu-id="05054-194">Initial compilation</span></span>|<span data-ttu-id="05054-195">No momento da criação.</span><span class="sxs-lookup"><span data-stu-id="05054-195">At create time.</span></span>|<span data-ttu-id="05054-196">Na primeira execução.</span><span class="sxs-lookup"><span data-stu-id="05054-196">At first execution.</span></span>|  
|<span data-ttu-id="05054-197">Recompilação automática</span><span class="sxs-lookup"><span data-stu-id="05054-197">Automatic recompilation</span></span>|<span data-ttu-id="05054-198">Na primeira execução do procedimento após o reinício do banco de dados ou do servidor.</span><span class="sxs-lookup"><span data-stu-id="05054-198">Upon first execution of the procedure after a database or server restart.</span></span>|<span data-ttu-id="05054-199">Na reinicialização do servidor.</span><span class="sxs-lookup"><span data-stu-id="05054-199">On server restart.</span></span> <span data-ttu-id="05054-200">Ou, remoção do cache do plano, geralmente com base nas alterações de estatísticas ou esquema, ou demanda de memória.</span><span class="sxs-lookup"><span data-stu-id="05054-200">Or, eviction from the plan cache, usually based on schema or stats changes, or memory pressure.</span></span>|  
|<span data-ttu-id="05054-201">Recompilação manual</span><span class="sxs-lookup"><span data-stu-id="05054-201">Manual recompilation</span></span>|<span data-ttu-id="05054-202">Não há suporte.</span><span class="sxs-lookup"><span data-stu-id="05054-202">Not supported.</span></span> <span data-ttu-id="05054-203">A solução alternativa é descartar e recriar o procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="05054-203">The workaround is to drop and recreate the stored procedure.</span></span>|<span data-ttu-id="05054-204">Use `sp_recompile`.</span><span class="sxs-lookup"><span data-stu-id="05054-204">Use `sp_recompile`.</span></span> <span data-ttu-id="05054-205">Você pode remover manualmente o plano do cache, por exemplo, usando DBCC FREEPROCCACHE.</span><span class="sxs-lookup"><span data-stu-id="05054-205">You can manually evict the plan from the cache, for example through DBCC FREEPROCCACHE.</span></span> <span data-ttu-id="05054-206">Você também pode criar o procedimento armazenado WITH RECOMPILE e o procedimento armazenado será recompilado em cada execução.</span><span class="sxs-lookup"><span data-stu-id="05054-206">You can also create the stored procedure WITH RECOMPILE and the stored procedure will be recompiled at every execution.</span></span>|  
  
### <a name="compilation-and-query-processing"></a><span data-ttu-id="05054-207">Processamento de compilação e consulta</span><span class="sxs-lookup"><span data-stu-id="05054-207">Compilation and Query Processing</span></span>  
 <span data-ttu-id="05054-208">O diagrama a seguir ilustra o processo de compilação para procedimentos armazenados compilados nativamente:</span><span class="sxs-lookup"><span data-stu-id="05054-208">The following diagram illustrates the compilation process for natively compiled stored procedures:</span></span>  
  
 <span data-ttu-id="05054-209">![Compilação original dos procedimentos armazenados.](../../database-engine/media/hekaton-query-plan-6.gif "Compilação original dos procedimentos armazenados.")</span><span class="sxs-lookup"><span data-stu-id="05054-209">![Native compilation of stored procedures.](../../database-engine/media/hekaton-query-plan-6.gif "Native compilation of stored procedures.")</span></span>  
<span data-ttu-id="05054-210">Compilação original dos procedimentos armazenados.</span><span class="sxs-lookup"><span data-stu-id="05054-210">Native compilation of stored procedures.</span></span>  
  
 <span data-ttu-id="05054-211">O processo é descrito como:</span><span class="sxs-lookup"><span data-stu-id="05054-211">The process is described as,</span></span>  
  
1.  <span data-ttu-id="05054-212">O usuário emite uma instrução `CREATE PROCEDURE` no [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="05054-212">The user issues a `CREATE PROCEDURE` statement to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
2.  <span data-ttu-id="05054-213">O analisador e o algebrista criam o fluxo de processamento para o procedimento, bem como as árvores de consulta para as consultas [!INCLUDE[tsql](../../../includes/tsql-md.md)] no procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="05054-213">The parser and algebrizer create the processing flow for the procedure, as well as query trees for the [!INCLUDE[tsql](../../../includes/tsql-md.md)] queries in the stored procedure.</span></span>  
  
3.  <span data-ttu-id="05054-214">O otimizador cria planos otimizados de execução de consulta para todas as consultas no procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="05054-214">The optimizer creates optimized query execution plans for all the queries in the stored procedure.</span></span>  
  
4.  <span data-ttu-id="05054-215">O compilador OLTP na memória usa o fluxo de processamento com os planos de consulta otimizados inseridos e gera uma DLL que contém o código de máquina para execução do procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="05054-215">The In-Memory OLTP compiler takes the processing flow with the embedded optimized query plans and generates a DLL that contains the machine code for executing the stored procedure.</span></span>  
  
5.  <span data-ttu-id="05054-216">A DLL gerado é carregada na memória.</span><span class="sxs-lookup"><span data-stu-id="05054-216">The generated DLL is loaded into memory.</span></span>  
  
 <span data-ttu-id="05054-217">A invocação de um procedimento armazenado originalmente compilado é convertida para chamar uma função na DLL.</span><span class="sxs-lookup"><span data-stu-id="05054-217">Invocation of a natively compiled stored procedure translates to calling a function in the DLL.</span></span>  
  
 <span data-ttu-id="05054-218">![Execução de procedimentos armazenados compilados nativamente.](../../database-engine/media/hekaton-query-plan-7.gif "Execução de procedimentos armazenados compilados nativamente.")</span><span class="sxs-lookup"><span data-stu-id="05054-218">![Execution of natively compiled stored procedures.](../../database-engine/media/hekaton-query-plan-7.gif "Execution of natively compiled stored procedures.")</span></span>  
<span data-ttu-id="05054-219">Execução de procedimentos armazenados compilados nativamente.</span><span class="sxs-lookup"><span data-stu-id="05054-219">Execution of natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="05054-220">A invocação de um procedimento armazenado originalmente compilado é descrita a seguir:</span><span class="sxs-lookup"><span data-stu-id="05054-220">Invocation of a natively compiled stored procedure is described as follows:</span></span>  
  
1.  <span data-ttu-id="05054-221">O usuário emite uma `EXEC` instrução *usp_myproc* .</span><span class="sxs-lookup"><span data-stu-id="05054-221">The user issues an `EXEC`*usp_myproc* statement.</span></span>  
  
2.  <span data-ttu-id="05054-222">O analisador extrai os parâmetros de nome e procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="05054-222">The parser extracts the name and stored procedure parameters.</span></span>  
  
     <span data-ttu-id="05054-223">Se a instrução tiver sido preparada, por exemplo, usando `sp_prep_exec`, o analisador não precisará extrair os parâmetros e o nome do procedimento no momento da execução.</span><span class="sxs-lookup"><span data-stu-id="05054-223">If the statement was prepared, for example using `sp_prep_exec`, the parser does not need to extract the procedure name and parameters at execution time.</span></span>  
  
3.  <span data-ttu-id="05054-224">O runtime do OLTP na memória localiza o ponto de entrada da DLL do procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="05054-224">The In-Memory OLTP runtime locates the DLL entry point for the stored procedure.</span></span>  
  
4.  <span data-ttu-id="05054-225">O código de máquina no DLL é executado e os resultados são retornados para o cliente.</span><span class="sxs-lookup"><span data-stu-id="05054-225">The machine code in the DLL is executed and the results of are returned to the client.</span></span>  
  
 <span data-ttu-id="05054-226">**Detecção de parâmetro**</span><span class="sxs-lookup"><span data-stu-id="05054-226">**Parameter sniffing**</span></span>  
  
 <span data-ttu-id="05054-227">Os procedimentos armazenados [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado são compilados na primeira execução, em oposição aos procedimentos armazenados compilados nativamente, que são compilados no momento da criação.</span><span class="sxs-lookup"><span data-stu-id="05054-227">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures are compiled at first execution, in contrast to natively compiled stored procedures, which are compiled at create time.</span></span> <span data-ttu-id="05054-228">Quando os procedimentos armazenados interpretados são compilados na invocação, os valores dos parâmetros fornecidos para essa invocação são usados pelo otimizador durante a geração do plano de execução.</span><span class="sxs-lookup"><span data-stu-id="05054-228">When interpreted stored procedures are compiled at invocation, the values of the parameters supplied for this invocation are used by the optimizer when generating the execution plan.</span></span> <span data-ttu-id="05054-229">Esse uso de parâmetros durante a compilação é chamado de detecção de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="05054-229">This use of parameters during compilation is called parameter sniffing.</span></span>  
  
 <span data-ttu-id="05054-230">A detecção de parâmetro não é usada para compilar os procedimentos armazenados compilados nativamente.</span><span class="sxs-lookup"><span data-stu-id="05054-230">Parameter sniffing is not used for compiling natively compiled stored procedures.</span></span> <span data-ttu-id="05054-231">Todos os parâmetros para o procedimento armazenado são considerados como tendo valores UNKNOWN.</span><span class="sxs-lookup"><span data-stu-id="05054-231">All parameters to the stored procedure are considered to have UNKNOWN values.</span></span> <span data-ttu-id="05054-232">Como são procedimentos armazenados interpretados, os procedimentos armazenados compilados nativos também dão suporte à dica de `OPTIMIZE FOR`.</span><span class="sxs-lookup"><span data-stu-id="05054-232">Like interpreted stored procedures, natively compiled stored procedures also support the `OPTIMIZE FOR` hint.</span></span> <span data-ttu-id="05054-233">Para obter mais informações, veja [Dicas de consulta &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span><span class="sxs-lookup"><span data-stu-id="05054-233">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
### <a name="retrieving-a-query-execution-plan-for-natively-compiled-stored-procedures"></a><span data-ttu-id="05054-234">Recuperando um plano de execução de consulta para procedimentos armazenados compilados de forma nativa</span><span class="sxs-lookup"><span data-stu-id="05054-234">Retrieving a Query Execution Plan for Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="05054-235">O plano de execução de consulta para um procedimento armazenado compilado nativamente pode ser recuperado usando o **Plano de Execução Estimado** no [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], ou usando a opção SHOWPLAN_XML no [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="05054-235">The query execution plan for a natively compiled stored procedure can be retrieved using **Estimated Execution Plan** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], or using the SHOWPLAN_XML option in [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="05054-236">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="05054-236">For example:</span></span>  
  
```sql  
SET SHOWPLAN_XML ON  
GO  
EXEC dbo.usp_myproc  
GO  
SET SHOWPLAN_XML OFF  
GO  
```  
  
 <span data-ttu-id="05054-237">O plano de execução gerado pelo otimizador de consulta consiste em uma árvore com operadores de consulta nos nós e nas folhas da árvore.</span><span class="sxs-lookup"><span data-stu-id="05054-237">The execution plan generated by the query optimizer consists of a tree with query operators on the nodes and leaves of the tree.</span></span> <span data-ttu-id="05054-238">A estrutura da árvore determina a interação (o fluxo de linhas de um operador para outro) entre os operadores.</span><span class="sxs-lookup"><span data-stu-id="05054-238">The structure of the tree determines the interaction (the flow of rows from one operator to another) between the operators.</span></span> <span data-ttu-id="05054-239">Na exibição gráfica do [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], o fluxo é da direita para a esquerda.</span><span class="sxs-lookup"><span data-stu-id="05054-239">In the graphical view of [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], the flow is from right to left.</span></span> <span data-ttu-id="05054-240">Por exemplo, o plano de consulta na figura 1 contém dois operadores de verificação de índice, que fornece linhas a um operador de junção de mesclagem.</span><span class="sxs-lookup"><span data-stu-id="05054-240">For example, the query plan in figure 1 contains two index scan operators, which supplies rows to a merge join operator.</span></span> <span data-ttu-id="05054-241">O operador de junção de mesclagem fornece linhas a um operador de seleção.</span><span class="sxs-lookup"><span data-stu-id="05054-241">The merge join operator supplies rows to a select operator.</span></span> <span data-ttu-id="05054-242">O operador de seleção, por fim, retorna as linhas ao cliente.</span><span class="sxs-lookup"><span data-stu-id="05054-242">The select operator, finally, returns the rows to the client.</span></span>  
  
### <a name="query-operators-in-natively-compiled-stored-procedures"></a><span data-ttu-id="05054-243">Operadores de consulta nos procedimentos armazenados compilados nativamente</span><span class="sxs-lookup"><span data-stu-id="05054-243">Query Operators in Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="05054-244">A tabela a seguir resume os operadores de consulta com suporte em procedimentos armazenados compilados nativamente:</span><span class="sxs-lookup"><span data-stu-id="05054-244">The following table summarizes the query operators supported inside natively compiled stored procedures:</span></span>  
  
|<span data-ttu-id="05054-245">Operador</span><span class="sxs-lookup"><span data-stu-id="05054-245">Operator</span></span>|<span data-ttu-id="05054-246">Exemplo de consulta</span><span class="sxs-lookup"><span data-stu-id="05054-246">Sample query</span></span>|  
|--------------|------------------|  
|<span data-ttu-id="05054-247">SELECT</span><span class="sxs-lookup"><span data-stu-id="05054-247">SELECT</span></span>|`SELECT OrderID FROM dbo.[Order]`|  
|<span data-ttu-id="05054-248">INSERT</span><span class="sxs-lookup"><span data-stu-id="05054-248">INSERT</span></span>|`INSERT dbo.Customer VALUES ('abc', 'def')`|  
|<span data-ttu-id="05054-249">UPDATE</span><span class="sxs-lookup"><span data-stu-id="05054-249">UPDATE</span></span>|`UPDATE dbo.Customer SET ContactName='ghi' WHERE CustomerID='abc'`|  
|<span data-ttu-id="05054-250">Delete (excluir)</span><span class="sxs-lookup"><span data-stu-id="05054-250">DELETE</span></span>|`DELETE dbo.Customer WHERE CustomerID='abc'`|  
|<span data-ttu-id="05054-251">Compute Scalar</span><span class="sxs-lookup"><span data-stu-id="05054-251">Compute Scalar</span></span>|<span data-ttu-id="05054-252">Esse operador é usado para funções intrínsecas e conversões de tipo.</span><span class="sxs-lookup"><span data-stu-id="05054-252">This operator is used both for intrinsic functions and type conversions.</span></span> <span data-ttu-id="05054-253">Nem todas as funções e conversões de tipos têm suporte em procedimentos armazenados compilados nativamente.</span><span class="sxs-lookup"><span data-stu-id="05054-253">Not all functions and type conversions are supported inside natively compiled stored procedures.</span></span><br /><br /> `SELECT OrderID+1 FROM dbo.[Order]`|  
|<span data-ttu-id="05054-254">Nested Loops Join</span><span class="sxs-lookup"><span data-stu-id="05054-254">Nested Loops Join</span></span>|<span data-ttu-id="05054-255">Nested Loops é o único operador de junção com suporte em procedimentos armazenados compilados nativamente.</span><span class="sxs-lookup"><span data-stu-id="05054-255">Nested Loops is the only join operator supported in natively compiled stored procedures.</span></span> <span data-ttu-id="05054-256">Todos os planos que contêm junções usarão o operador Nested loops, mesmo se o plano para a mesma consulta executada como [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado contiver uma junção de mesclagem ou hash.</span><span class="sxs-lookup"><span data-stu-id="05054-256">All plans that contain joins will use the Nested Loops operator, even if the plan for same query executed as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] contains a hash or merge join.</span></span><br /><br /> `SELECT o.OrderID, c.CustomerID`  <br /> `FROM dbo.[Order] o INNER JOIN dbo.[Customer] c`|  
|<span data-ttu-id="05054-257">Classificar</span><span class="sxs-lookup"><span data-stu-id="05054-257">Sort</span></span>|`SELECT ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="05054-258">TOP</span><span class="sxs-lookup"><span data-stu-id="05054-258">Top</span></span>|`SELECT TOP 10 ContactName FROM dbo.Customer`|  
|<span data-ttu-id="05054-259">Top-sort</span><span class="sxs-lookup"><span data-stu-id="05054-259">Top-sort</span></span>|<span data-ttu-id="05054-260">A expressão `TOP` (o número de linhas a serem retornadas) não pode exceder 8.000 linhas.</span><span class="sxs-lookup"><span data-stu-id="05054-260">The `TOP` expression (the number of rows to be returned) cannot exceed 8,000 rows.</span></span> <span data-ttu-id="05054-261">Menos se também houver operadores de junção e agregação na consulta.</span><span class="sxs-lookup"><span data-stu-id="05054-261">Fewer if there are also join and aggregation operators in the query.</span></span> <span data-ttu-id="05054-262">As junções e a agregação normalmente reduzem o número de linhas a serem classificadas, em comparação com a contagem de linhas das tabelas base.</span><span class="sxs-lookup"><span data-stu-id="05054-262">Joins and aggregation do typically reduce the number of rows to be sorted, compared with the row count of the base tables.</span></span><br /><br /> `SELECT TOP 10 ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="05054-263">Stream Aggregate</span><span class="sxs-lookup"><span data-stu-id="05054-263">Stream Aggregate</span></span>|<span data-ttu-id="05054-264">Observe que o operador Hash Match não tem suporte para agregação.</span><span class="sxs-lookup"><span data-stu-id="05054-264">Note that the Hash Match operator is not supported for aggregation.</span></span> <span data-ttu-id="05054-265">Desse modo, todas as agregações em procedimentos armazenados compilados nativamente usam o operador Stream Aggregate, mesmo se o plano para a mesma consulta no [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado usar o operador Hash Match.</span><span class="sxs-lookup"><span data-stu-id="05054-265">Therefore, all aggregation in natively compiled stored procedures uses the Stream Aggregate operator, even if the plan for the same query in interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] uses the Hash Match operator.</span></span><br /><br /> `SELECT count(CustomerID) FROM dbo.Customer`|  
  
## <a name="column-statistics-and-joins"></a><span data-ttu-id="05054-266">Junções e estatísticas de coluna</span><span class="sxs-lookup"><span data-stu-id="05054-266">Column Statistics and Joins</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="05054-267">mantém estatísticas sobre valores nas colunas de chave do índice para ajudar a fazer uma estimativa do custo de determinadas operações, como buscas de índice e verificação de índice.</span><span class="sxs-lookup"><span data-stu-id="05054-267">maintains statistics on values in index key columns to help estimate the cost of certain operations, such as index scan and index seeks.</span></span> <span data-ttu-id="05054-268">(O [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] também criará estatísticas em colunas de chave não índice se você criá-las explicitamente ou se o otimizador de consulta criá-los em resposta a uma consulta com um predicado.) A principal métrica na estimativa de custo é o número de linhas processadas por um único operador.</span><span class="sxs-lookup"><span data-stu-id="05054-268">( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also creates statistics on non-index key columns if you explicitly create them or if the query optimizer creates them in response to a query with a predicate.) The main metric in cost estimation is the number of rows processed by a single operator.</span></span> <span data-ttu-id="05054-269">Observe que para tabelas baseadas em disco, o número de páginas acessadas por um operador específico é significativo na estimativa de custo.</span><span class="sxs-lookup"><span data-stu-id="05054-269">Note that for disk-based tables, the number of pages accessed by a particular operator is significant in cost estimation.</span></span> <span data-ttu-id="05054-270">No entanto, como a contagem de páginas não é importante para tabelas com otimização de memória (sempre será zero), este documento se concentra na contagem de linhas.</span><span class="sxs-lookup"><span data-stu-id="05054-270">However, as page count is not important for memory-optimized tables (it is always zero), this discussion focuses on row count.</span></span> <span data-ttu-id="05054-271">A estimativa é iniciada com os operadores de verificação e busca de índice no plano e depois é estendida para incluir os outros operadores, como o de junção.</span><span class="sxs-lookup"><span data-stu-id="05054-271">The estimation starts with the index seek and scan operators in the plan, and is then extended to include the other operators, like the join operator.</span></span> <span data-ttu-id="05054-272">O número estimado de linhas a serem processadas por um operador de junção é baseado na estimativa dos operadores subjacentes de índice, busca e verificação.</span><span class="sxs-lookup"><span data-stu-id="05054-272">The estimated number of rows to be processed by a join operator is based on the estimation for the underlying index, seek, and scan operators.</span></span> <span data-ttu-id="05054-273">Para obter acesso do [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado a tabelas com otimização de memória, você pode observar o plano de execução real ver a diferença entre as contagens de linhas estimadas e reais dos operadores no plano.</span><span class="sxs-lookup"><span data-stu-id="05054-273">For interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables, you can observe the actual execution plan to see the difference between the estimated and actual row counts for the operators in the plan.</span></span>  
  
 <span data-ttu-id="05054-274">Para o exemplo na figura 1:</span><span class="sxs-lookup"><span data-stu-id="05054-274">For the example in figure 1,</span></span>  
  
-   <span data-ttu-id="05054-275">A verificação de índice clusterizado em Customer estimou 91; real 91.</span><span class="sxs-lookup"><span data-stu-id="05054-275">The clustered index scan on Customer has estimated 91; actual 91.</span></span>  
  
-   <span data-ttu-id="05054-276">A verificação de índice não clusterizado em CustomerID estimou 830; real 830.</span><span class="sxs-lookup"><span data-stu-id="05054-276">The nonclustered index scan on CustomerID has estimated 830; actual 830.</span></span>  
  
-   <span data-ttu-id="05054-277">O operador Merge Join estimou 815; real 830.</span><span class="sxs-lookup"><span data-stu-id="05054-277">The Merge Join operator has estimated 815; actual 830.</span></span>  
  
 <span data-ttu-id="05054-278">As estimativas para as verificações de índice são precisas.</span><span class="sxs-lookup"><span data-stu-id="05054-278">The estimates for the index scans are accurate.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="05054-279">mantém a contagem de linhas para tabelas baseadas em disco.</span><span class="sxs-lookup"><span data-stu-id="05054-279">maintains the row count for disk-based tables.</span></span> <span data-ttu-id="05054-280">As estimativas para verificação de índice e tabela inteira sempre são precisas.</span><span class="sxs-lookup"><span data-stu-id="05054-280">Estimates for full table and index scans are always accurate.</span></span> <span data-ttu-id="05054-281">A avaliação para a junção é bastante precisa também.</span><span class="sxs-lookup"><span data-stu-id="05054-281">The estimate for the join is fairly accurate, too.</span></span>  
  
 <span data-ttu-id="05054-282">Se essas estimativas forem alteradas, as considerações de custo para diferentes alternativas de plano também serão alteradas.</span><span class="sxs-lookup"><span data-stu-id="05054-282">If these estimates change, the cost considerations for different plan alternatives change as well.</span></span> <span data-ttu-id="05054-283">Por exemplo, se um dos lados da junção tiver uma contagem de linhas estimada de 1 ou apenas algumas linhas, usar as junções de loops aninhados é menos dispendioso.</span><span class="sxs-lookup"><span data-stu-id="05054-283">For example, if one of the sides of the join has an estimated row count of 1 or just a few rows, using a nested loops joins is less expensive.</span></span>  
  
 <span data-ttu-id="05054-284">Veja a seguir o plano para a consulta;</span><span class="sxs-lookup"><span data-stu-id="05054-284">The following is the plan for the query:</span></span>  
  
```  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="05054-285">Depois de excluir todas as linhas, menos uma na tabela Customer:</span><span class="sxs-lookup"><span data-stu-id="05054-285">After deleting all rows but one in the table Customer:</span></span>  
  
 <span data-ttu-id="05054-286">![Estatísticas e junções de coluna.](../../database-engine/media/hekaton-query-plan-9.gif "Junções e estatísticas de coluna.")</span><span class="sxs-lookup"><span data-stu-id="05054-286">![Column statistics and joins.](../../database-engine/media/hekaton-query-plan-9.gif "Column statistics and joins.")</span></span>  
  
 <span data-ttu-id="05054-287">Em relação a esse plano de consulta:</span><span class="sxs-lookup"><span data-stu-id="05054-287">Regarding this query plan:</span></span>  
  
-   <span data-ttu-id="05054-288">O Hash Match foi substituído por um operador de junção físico Nested Loops.</span><span class="sxs-lookup"><span data-stu-id="05054-288">The Hash Match has been replaced with a Nested Loops physical join operator.</span></span>  
  
-   <span data-ttu-id="05054-289">A verificação de índice completo em IX_CustomerID foi substituída por uma busca de índice.</span><span class="sxs-lookup"><span data-stu-id="05054-289">The full index scan on IX_CustomerID has been replaced with an index seek.</span></span> <span data-ttu-id="05054-290">Isso resultou na verificação de 5 linhas, em vez das 830 linhas exigidas para a verificação de índice completo.</span><span class="sxs-lookup"><span data-stu-id="05054-290">This resulted in scanning 5 rows, instead of the 830 rows required for the full index scan.</span></span>  
  
### <a name="statistics-and-cardinality-for-memory-optimized-tables"></a><span data-ttu-id="05054-291">Estatísticas e cardinalidade para tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="05054-291">Statistics and Cardinality for Memory-Optimized Tables</span></span>  
 <span data-ttu-id="05054-292">O [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] mantém as estatísticas no nível de coluna para tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="05054-292">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] maintains column-level statistics for memory-optimized tables.</span></span> <span data-ttu-id="05054-293">Além disso, ele mantém a contagem real de linhas da tabela.</span><span class="sxs-lookup"><span data-stu-id="05054-293">In addition, it maintains the actual row count of the table.</span></span> <span data-ttu-id="05054-294">No entanto, em contraposição às tabelas baseadas em disco, as estatísticas de tabelas com otimização de memória não são atualizadas automaticamente.</span><span class="sxs-lookup"><span data-stu-id="05054-294">However, in contrast to disk-based tables, the statistics for memory-optimized tables are not automatically updated.</span></span> <span data-ttu-id="05054-295">Portanto, as estatísticas precisam ser atualizadas manualmente depois que alterações significativas são feitas nas tabelas.</span><span class="sxs-lookup"><span data-stu-id="05054-295">Therefore, statistics need to be manually updated after significant changes in the tables.</span></span> <span data-ttu-id="05054-296">Para obter mais informações, consulte [Estatísticas para tabelas com otimização de memória](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="05054-296">For more information, see [Statistics for Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="05054-297">Consulte Também</span><span class="sxs-lookup"><span data-stu-id="05054-297">See Also</span></span>  
 [<span data-ttu-id="05054-298">Memory-Optimized Tables</span><span class="sxs-lookup"><span data-stu-id="05054-298">Memory-Optimized Tables</span></span>](memory-optimized-tables.md)  
  
  
