---
title: Introdução às tabelas com otimização de memória | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87685697"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="a6a2e-102">Introdução às tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="a6a2e-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="a6a2e-103">Tabelas com otimização de memória são aquelas criadas com [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="a6a2e-104">Tabelas com otimização de memória residem na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="a6a2e-105">As linhas da tabela são lidas e gravadas na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="a6a2e-106">A tabela inteira reside na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-106">The entire table resides in memory.</span></span> <span data-ttu-id="a6a2e-107">Uma segunda cópia dos dados da tabela é mantida em disco, mas apenas para fins de durabilidade.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="a6a2e-108">O OLTP na memória é integrado ao [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] para fornecer uma experiência perfeita em todas as áreas, como desenvolvimento, implantação, capacidade de gerenciamento e suporte.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="a6a2e-109">Um banco de dados pode conter objetos residentes na memória e baseados em disco.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="a6a2e-110">As linhas nas tabelas com otimização de memória têm controle de versão.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="a6a2e-111">Isso significa que cada linha da tabela, possivelmente, tem várias versões.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="a6a2e-112">Todas as versões de linha são mantidas na mesma estrutura de dados da tabela.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="a6a2e-113">O controle de versão de linha é usado para permitir leituras e gravações simultâneas na mesma linha.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="a6a2e-114">Para obter mais informações sobre leituras e gravações simultâneas na mesma linha, consulte [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="a6a2e-115">A figura a seguir ilustra o controle de várias versões.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="a6a2e-116">A figura mostra uma tabela com três linhas, e cada linha tem versões diferentes.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="a6a2e-117">![Controle de várias versões.](../../database-engine/media/hekaton-tables-1.gif "Controle de várias versões.")</span><span class="sxs-lookup"><span data-stu-id="a6a2e-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="a6a2e-118">A tabela tem três linhas: r1, r2 e r3.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="a6a2e-119">r1 tem três versões, r2 tem duas versões e r3 tem quatro versões.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="a6a2e-120">Observe que as versões diferentes da mesma linha não ocupam necessariamente locais de memória consecutivos.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="a6a2e-121">As versões de linha diferentes podem ser dispersas em toda a estrutura de dados da tabela.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="a6a2e-122">A estrutura de dados da tabela com otimização de memória pode ser considerada uma coleção de versões de linha.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="a6a2e-123">As linhas nas tabelas baseadas em disco são organizadas em páginas e extensões, e as linhas individuais são resolvidas através do número e do deslocamento da página, as versões de linha nas tabelas com otimização de memória são resolvidas através dos ponteiros de memória de 8 bytes.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="a6a2e-124">Durabilidade</span><span class="sxs-lookup"><span data-stu-id="a6a2e-124">Durability</span></span>  
 <span data-ttu-id="a6a2e-125">Por padrão, as tabelas com otimização de memória são completamente duráveis e, assim como as transações em tabelas baseadas em disco (tradicionais), as transações completamente duráveis em tabelas com otimização de memória são completamente ACID (atômicas, consistentes, isoladas e duráveis).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="a6a2e-126">As tabelas com otimização de memória e procedimentos armazenados compilados nativamente oferecem suporte a um subconjunto do [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a6a2e-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="a6a2e-127">O OLTP na Memória oferece suporte a tabelas duráveis com a durabilidade da transação atrasada.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="a6a2e-128">As transações duráveis atrasadas são salvas em disco logo depois que a transação é confirmada.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="a6a2e-129">Em compensação ao desempenho aprimorado, as transações confirmadas que não foram salvas em disco serão perdidas em caso de falha ou failover do servidor.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="a6a2e-130">Além das tabelas padrão com otimização de memória duráveis, o [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] também oferece suporte a tabelas com otimização de memória não duráveis, que não são registradas e seus dados não são persistidos no disco.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="a6a2e-131">Isso significa que as transações nessas tabelas não requerem nenhuma E/S de disco, mas os dados não serão recuperados se houver falha ou failover do servidor.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="a6a2e-132">Acessando dados nas tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="a6a2e-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="a6a2e-133">Os dados nas tabelas com otimização de memória são acessados de duas maneiras:</span><span class="sxs-lookup"><span data-stu-id="a6a2e-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="a6a2e-134">Com [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado (fora de um procedimento armazenado compilado nativamente).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="a6a2e-135">Essas instruções [!INCLUDE[tsql](../../../includes/tsql-md.md)] podem ser procedimentos armazenados interpretados internos ou instruções [!INCLUDE[tsql](../../../includes/tsql-md.md)] ad hoc.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="a6a2e-136">Por meio de procedimentos armazenados compilados nativamente.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="a6a2e-137">As tabelas com otimização de memória podem ser acessadas com mais eficiência por meio de procedimentos armazenados compilados de modo nativo ([Procedimentos armazenados compilados de modo nativo](natively-compiled-stored-procedures.md)).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="a6a2e-138">As tabelas com otimização de memória também podem ser acessadas com [!INCLUDE[tsql](../../../includes/tsql-md.md)]interpretado (tradicional).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="a6a2e-139">O termo [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado refere-se ao acesso a tabelas com otimização de memória sem um procedimento armazenado compilado nativamente.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="a6a2e-140">Alguns exemplos de acesso ao [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado incluem o acesso a uma tabela com otimização de memória de um gatilho DML ou de um lote [!INCLUDE[tsql](../../../includes/tsql-md.md)] ad hoc, exibição e função com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="a6a2e-141">A tabela a seguir resume o acesso ao [!INCLUDE[tsql](../../../includes/tsql-md.md)] nativo e interpretado de vários objetos.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="a6a2e-142">Recurso</span><span class="sxs-lookup"><span data-stu-id="a6a2e-142">Feature</span></span>|<span data-ttu-id="a6a2e-143">Acesso através de um procedimento armazenado compilado nativamente</span><span class="sxs-lookup"><span data-stu-id="a6a2e-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="a6a2e-144">Acesso [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado</span><span class="sxs-lookup"><span data-stu-id="a6a2e-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="a6a2e-145">Acesso à CLR</span><span class="sxs-lookup"><span data-stu-id="a6a2e-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="a6a2e-146">Tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="a6a2e-146">Memory-optimized tables</span></span>|<span data-ttu-id="a6a2e-147">Sim</span><span class="sxs-lookup"><span data-stu-id="a6a2e-147">Yes</span></span>|<span data-ttu-id="a6a2e-148">Sim</span><span class="sxs-lookup"><span data-stu-id="a6a2e-148">Yes</span></span>|<span data-ttu-id="a6a2e-149">Não <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="a6a2e-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="a6a2e-150">Variáveis de tabela com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="a6a2e-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="a6a2e-151">Sim</span><span class="sxs-lookup"><span data-stu-id="a6a2e-151">Yes</span></span>|<span data-ttu-id="a6a2e-152">Sim</span><span class="sxs-lookup"><span data-stu-id="a6a2e-152">Yes</span></span>|<span data-ttu-id="a6a2e-153">Não</span><span class="sxs-lookup"><span data-stu-id="a6a2e-153">No</span></span>|  
|[<span data-ttu-id="a6a2e-154">Procedimentos armazenados compilados nativamente</span><span class="sxs-lookup"><span data-stu-id="a6a2e-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="a6a2e-155">Você não pode usar a instrução EXECUTE para executar nenhum procedimento armazenado em um procedimento armazenado compilado nativamente.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="a6a2e-156">Sim</span><span class="sxs-lookup"><span data-stu-id="a6a2e-156">Yes</span></span>|<span data-ttu-id="a6a2e-157">Não <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="a6a2e-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="a6a2e-158"><sup>1</sup> você não pode acessar uma tabela com otimização de memória ou um procedimento armazenado compilado nativamente da conexão de contexto (a conexão do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] ao executar um módulo CLR).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="a6a2e-159">No entanto, é possível criar e abrir outra conexão, da qual você pode acessar tabelas com otimização de memória e procedimentos armazenados compilados nativamente.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="a6a2e-160">Para obter mais informações, consulte [regular versus conexões de contexto](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="a6a2e-161">Desempenho e escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a6a2e-161">Performance and Scalability</span></span>  
 <span data-ttu-id="a6a2e-162">Os seguintes fatores afetarão os ganhos de desempenho que podem ser obtidos com o OLTP na memória:</span><span class="sxs-lookup"><span data-stu-id="a6a2e-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="a6a2e-163">Comunicação</span><span class="sxs-lookup"><span data-stu-id="a6a2e-163">Communication</span></span>  
 <span data-ttu-id="a6a2e-164">Um aplicativo com muitas chamadas para procedimentos armazenados curtos pode ver um ganho de desempenho menor em comparação com um aplicativo com menos chamadas e mais funcionalidade implementada em cada procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="a6a2e-165">Execução</span><span class="sxs-lookup"><span data-stu-id="a6a2e-165">Execution</span></span>  
 <span data-ttu-id="a6a2e-166">O OLTP na memória atinge o melhor desempenho usando procedimentos armazenados compilados nativamente do que usando procedimentos armazenados interpretados ou execução de consulta.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="a6a2e-167">Os procedimentos armazenados que executam outros procedimentos armazenados não podem ser compilados nativamente, mas pode ser vantajoso acessar tabelas com otimização de memória nesses procedimentos.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="a6a2e-168">Varredura de intervalo x pesquisa de ponto</span><span class="sxs-lookup"><span data-stu-id="a6a2e-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="a6a2e-169">Os índices não clusterizados com otimização de memória dão suporte a exames de intervalo e exames ordenados.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="a6a2e-170">Para pesquisas de ponto, os índices de hash com otimização de memória têm desempenho melhor que os índices não clusterizados com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="a6a2e-171">Os índices não clusterizados com otimização de memória têm desempenho melhor que os índices baseados em disco.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="a6a2e-172">As operações de índice não são registradas e existem apenas na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="a6a2e-173">Simultaneidade</span><span class="sxs-lookup"><span data-stu-id="a6a2e-173">Concurrency</span></span>  
 <span data-ttu-id="a6a2e-174">Os aplicativos cujo desempenho é afetado pela simultaneidade no nível de mecanismo, como contenção de trava ou bloqueio, melhoram significativamente quando o aplicativo é movido para OLTP na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="a6a2e-175">A tabela a seguir lista os problemas de desempenho e escalabilidade que geralmente são encontrados em bancos de dados relacionais e como o OLTP na memória pode melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="a6a2e-176">Problema</span><span class="sxs-lookup"><span data-stu-id="a6a2e-176">Issue</span></span>|<span data-ttu-id="a6a2e-177">Impacto do OLTP na memória</span><span class="sxs-lookup"><span data-stu-id="a6a2e-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="a6a2e-178">Desempenho</span><span class="sxs-lookup"><span data-stu-id="a6a2e-178">Performance</span></span><br /><br /> <span data-ttu-id="a6a2e-179">Alto uso de recursos (CPU, E/S, rede ou memória).</span><span class="sxs-lookup"><span data-stu-id="a6a2e-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="a6a2e-180">CPU</span><span class="sxs-lookup"><span data-stu-id="a6a2e-180">CPU</span></span><br /> <span data-ttu-id="a6a2e-181">Os procedimentos armazenados compilados nativamente podem reduzir significativamente o uso da CPU, pois exigem muito menos instruções para executar uma instrução [!INCLUDE[tsql](../../../includes/tsql-md.md)] comparada com os procedimentos armazenados interpretados.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="a6a2e-182">O OLTP na memória pode ajudar a reduzir o investimento de hardware em cargas de trabalho expandidas, pois um servidor pode potencialmente fornecer a taxa de transferência de cinco a dez servidores.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="a6a2e-183">E/S</span><span class="sxs-lookup"><span data-stu-id="a6a2e-183">I/O</span></span><br /> <span data-ttu-id="a6a2e-184">Se você encontrar um gargalo de E/S, do processamento às páginas de dados ou índice, o OLTP na memória poderá reduzir esse gargalo.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="a6a2e-185">Além disso, o ponto de verificação de objetos OLTP na memória é contínuo e não resulta em aumentos repentinos nas operações de E/S.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="a6a2e-186">No entanto, se o conjunto de trabalho das tabelas críticas de desempenho não se ajustar na memória, o OLTP na memória não melhorará o desempenho, pois ele exige que os dados sejam residentes na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="a6a2e-187">Se você encontrar um gargalo de E/S no log, o OLTP na memória poderá reduzi-lo, pois ele gera menos registros.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="a6a2e-188">Se uma ou mais tabelas com otimização de memória forem configuradas como tabelas não duráveis, você poderá eliminar o registro de dados.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="a6a2e-189">Memória</span><span class="sxs-lookup"><span data-stu-id="a6a2e-189">Memory</span></span><br /> <span data-ttu-id="a6a2e-190">O OLTP na memória não oferece nenhum benefício de desempenho.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="a6a2e-191">Além disso, o OLTP na memória pode fazer mais pressão na memória, pois os objetos precisam ser residentes na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="a6a2e-192">Rede</span><span class="sxs-lookup"><span data-stu-id="a6a2e-192">Network</span></span><br /> <span data-ttu-id="a6a2e-193">O OLTP na memória não oferece nenhum benefício de desempenho.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="a6a2e-194">Os dados precisam ser comunicados da camada de dados à camada de aplicativos.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="a6a2e-195">Escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a6a2e-195">Scalability</span></span><br /><br /> <span data-ttu-id="a6a2e-196">A maioria dos problemas de colocação em escala nos aplicativos do [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] é causada por problemas de simultaneidade, como contenção em bloqueios, travas e spinlocks.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="a6a2e-197">Contenção de trava</span><span class="sxs-lookup"><span data-stu-id="a6a2e-197">Latch Contention</span></span><br /> <span data-ttu-id="a6a2e-198">Um cenário típico é a contenção na última página de um índice na inserção de linhas simultaneamente na ordem de chave.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="a6a2e-199">Como o OLTP na memória não usa travas ao acessar dados, os problemas de escalabilidade relacionados a contenções de trava são totalmente removidos.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="a6a2e-200">Contenção de spinlock</span><span class="sxs-lookup"><span data-stu-id="a6a2e-200">Spinlock Contention</span></span><br /> <span data-ttu-id="a6a2e-201">Como o OLTP na memória não usa travas ao acessar dados, os problemas de escalabilidade relacionados a contenções de spinlock são totalmente removidos.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="a6a2e-202">Contenção relacionada ao bloqueio</span><span class="sxs-lookup"><span data-stu-id="a6a2e-202">Locking Related Contention</span></span><br /> <span data-ttu-id="a6a2e-203">Se seu aplicativo de banco de dados detectar problemas de bloqueio entre operações de leitura e gravação, o OLTP na memória removerá esses problemas, pois ele usa um novo formulário de controle de simultaneidade otimista para implementar todos os níveis de isolamento de transação.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="a6a2e-204">O OLTP na memória não usa TempDB para armazenar versões de linha.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="a6a2e-205">Se o problema de colocação em escala for causado por um conflito entre duas operações de gravação, como duas transações simultâneas tentando atualizar a mesma linha, o OLTP na memória permitirá que uma transação tenha êxito e que a outra falhe.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="a6a2e-206">A transação com falha deve ser reenviada explícita ou implicitamente, repetindo a transação.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="a6a2e-207">Em ambos os casos, você precisa fazer alterações no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="a6a2e-208">Se seu aplicativo apresentar conflitos frequentes entre duas operações de gravação, o valor do bloqueio otimista será diminuído.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="a6a2e-209">O aplicativo não é apropriado para o OLTP na memória.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="a6a2e-210">A maioria dos aplicativos OLTP não apresenta conflitos de gravação, a menos que o conflito seja induzido pelo escalonamento de bloqueios.</span><span class="sxs-lookup"><span data-stu-id="a6a2e-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="a6a2e-211">Consulte Também</span><span class="sxs-lookup"><span data-stu-id="a6a2e-211">See Also</span></span>  
 [<span data-ttu-id="a6a2e-212">OLTP in-memory &#40;Otimização na memória&#41;</span><span class="sxs-lookup"><span data-stu-id="a6a2e-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
