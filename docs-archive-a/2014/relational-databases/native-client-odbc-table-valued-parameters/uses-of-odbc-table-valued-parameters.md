---
title: Usos de parâmetros com valor de tabela ODBC | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87685089"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="26b3b-102">Usos de parâmetros ODBC com valor de tabela</span><span class="sxs-lookup"><span data-stu-id="26b3b-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="26b3b-103">Este tópico discute os principais cenários de usuário para o uso de parâmetros com valor de tabela com ODBC:</span><span class="sxs-lookup"><span data-stu-id="26b3b-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="26b3b-104">Parâmetro com valor de tabela com buffers de várias linhas totalmente associados (Enviar dados como um RVP com todos os valores na memória)</span><span class="sxs-lookup"><span data-stu-id="26b3b-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="26b3b-105">Parâmetro com valor de tabela com streaming de linhas (Enviar dados como TVP usando dados em execução)</span><span class="sxs-lookup"><span data-stu-id="26b3b-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="26b3b-106">Recuperando metadados do parâmetro com valor de tabela do catálogo do sistema</span><span class="sxs-lookup"><span data-stu-id="26b3b-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="26b3b-107">Recuperando metadados do parâmetro com valor de tabela para uma instrução preparada</span><span class="sxs-lookup"><span data-stu-id="26b3b-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="26b3b-108">Parâmetro com valor de tabela com buffers de várias linhas totalmente associados (Enviar dados como um RVP com todos os valores na memória)</span><span class="sxs-lookup"><span data-stu-id="26b3b-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="26b3b-109">Quando usados com buffers de várias linhas totalmente associados, todos os valores de parâmetro ficam disponíveis na memória.</span><span class="sxs-lookup"><span data-stu-id="26b3b-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="26b3b-110">Por exemplo, isto é típico de uma transação de OLTP na qual os parâmetros com valor de tabela podem ser empacotados em um único procedimento armazenado.</span><span class="sxs-lookup"><span data-stu-id="26b3b-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="26b3b-111">Sem parâmetros com valor de tabela, isso envolveria gerar um lote de várias instruções complexas dinamicamente ou fazer várias chamadas para o servidor.</span><span class="sxs-lookup"><span data-stu-id="26b3b-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="26b3b-112">O parâmetro com valor de tabela é associado usando [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) junto com os outros parâmetros.</span><span class="sxs-lookup"><span data-stu-id="26b3b-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="26b3b-113">Depois que todos os parâmetros tiverem sido associados, o aplicativo definirá o atributo Focus do parâmetro, SQL_SOPT_SS_PARAM_FOCUS, em cada parâmetro com valor de tabela e chamará SQLBindParameter para as colunas do parâmetro com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="26b3b-114">O tipo de servidor para um parâmetro com valor de tabela é um novo tipo específico do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], o SQL_SS_TABLE.</span><span class="sxs-lookup"><span data-stu-id="26b3b-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="26b3b-115">O tipo de C que associa para SQL_SS_TABLE sempre deve ser SQL_C_DEFAULT.</span><span class="sxs-lookup"><span data-stu-id="26b3b-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="26b3b-116">Nenhum dado é transferido para o parâmetro associado ao parâmetro com valor de tabela. Ele é usado para transmitir metadados de tabela e controlar a maneira de transmitir dados nas colunas constituintes do parâmetro com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="26b3b-117">O comprimento do parâmetro com valor tabela é definido como o número de linhas que são enviadas ao servidor.</span><span class="sxs-lookup"><span data-stu-id="26b3b-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="26b3b-118">O parâmetro *ColumnSize* de SQLBindParameter para um parâmetro com valor de tabela especifica o número máximo de linhas que podem ser enviadas; Esse é o tamanho da matriz dos buffers de coluna.</span><span class="sxs-lookup"><span data-stu-id="26b3b-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="26b3b-119">*ParameterValuePtr* é o buffer de parâmetro para um parâmetro com valor de tabela em SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="26b3b-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="26b3b-120">*ParameterValuePtr* e seus *BufferLength* associados são usados para passar o nome de tipo do parâmetro com valor de tabela quando necessário.</span><span class="sxs-lookup"><span data-stu-id="26b3b-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="26b3b-121">O nome de tipo não é necessário para chamadas de procedimento armazenado, mas é necessário para instruções SQL.</span><span class="sxs-lookup"><span data-stu-id="26b3b-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="26b3b-122">Quando um nome de tipo de parâmetro com valor de tabela é especificado em uma chamada para SQLBindParameter, ele sempre deve ser especificado como um valor Unicode, mesmo em aplicativos criados como aplicativos ANSI.</span><span class="sxs-lookup"><span data-stu-id="26b3b-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="26b3b-123">Quando você especifica um nome de tipo de parâmetro com valor de tabela usando SQLSetDescField, você pode usar um literal que está de acordo com a maneira como o aplicativo é compilado.</span><span class="sxs-lookup"><span data-stu-id="26b3b-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="26b3b-124">O Gerenciador do Driver ODBC executará todas as conversões de Unicode necessárias.</span><span class="sxs-lookup"><span data-stu-id="26b3b-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="26b3b-125">Os metadados para parâmetros com valor de tabela e colunas de parâmetro com valor de tabela podem ser manipulados individualmente e explicitamente usando SQLGetDescRec, SQLSetDescRec, SQLGetDescField e SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="26b3b-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="26b3b-126">No entanto, o sobrecarregamento de SQLBindParameter é geralmente mais conveniente e não requer acesso de descritor explícito na maioria dos casos.</span><span class="sxs-lookup"><span data-stu-id="26b3b-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="26b3b-127">Essa abordagem é consistente com a definição de SQLBindParameter para outros tipos de dados, exceto pelo fato de que, para um parâmetro com valor de tabela, os campos de descritor afetados são ligeiramente diferentes.</span><span class="sxs-lookup"><span data-stu-id="26b3b-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="26b3b-128">Às vezes, um aplicativo usa um parâmetro com valor de tabela com SQL dinâmico e é necessário fornecer o nome do tipo do parâmetro com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="26b3b-129">Se esse for o caso e o parâmetro com valor de tabela não estiver definido no esquema padrão atual para a conexão, SQL_CA_SS_TYPE_CATALOG_NAME e SQL_CA_SS_TYPE_SCHEMA_NAME deverão ser definidos usando SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="26b3b-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="26b3b-130">Como as definições de tipo de tabela e parâmetros com valor de tabela devem ocorrer no mesmo banco de dados, SQL_CA_SS_TYPE_CATALOG_NAME não deve ser definido se o aplicativo usar parâmetros com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="26b3b-131">Caso contrário, o SQLSetDescField relatará um erro.</span><span class="sxs-lookup"><span data-stu-id="26b3b-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="26b3b-132">O código de exemplo para esse cenário está no procedimento `demo_fixed_TVP_binding` em [usar parâmetros com valor de tabela &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="26b3b-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="26b3b-133">Parâmetro com valor de tabela com streaming de linhas (Enviar dados como TVP usando dados em execução)</span><span class="sxs-lookup"><span data-stu-id="26b3b-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="26b3b-134">Neste cenário, o aplicativo fornece linhas ao driver conforme ele precisa e elas são transmitidas ao servidor.</span><span class="sxs-lookup"><span data-stu-id="26b3b-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="26b3b-135">Isto evita ter a necessidade de armazenar em buffer todas as linhas na memória.</span><span class="sxs-lookup"><span data-stu-id="26b3b-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="26b3b-136">Isto representa os cenários de inserção/atualização em massa.</span><span class="sxs-lookup"><span data-stu-id="26b3b-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="26b3b-137">Parâmetros com valor de tabela fornecem um ponto de desempenho em algum local entre as matrizes do parâmetro e a cópia em massa.</span><span class="sxs-lookup"><span data-stu-id="26b3b-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="26b3b-138">Isto é, parâmetros com valor de tabela são quase tão simples de programar quanto matrizes de parâmetros, mas eles fornecem mais flexibilidade no servidor.</span><span class="sxs-lookup"><span data-stu-id="26b3b-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="26b3b-139">O parâmetro com valor de tabela e suas colunas são associados conforme discutido na seção anterior, Parâmetro com valor de tabela com buffers de várias linhas totalmente associados, mas o indicador de comprimento do parâmetro com valor de tabela é definido como SQL_DATA_AT_EXEC.</span><span class="sxs-lookup"><span data-stu-id="26b3b-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="26b3b-140">O driver responde a SQLExecute ou SQLExecuteDirect da maneira usual para parâmetros de dados em execução, ou seja, retornando SQL_NEED_DATA.</span><span class="sxs-lookup"><span data-stu-id="26b3b-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="26b3b-141">Quando o driver estiver pronto para aceitar dados para um parâmetro com valor de tabela, SQLParamData retornará o valor de *ParameterValuePtr* em SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="26b3b-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="26b3b-142">Um aplicativo usa SQLPutData para um parâmetro com valor de tabela para indicar a disponibilidade de dados para colunas constituintes de parâmetro com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="26b3b-143">Quando SQLPutData é chamado para um parâmetro com valor de tabela, *DataPtr* sempre deve ser nulo e *StrLen_or_Ind* deve ser 0 ou um número menor ou igual ao tamanho da matriz especificado para os buffers de parâmetro com valor de tabela (o parâmetro *colunasize* de SQLBindParameter).</span><span class="sxs-lookup"><span data-stu-id="26b3b-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="26b3b-144">0 significa que não há mais linhas para o parâmetro com valor de tabela e que o driver continuará a processar o próximo parâmetro de procedimento real.</span><span class="sxs-lookup"><span data-stu-id="26b3b-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="26b3b-145">Quando *StrLen_or_Ind* não for 0, o driver processará as colunas constituintes do parâmetro com valor de tabela da mesma maneira que os parâmetros vinculados a parâmetros que não têm valor de tabela: cada coluna de parâmetro com valor de tabela pode especificar seu comprimento de dados real, SQL_NULL_DATA ou pode especificar dados na execução por meio de seu buffer de comprimento/indicador.</span><span class="sxs-lookup"><span data-stu-id="26b3b-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="26b3b-146">Os valores de coluna de parâmetro com valor de tabela podem ser passados por chamadas repetidas para SQLPutData como de costume quando um valor de caractere ou binário é passado em partes.</span><span class="sxs-lookup"><span data-stu-id="26b3b-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="26b3b-147">Quando todas as colunas de parâmetro com valor de tabela tiverem sido processadas, o driver retornará ao parâmetro com valor de tabela para processar outras linhas dos dados.</span><span class="sxs-lookup"><span data-stu-id="26b3b-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="26b3b-148">Portanto, para parâmetros com valor de tabela de dados em execução, o driver não segue a verificação sequencial habitual de parâmetros associados.</span><span class="sxs-lookup"><span data-stu-id="26b3b-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="26b3b-149">Um parâmetro de valor de tabela associado será sondado até que SQLPutData seja chamado com *StrLen_or_IndPtr* igual a 0, quando o driver ignorar colunas de parâmetro com valor de tabela e passar para o próximo parâmetro de procedimento armazenado real.</span><span class="sxs-lookup"><span data-stu-id="26b3b-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="26b3b-150">Quando SQLPutData passa um valor de indicador maior ou igual a 1, o driver processa colunas de parâmetro com valor de tabela e linhas sequencialmente até que tenha valores para todas as linhas e colunas associadas.</span><span class="sxs-lookup"><span data-stu-id="26b3b-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="26b3b-151">Então o driver retornará o parâmetro com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="26b3b-152">Entre o recebimento do token para o parâmetro com valor de tabela de SQLParamData e a chamada de SQLPutData (HSTMT, NULL, n) para um parâmetro com valor de tabela, o aplicativo deve definir dados de coluna constituintes de parâmetro com valor de tabela e o conteúdo do buffer de indicador para a próxima linha ou linhas a serem passadas para o servidor.</span><span class="sxs-lookup"><span data-stu-id="26b3b-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="26b3b-153">O código de exemplo para esse cenário está na rotina `demo_variable_TVP_binding` em [usar parâmetros com valor de tabela &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="26b3b-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="26b3b-154">Recuperando metadados do parâmetro com valor de tabela do catálogo do sistema</span><span class="sxs-lookup"><span data-stu-id="26b3b-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="26b3b-155">Quando um aplicativo chama SQLProcedureColumns para um procedimento que tem parâmetros de parâmetro com valor de tabela, DATA_TYPE é retornado como SQL_SS_TABLE e TYPE_NAME é o nome do tipo de tabela para o parâmetro com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="26b3b-156">Duas colunas adicionais são adicionadas ao conjunto de resultados retornado por SQLProcedureColumns: SS_TYPE_CATALOG_NAME retorna o nome do catálogo em que o tipo de tabela do parâmetro de valor de tabela é definido e SS_TYPE_SCHEMA_NAME retorna o nome do esquema onde o tipo de tabela do parâmetro de tabela-valor é definido.</span><span class="sxs-lookup"><span data-stu-id="26b3b-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="26b3b-157">Em conformidade com a especificação ODBC, SS_TYPE_CATALOG_NAME e SS_TYPE_SCHEMA_NAME aparecem antes de todas as colunas específicas do driver que foram adicionadas em versões anteriores do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] e depois de todas as colunas exigidas pelo próprio ODBC.</span><span class="sxs-lookup"><span data-stu-id="26b3b-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="26b3b-158">As colunas novas serão populadas não apenas para parâmetros com valor de tabela, mas também para parâmetros de tipo definido pelo usuário de CLR.</span><span class="sxs-lookup"><span data-stu-id="26b3b-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="26b3b-159">As colunas existentes do esquema e do catálogo de parâmetros UDT ainda serão populadas, mas ter colunas de esquema e catálogo para tipos de dados que precisem delas simplificará o desenvolvimento do aplicativo no futuro.</span><span class="sxs-lookup"><span data-stu-id="26b3b-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="26b3b-160">(Observe que as coleções de esquema XML são ligeiramente diferentes e não estão incluídas nessa alteração.)</span><span class="sxs-lookup"><span data-stu-id="26b3b-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="26b3b-161">Um aplicativo usa SQLTables para determinar os nomes dos tipos de tabela da mesma maneira que faz para tabelas persistentes, tabelas do sistema e exibições.</span><span class="sxs-lookup"><span data-stu-id="26b3b-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="26b3b-162">Um tipo de tabela novo, TABLE TYPE, é introduzido para permitir que um aplicativo para identifique tipos de tabela associados com parâmetros com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="26b3b-163">Tipos de tabela e tabelas regulares usam namespaces diferentes.</span><span class="sxs-lookup"><span data-stu-id="26b3b-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="26b3b-164">Isto significa que você pode usar o mesmo nome para um tipo de tabela e uma tabela real.</span><span class="sxs-lookup"><span data-stu-id="26b3b-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="26b3b-165">Para tratar isto, um novo atributo de instrução, SQL_SOPT_SS_NAME_SCOPE, foi introduzido.</span><span class="sxs-lookup"><span data-stu-id="26b3b-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="26b3b-166">Esse atributo especifica se SQLTables e outras funções de catálogo que usam um nome de tabela como parâmetro devem interpretar o nome da tabela como o nome de uma tabela real ou o nome de um tipo de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="26b3b-167">Um aplicativo usa SQLColumns para determinar as colunas para um tipo de tabela da mesma maneira que faz para tabelas persistentes, mas deve primeiro definir SQL_SOPT_SS_NAME_SCOPE para indicar que ele está funcionando com tipos de tabela em vez de tabelas reais.</span><span class="sxs-lookup"><span data-stu-id="26b3b-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="26b3b-168">SQLPrimaryKeys também pode ser usado com tipos de tabela, novamente usando SQL_SOPT_SS_NAME_SCOPE.</span><span class="sxs-lookup"><span data-stu-id="26b3b-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="26b3b-169">O código de exemplo para esse cenário está na rotina `demo_metadata_from_catalog_APIs` em [usar parâmetros com valor de tabela &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="26b3b-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="26b3b-170">Recuperando metadados do parâmetro com valor de tabela para uma instrução preparada</span><span class="sxs-lookup"><span data-stu-id="26b3b-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="26b3b-171">Nesse cenário, um aplicativo usa SQLNumParameters e SQLDescribeParam para recuperar metadados para parâmetros com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="26b3b-172">O campo de IPD SQL_CA_SS_TYPE_NAME é usado para recuperar o nome de tipo para parâmetros com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="26b3b-173">Os campos de IPD SQL_CA_SS_TYPE_SCHEMA_NAME e SQL_CA_SS_TYPE_CATALOG_NAME são usados para recuperar seu catálogo e seu esquema, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="26b3b-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="26b3b-174">As definições de tipo de tabela e parâmetros com valor de tabela devem ocorrer no mesmo banco de dados.</span><span class="sxs-lookup"><span data-stu-id="26b3b-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="26b3b-175">O SQLSetDescField relatará um erro se um aplicativo definir SQL_CA_SS_TYPE_CATALOG_NAME ao usar parâmetros com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="26b3b-176">Também é possível usar SQL_CA_SS_TYPE_CATALOG_NAME e SQL_CA_SS_TYPE_SCHEMA_NAME para recuperar o catálogo e o esquema associados com parâmetros de tipo definido pelo usuário CLR.</span><span class="sxs-lookup"><span data-stu-id="26b3b-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="26b3b-177">SQL_CA_SS_TYPE_CATALOG_NAME e SQL_CA_SS_TYPE_SCHEMA_NAME são alternativas aos atributos de esquema de catálogo específico de tipos UDT da CLR.</span><span class="sxs-lookup"><span data-stu-id="26b3b-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="26b3b-178">Um aplicativo usa SQLColumns para recuperar metadados de coluna para um parâmetro com valor de tabela nesse cenário também, porque SQLDescribeParam não retorna metadados para as colunas de uma coluna de parâmetro com valor de tabela.</span><span class="sxs-lookup"><span data-stu-id="26b3b-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="26b3b-179">O código de exemplo para esse caso de uso está na rotina `demo_metadata_from_prepared_statement` em [usar parâmetros com valor de tabela &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="26b3b-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="26b3b-180">Consulte Também</span><span class="sxs-lookup"><span data-stu-id="26b3b-180">See Also</span></span>  
 [<span data-ttu-id="26b3b-181">Parâmetros com valor de tabela &#40;&#41;ODBC</span><span class="sxs-lookup"><span data-stu-id="26b3b-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
