---
title: Diretrizes para níveis de isolamento de transação com tabelas com otimização de memória | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: e365e9ca-c34b-44ae-840c-10e599fa614f
author: stevestein
ms.author: sstein
ms.openlocfilehash: 834c5950a8f8b0ddf8854d06c6fb1073a264fc22
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87681075"
---
# <a name="guidelines-for-transaction-isolation-levels-with-memory-optimized-tables"></a><span data-ttu-id="c0df6-102">Diretrizes para níveis de isolamento da transação com tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="c0df6-102">Guidelines for Transaction Isolation Levels with Memory-Optimized Tables</span></span>
  <span data-ttu-id="c0df6-103">Em vários cenários, você deve especificar o nível de isolamento da transação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-103">In many scenarios, you must specify the transaction isolation level.</span></span> <span data-ttu-id="c0df6-104">O isolamento da transação para tabelas com otimização de memória difere das tabelas baseadas em disco.</span><span class="sxs-lookup"><span data-stu-id="c0df6-104">Transaction isolation for memory-optimized tables differs from disk-based tables.</span></span>  
  
 <span data-ttu-id="c0df6-105">Requisitos para especificação do nível de isolamento da transação:</span><span class="sxs-lookup"><span data-stu-id="c0df6-105">Requirements for specifying transaction isolation level:</span></span>  
  
-   <span data-ttu-id="c0df6-106">TRANSACTION ISOLATION LEVEL é uma opção necessária no bloco ATOMIC que compõe o conteúdo de um procedimento armazenado compilado nativamente.</span><span class="sxs-lookup"><span data-stu-id="c0df6-106">TRANSACTION ISOLATION LEVEL is a required option for the ATOMIC block comprising the content of a natively compiled stored procedure.</span></span>  
  
-   <span data-ttu-id="c0df6-107">Devido às restrições do uso em nível de isolamento nas transações entre contêineres, os usos das tabelas com otimização de memória no [!INCLUDE[tsql](../includes/tsql-md.md)] interpretado devem sempre ser acompanhados por uma dica de tabela que especifique o nível de isolamento usado para acessar a tabela.</span><span class="sxs-lookup"><span data-stu-id="c0df6-107">Because of restrictions on isolation level use in cross-container transactions, uses of memory-optimized tables in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] must often be accompanied by a table hint specifying the isolation level used to access the table.</span></span> <span data-ttu-id="c0df6-108">Para obter mais informações sobre dicas de nível de isolamento e transações entre contêineres, consulte [níveis de isolamento da transação](../../2014/database-engine/transaction-isolation-levels.md).</span><span class="sxs-lookup"><span data-stu-id="c0df6-108">For more information about isolation level hints and cross-container transactions, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>  
  
-   <span data-ttu-id="c0df6-109">O nível de isolamento da transação desejado deve ser explicitamente declarado.</span><span class="sxs-lookup"><span data-stu-id="c0df6-109">The desired transaction isolation level must be explicitly declared.</span></span> <span data-ttu-id="c0df6-110">Não é possível usar dicas de bloqueio (como XLOCK) para garantir o isolamento de determinadas linhas ou tabelas na transação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-110">It is not possible to use locking hints (such as XLOCK) to guarantee the isolation of certain rows or tables in the transaction.</span></span>  
  
-   <span data-ttu-id="c0df6-111">O aplicativo que acessa o banco de dados deve implementar a lógica de repetição para tratar erros resultantes de conflitos decretados por transação, de falhas de validação e de falhas de dependência de confirmação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-111">The application accessing the database should implement retry logic to deal with errors resulting from transaction-dooming conflicts, validation failures, and commit-dependency failures.</span></span> <span data-ttu-id="c0df6-112">Observe que as falhas de dependência de confirmação podem ocorrer até mesmo com transações somente leitura.</span><span class="sxs-lookup"><span data-stu-id="c0df6-112">Note that commit dependency failures can occur even with read-only transactions.</span></span>  
  
-   <span data-ttu-id="c0df6-113">As transações de longa execução devem ser evitadas com tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="c0df6-113">Long-running transactions should be avoided with memory-optimized tables.</span></span> <span data-ttu-id="c0df6-114">Essas transações aumentam a probabilidade de conflitos e subsequentes encerramentos de transações.</span><span class="sxs-lookup"><span data-stu-id="c0df6-114">Such transactions increase the likelihood of conflicts and subsequent transaction terminations.</span></span> <span data-ttu-id="c0df6-115">Uma transação de execução longa também adia a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="c0df6-115">A long-running transaction also defers garbage collection.</span></span> <span data-ttu-id="c0df6-116">Quanto mais demorada for a transação, mais o OLTP na memória manterá versões de linhas excluídas recentemente, o que pode diminuir o desempenho da pesquisa de novas transações.</span><span class="sxs-lookup"><span data-stu-id="c0df6-116">The longer a transaction runs, the longer In-Memory OLTP keeps recently deleted row versions, which can decrease lookup performance for new transactions.</span></span>  
  
 <span data-ttu-id="c0df6-117">As tabelas baseadas em disco normalmente se baseiam no bloqueio do isolamento da transação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-117">Disk-based tables typically rely on locking and blocking for transaction isolation.</span></span> <span data-ttu-id="c0df6-118">As tabelas com otimização de memória contam com o controle de várias versões e detecção de conflito para garantir o isolamento.</span><span class="sxs-lookup"><span data-stu-id="c0df6-118">Memory-optimized tables rely on multi-versioning and conflict detection to guarantee isolation.</span></span> <span data-ttu-id="c0df6-119">Para obter detalhes, consulte a seção sobre detecção de conflito, validação e verificações de dependência de confirmação em [transações em tabelas com otimização de memória](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="c0df6-119">For details, see the section on Conflict Detection, Validation, and Commit Dependency Checks in [Transactions in Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="c0df6-120">As tabelas baseadas em disco permitem o controle de várias versões nos níveis de isolamento SNAPSHOT e READ_COMMITTED_SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="c0df6-120">Disk-based tables do allow multi-versioning with the isolation levels SNAPSHOT and READ_COMMITTED_SNAPSHOT.</span></span> <span data-ttu-id="c0df6-121">Nas tabelas com otimização de memória, todos os níveis de isolamento baseiam-se no controle de várias versões, incluindo REPEATABLE READ e SERIALIZABLE.</span><span class="sxs-lookup"><span data-stu-id="c0df6-121">For memory-optimized tables all isolation levels are multi-version based, including REPEATABLE READ and SERIALIZABLE.</span></span>  
  
## <a name="types-of-transactions"></a><span data-ttu-id="c0df6-122">Tipos de transações</span><span class="sxs-lookup"><span data-stu-id="c0df6-122">Types of Transactions</span></span>  
 <span data-ttu-id="c0df6-123">Cada consulta no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] é executada no contexto de uma transação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-123">Every query in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] runs in the context of a transaction.</span></span>  
  
 <span data-ttu-id="c0df6-124">Há três tipos de transações no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="c0df6-124">There are three types of transactions in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="c0df6-125">Transações de confirmação automática.</span><span class="sxs-lookup"><span data-stu-id="c0df6-125">Autocommit transactions.</span></span> <span data-ttu-id="c0df6-126">Se não houver nenhum contexto de transação ativo e as transações implícitas não estiverem definidas como ON na sessão, cada consulta terá seu próprio contexto de transação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-126">If there is no active transaction context and implicit transactions are not set to ON in the session, each query has its own transaction context.</span></span> <span data-ttu-id="c0df6-127">A transação inicia quando a instrução começa a execução e termina quando a instrução é concluída.</span><span class="sxs-lookup"><span data-stu-id="c0df6-127">The transaction starts when the statement starts execution, and completes when the statement finishes.</span></span>  
  
-   <span data-ttu-id="c0df6-128">Transações explícitas.</span><span class="sxs-lookup"><span data-stu-id="c0df6-128">Explicit transactions.</span></span> <span data-ttu-id="c0df6-129">O usuário inicia a transação através de uma instrução BEGIN TRAN ou BEGIN ATOMIC explícita.</span><span class="sxs-lookup"><span data-stu-id="c0df6-129">The user starts the transaction through an explicit BEGIN TRAN or BEGIN ATOMIC.</span></span> <span data-ttu-id="c0df6-130">A transação é concluída após as instruções COMMIT e ROLLBACK correspondentes ou END (no caso de um bloco atômico).</span><span class="sxs-lookup"><span data-stu-id="c0df6-130">The transaction is completed following the corresponding COMMIT and ROLLBACK or END (in the case of an atomic block).</span></span>  
  
-   <span data-ttu-id="c0df6-131">Transações implícitas.</span><span class="sxs-lookup"><span data-stu-id="c0df6-131">Implicit transactions.</span></span> <span data-ttu-id="c0df6-132">Quando a opção IMPLICIT_TRANSACTIONS é definida como ON, uma transação é iniciada implicitamente sempre que o usuário executa uma instrução e não há nenhum contexto de transação ativo.</span><span class="sxs-lookup"><span data-stu-id="c0df6-132">When the option IMPLICIT_TRANSACTIONS is set to ON, a transaction is started implicitly whenever the user executes a statement and there is no active transaction context.</span></span> <span data-ttu-id="c0df6-133">A transação é concluída através de uma instrução COMMIT e ROLLBACK explícita.</span><span class="sxs-lookup"><span data-stu-id="c0df6-133">The transaction is completed through an explicit COMMIT and ROLLBACK.</span></span>  
  
## <a name="baseline-read-committed-isolation"></a><span data-ttu-id="c0df6-134">Isolamento READ COMMITTED de linha de base</span><span class="sxs-lookup"><span data-stu-id="c0df6-134">Baseline READ COMMITTED Isolation</span></span>  
 <span data-ttu-id="c0df6-135">READ COMMITTED é o nível de isolamento padrão no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c0df6-135">READ COMMITTED is the default isolation level in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="c0df6-136">O nível de isolamento READ COMMITTED garante que as transações não encontrem dados não confirmados de alterações fora da transação atual.</span><span class="sxs-lookup"><span data-stu-id="c0df6-136">The isolation level READ COMMITTED guarantees that transactions do not see any uncommitted data from changes outside the current transaction.</span></span> <span data-ttu-id="c0df6-137">Ou seja, a transação lê apenas os dados que foram confirmados para o banco de dados, ou que foram alterados pela transação atual.</span><span class="sxs-lookup"><span data-stu-id="c0df6-137">In other words, the transaction only reads data which has either been committed to the database, or has been changed by the current transaction.</span></span>  
  
 <span data-ttu-id="c0df6-138">Todos os níveis de isolamento com suporte para tabelas com otimização de memória fornecem a garantia de leitura confirmada.</span><span class="sxs-lookup"><span data-stu-id="c0df6-138">All isolation levels supported for memory-optimized tables provide the read committed guarantee.</span></span> <span data-ttu-id="c0df6-139">Portanto, se a transação não exigir garantias mais fortes, você pode usar qualquer nível de isolamento com suporte para tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="c0df6-139">Therefore, if the transaction does not require stronger guarantees, you can use any of the isolation levels supported for memory-optimized tables.</span></span> <span data-ttu-id="c0df6-140">O nível de isolamento SNAPSHOT usa o menor número possível de recursos do sistema, comparados com outros níveis de isolamento.</span><span class="sxs-lookup"><span data-stu-id="c0df6-140">SNAPSHOT uses the fewest system resources, compared to other isolation levels.</span></span>  
  
 <span data-ttu-id="c0df6-141">A garantia fornecida pelo nível de isolamento SNAPSHOT (o nível inferior de isolamento com suporte para tabelas com otimização de memória) inclui as garantias de READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="c0df6-141">The guarantee provided by the SNAPSHOT isolation level (the lowest level of isolation supported for memory-optimized tables) includes the guarantees of READ COMMITTED.</span></span> <span data-ttu-id="c0df6-142">Cada instrução da transação lê a mesma versão consistente do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="c0df6-142">Every statement in the transaction reads the same, consistent version of the database.</span></span> <span data-ttu-id="c0df6-143">Não somente todas as linhas são lidas pela transação confirmada no banco de dados, como também todas as operações de leitura veem o conjunto de alterações feito pelo mesmo conjunto de transações.</span><span class="sxs-lookup"><span data-stu-id="c0df6-143">Not only are all the rows read by the transaction committed to the database, also all the read operations see the set of changes made by the same set of transactions.</span></span>  
  
 <span data-ttu-id="c0df6-144">**Diretriz**: se apenas a garantia de isolamento de leitura confirmada for necessária, use o isolamento de instantâneo com procedimentos armazenados compilados nativamente e para acessar tabelas com otimização de memória por meio de interpretado [!INCLUDE[tsql](../includes/tsql-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="c0df6-144">**Guideline**: If only the READ COMMITTED isolation guarantee is required, use SNAPSHOT isolation with natively compiled stored procedures and for accessing memory-optimized tables through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="c0df6-145">Para transações de confirmação automática, o nível de isolamento READ COMMITTED é mapeado implicitamente para SNAPSHOT nas tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="c0df6-145">For autocommit transactions, the isolation level READ COMMITTED is implicitly mapped to SNAPSHOT for memory-optimized tables.</span></span> <span data-ttu-id="c0df6-146">Portanto, se a configuração de sessão TRANSACTION ISOLATION LEVEL for definida como READ COMMITTED, não será necessário especificar o nível de isolamento através de uma dica de tabela ao acessar tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="c0df6-146">Therefore, if the TRANSACTION ISOLATION LEVEL session setting is set to READ COMMITTED, it is not necessary to specify the isolation level through a table hint when accessing memory-optimized tables.</span></span>  
  
 <span data-ttu-id="c0df6-147">O exemplo de transação de confirmação automática a seguir mostra uma junção entre uma tabela com otimização de memória Customers e uma tabela normal [Order History], como parte de um lote ad hoc:</span><span class="sxs-lookup"><span data-stu-id="c0df6-147">The following autocommit transaction example shows a join between a memory-optimized table Customers and a regular table [Order History], as part of an ad hoc batch:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
SELECT *   
FROM dbo.Customers AS c   
LEFT JOIN dbo.[Order History] AS oh   
    ON c.customer_id = oh.customer_id;  
```  
  
 <span data-ttu-id="c0df6-148">O seguinte exemplo de transações explícitas ou implícitas mostra a mesma junção, mas dessa vez em uma transação de usuário explícita.</span><span class="sxs-lookup"><span data-stu-id="c0df6-148">The following explicit or implicit transactions example shows the same join, but this time in an explicit user transaction.</span></span> <span data-ttu-id="c0df6-149">A tabela com otimização de memória Customers é acessada no isolamento de instantâneo, conforme indicado através da dica de tabela WITH (SNAPSHOT), e a tabela [Order History] normal é acessada no isolamento de leitura confirmada:</span><span class="sxs-lookup"><span data-stu-id="c0df6-149">The memory-optimized table Customers is accessed under snapshot isolation, as indicated through the table hint WITH (SNAPSHOT), and the regular table [Order History] is accessed under read committed isolation:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED  
GO  
BEGIN TRAN  
SELECT * FROM dbo.Customers c with (SNAPSHOT)   
LEFT JOIN dbo.[Order History] oh   
    ON c.customer_id=oh.customer_id  
...  
COMMIT  
```  
  
### <a name="operational-differences"></a><span data-ttu-id="c0df6-150">Diferenças operacionais</span><span class="sxs-lookup"><span data-stu-id="c0df6-150">Operational Differences</span></span>  
 <span data-ttu-id="c0df6-151">Além da garantia de leitura confirmada, também há dois detalhes de implementação fundamentais que os aplicativos que usam tabelas baseadas em disco podem usar.</span><span class="sxs-lookup"><span data-stu-id="c0df6-151">Besides the read committed guarantee, there are also two key implementation details that applications using disk-based tables may rely on.</span></span> <span data-ttu-id="c0df6-152">Lembre-se do seguinte ao converter uma tabela baseada em disco acessada por meio do isolamento READ COMMITTED em tabela com otimização de memória acessada por meio do isolamento SNAPSHOT:</span><span class="sxs-lookup"><span data-stu-id="c0df6-152">Be aware of the following when converting a disk-based table that is accessed using READ COMMITTED isolation to a memory-optimized table that is accessed using SNAPSHOT isolation:</span></span>  
  
-   <span data-ttu-id="c0df6-153">A implementação do nível de isolamento READ COMMITTED das tabelas baseadas em disco (pressupondo que READ_COMMITTED_SNAPSHOT esteja desativado) usa bloqueios para evitar conflitos entre leitores e gravadores.</span><span class="sxs-lookup"><span data-stu-id="c0df6-153">The implementation of the READ COMMITTED isolation level for disk-based tables (assuming READ_COMMITTED_SNAPSHOT is OFF) uses locks to prevent conflicts between readers and writers.</span></span> <span data-ttu-id="c0df6-154">Quando um gravador inicia a atualização de uma linha, ele usa um bloqueio e o libera apenas depois que a transação é confirmada.</span><span class="sxs-lookup"><span data-stu-id="c0df6-154">When a writer starts updating a row, it takes a lock and does not release the lock until the transaction is committed.</span></span> <span data-ttu-id="c0df6-155">Todas as operações de leitura são bloqueadas e esperarão a transação de gravação ser confirmada.</span><span class="sxs-lookup"><span data-stu-id="c0df6-155">Any read operations are blocked and will wait for the write transaction to commit.</span></span>  
  
     <span data-ttu-id="c0df6-156">Alguns aplicativos podem assumir que os leitores sempre esperarão a confirmação dos gravadores, especialmente se houver alguma sincronização entre as duas transações na camada de aplicativos.</span><span class="sxs-lookup"><span data-stu-id="c0df6-156">Some applications may assume readers always wait for writers to commit, particularly if there is any synchronization between the two transactions in the application tier.</span></span>  
  
     <span data-ttu-id="c0df6-157">**Diretriz:** Os aplicativos não podem depender do comportamento de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="c0df6-157">**Guideline:** Applications cannot rely on blocking behavior.</span></span> <span data-ttu-id="c0df6-158">Se um aplicativo precisar de sincronização entre transações simultâneas, essa lógica poderá ser implementada na camada de aplicativo ou na camada de banco de dados, por meio de [sp_getapplock &#40;&#41;Transact-SQL ](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="c0df6-158">If an application needs synchronization between concurrent transactions, such logic can be implemented in the application tier or in the database tier, through [sp_getapplock &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span></span>  
  
-   <span data-ttu-id="c0df6-159">Em transações que usam o isolamento READ COMMITTED, cada instrução considera a versão mais recente das linhas no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="c0df6-159">In transactions that use READ COMMITTED isolation, each statement sees the most recent version of the rows in the database.</span></span> <span data-ttu-id="c0df6-160">Portanto, as instruções subsequentes veem as alterações no estado do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="c0df6-160">Therefore, subsequent statements see changes in the state of the database.</span></span>  
  
     <span data-ttu-id="c0df6-161">A sondagem de uma tabela através de um loop WHILE até uma nova linha ser encontrada é um exemplo de um padrão de aplicativo que usa essa suposição.</span><span class="sxs-lookup"><span data-stu-id="c0df6-161">Polling a table using a WHILE loop until a new row has been found is an example of an application pattern that uses this assumption.</span></span> <span data-ttu-id="c0df6-162">Com cada iteração do loop, a consulta considerará as atualizações mais recentes no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="c0df6-162">With each iteration of the loop, the query will see the latest updates in the database.</span></span>  
  
     <span data-ttu-id="c0df6-163">**Diretriz:** Se um aplicativo precisar sondar uma tabela com otimização de memória para obter as linhas mais recentes gravadas na tabela, mova o loop de sondagem fora do escopo da transação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-163">**Guideline:** If an application needs to poll a memory-optimized table to obtain the most recent rows written to the table, move the polling loop outside the scope of the transaction.</span></span>  
  
     <span data-ttu-id="c0df6-164">Este é um padrão de aplicativo de exemplo que usa essa suposição.</span><span class="sxs-lookup"><span data-stu-id="c0df6-164">The following is an example application pattern that uses this assumption.</span></span> <span data-ttu-id="c0df6-165">Sondando uma tabela através de um loop WHILE até que uma nova linha seja encontrada.</span><span class="sxs-lookup"><span data-stu-id="c0df6-165">Polling a table using a WHILE loop until a new row is found.</span></span> <span data-ttu-id="c0df6-166">Em cada iteração de loop, a consulta acessará as atualizações mais recentes no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="c0df6-166">In each loop iteration, the query will access the latest updates in the database.</span></span>  
  
 <span data-ttu-id="c0df6-167">O exemplo de script a seguir sonda uma tabela t1 até que ela tenha uma linha.</span><span class="sxs-lookup"><span data-stu-id="c0df6-167">The following example script polls a table t1 until it has a row.</span></span> <span data-ttu-id="c0df6-168">Em seguida, ele remove a linha única da tabela para processamento posterior.</span><span class="sxs-lookup"><span data-stu-id="c0df6-168">It then removes a single row from the table for further processing.</span></span>  
  
 <span data-ttu-id="c0df6-169">Observe que a lógica de sondagem precisa estar fora do escopo da transação, pois ela está usando o isolamento de instantâneo para acessar a tabela t1.</span><span class="sxs-lookup"><span data-stu-id="c0df6-169">Notice that the polling logic needs to be outside the scope of the transaction, as it is using snapshot isolation to access table t1.</span></span> <span data-ttu-id="c0df6-170">O uso da lógica de sondagem no escopo de uma transação criará uma transação demorada, que é uma prática incorreta.</span><span class="sxs-lookup"><span data-stu-id="c0df6-170">Using polling logic inside the scope of a transaction would create a long-running transaction, which is a bad practice.</span></span>  
  
```sql  
-- poll table  
WHILE NOT EXISTS (SELECT 1 FROM dbo.t1)  
BEGIN   
  -- if empty, wait and poll again  
  WAITFOR DELAY '00:00:01'  
END  
  
BEGIN TRANSACTION  
  DECLARE @id int  
  SELECT TOP 1 @id=id FROM dbo.t1 WITH (SNAPSHOT)  
  DELETE FROM dbo.t1 WITH (SNAPSHOT) WHERE id=@id  
  
  -- insert processing based on @id  
COMMIT  
```  
  
## <a name="locking-table-hints"></a><span data-ttu-id="c0df6-171">Dicas de bloqueio de tabela</span><span class="sxs-lookup"><span data-stu-id="c0df6-171">Locking Table Hints</span></span>  
 <span data-ttu-id="c0df6-172">Dicas de bloqueio ([dicas de tabela &#40;&#41;Transact-SQL ](/sql/t-sql/queries/hints-transact-sql-table)), como HOLDLOCK e xlock, podem ser usadas com tabelas baseadas em disco para ter [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] mais bloqueios do que o necessário para o nível de isolamento especificado.</span><span class="sxs-lookup"><span data-stu-id="c0df6-172">Locking hints ([Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)) such as HOLDLOCK and XLOCK can be used with disk-based tables to have [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] take more locks than are required for the specified isolation level.</span></span>  
  
 <span data-ttu-id="c0df6-173">As tabelas com otimização de memória não usam bloqueios.</span><span class="sxs-lookup"><span data-stu-id="c0df6-173">Memory-optimized tables do not use locks.</span></span> <span data-ttu-id="c0df6-174">Os níveis de isolamento superiores, como REPEATABLE READ e SERIALIZABLE, podem ser usados para declarar as garantias desejadas.</span><span class="sxs-lookup"><span data-stu-id="c0df6-174">Higher isolation levels such as REPEATABLE READ and SERIALIZABLE can be used to declare the desired guarantees.</span></span>  
  
 <span data-ttu-id="c0df6-175">Não há suporte para as dicas de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="c0df6-175">Locking hints are not supported.</span></span> <span data-ttu-id="c0df6-176">Em vez disso, declare as garantias exigidas através dos níveis de isolamento de transação.</span><span class="sxs-lookup"><span data-stu-id="c0df6-176">Instead, declare the required guarantees through the transaction isolation levels.</span></span> <span data-ttu-id="c0df6-177">(NOLOCK tem suporte porque o [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] não usa bloqueios em tabelas com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="c0df6-177">(NOLOCK is supported because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not take locks on memory-optimized tables.</span></span> <span data-ttu-id="c0df6-178">Observe que, em contraste com tabelas baseadas em disco, NOLOCK não implica o comportamento READ UNCOMMITTED para tabelas com otimização de memória.)</span><span class="sxs-lookup"><span data-stu-id="c0df6-178">Note that, in contrast to disk-based tables, NOLOCK does not imply READ UNCOMMITTED behavior for memory-optimized tables.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c0df6-179">Consulte Também</span><span class="sxs-lookup"><span data-stu-id="c0df6-179">See Also</span></span>  
 <span data-ttu-id="c0df6-180">[Noções básicas sobre transações em tabelas com otimização de memória](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="c0df6-180">[Understanding Transactions on Memory-Optimized Tables](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span></span>  
 <span data-ttu-id="c0df6-181">[Diretrizes para a lógica de repetição para transações em tabelas com otimização de memória](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="c0df6-181">[Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span></span>  
 [<span data-ttu-id="c0df6-182">Níveis de isolamento da transação</span><span class="sxs-lookup"><span data-stu-id="c0df6-182">Transaction Isolation Levels</span></span>](../../2014/database-engine/transaction-isolation-levels.md)  
  
  
