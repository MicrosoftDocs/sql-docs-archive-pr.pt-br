---
title: Determinando a contagem de buckets correta para os índices de hash | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 6d1ac280-87db-4bd8-ad43-54353647d8b5
author: stevestein
ms.author: sstein
ms.openlocfilehash: e0579a98e3302b6944f68ca449d3e7cda0ecc01d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87571557"
---
# <a name="determining-the-correct-bucket-count-for-hash-indexes"></a><span data-ttu-id="f7ab6-102">Determinando o número de buckets correto para índices de hash não clusterizados</span><span class="sxs-lookup"><span data-stu-id="f7ab6-102">Determining the Correct Bucket Count for Hash Indexes</span></span>
  <span data-ttu-id="f7ab6-103">Você deve especificar um valor para o parâmetro `BUCKET_COUNT` quando cria a tabela com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-103">You must specify a value for the `BUCKET_COUNT` parameter when you create the memory-optimized table.</span></span> <span data-ttu-id="f7ab6-104">Este tópico faz recomendações para determinar o valor apropriado para o parâmetro `BUCKET_COUNT`.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-104">This topic makes recommendations for determining the appropriate value for the `BUCKET_COUNT` parameter.</span></span> <span data-ttu-id="f7ab6-105">Se você não puder determinar o número de buckets correto, use um índice não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-105">If you cannot determine the correct bucket count, use a nonclustered index instead.</span></span>  <span data-ttu-id="f7ab6-106">Um valor incorreto de `BUCKET_COUNT`, especialmente muito baixo, pode afetar significativamente o desempenho da carga de trabalho, bem como o tempo de recuperação do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-106">An incorrect `BUCKET_COUNT` value, especially one that is too low, can significantly impact workload performance, as well as recovery time of the database.</span></span> <span data-ttu-id="f7ab6-107">É melhor superestimar o número de buckets.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-107">It is better to overestimate the bucket count.</span></span>  
  
 <span data-ttu-id="f7ab6-108">As chaves de índice duplicadas podem reduzir o desempenho com um índice de hash porque as chaves com hash para o mesmo bucket, fazendo com que a cadeia de bucket aumente.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-108">Duplicate index keys can decrease performance with a hash index because the keys are hashed to the same bucket, causing that bucket's chain to increase.</span></span>  
  
 <span data-ttu-id="f7ab6-109">Para obter mais informações sobre índices de hash não clusterizados, consulte [Hash Indexes](hash-indexes.md) and [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="f7ab6-109">For more information about nonclustered hash indexes, see [Hash Indexes](hash-indexes.md) and [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="f7ab6-110">Uma tabela de hash é alocada para cada índice de hash em uma tabela com otimização de memória.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-110">One hash table is allocated for each hash index on a memory-optimized table.</span></span> <span data-ttu-id="f7ab6-111">O tamanho da tabela de hash alocada para um índice é especificado pelo `BUCKET_COUNT` parâmetro em [CREATE TABLE &#40;TRANSACT-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) ou [criar tipo &#40;&#41;do Transact-SQL ](/sql/t-sql/statements/create-type-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="f7ab6-111">The size of the hash table allocated for an index is specified by the `BUCKET_COUNT` parameter in [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) or [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span> <span data-ttu-id="f7ab6-112">O número de buckets será arredondado internamente até a próxima potência de dois.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-112">The bucket count will internally be rounded up to the next power of two.</span></span> <span data-ttu-id="f7ab6-113">Por exemplo, especificar um número de buckets 300.000 resultará em um número real de buckets 524.288.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-113">For example, specifying a bucket count of 300,000 will result in an actual bucket count of 524,288.</span></span>  
  
 <span data-ttu-id="f7ab6-114">Para obter links para um artigo e vídeo sobre contas buckets, consulte [Como determinar a contagem de buckets correta para índices de hash (OLTP na memória)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span><span class="sxs-lookup"><span data-stu-id="f7ab6-114">For links to an article and video on bucket count, see [How to determine the right bucket count for hash indexes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span></span>  
  
## <a name="recommendations"></a><span data-ttu-id="f7ab6-115">Recomendações</span><span class="sxs-lookup"><span data-stu-id="f7ab6-115">Recommendations</span></span>  
 <span data-ttu-id="f7ab6-116">Na maioria dos casos, o número de buckets deve estar entre 1 e 2 vezes o número de valores distintos na chave de índice.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-116">In most cases the bucket count should be between 1 and 2 times the number of distinct values in the index key.</span></span> <span data-ttu-id="f7ab6-117">Se a chave de índice contiver muitos valores duplicados (há, em média, mais de 10 linhas para cada valor de chave de índice), use um índice não clusterizado</span><span class="sxs-lookup"><span data-stu-id="f7ab6-117">If the index key contains a lot of duplicate values, on average there are more than 10 rows for each index key value, use a nonclustered index instead</span></span>  
  
 <span data-ttu-id="f7ab6-118">Você não pode sempre prever quantos valores determinada chave de índice tem ou terá.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-118">You may not always be able to predict how many values a particular index key may have or will have.</span></span> <span data-ttu-id="f7ab6-119">O desempenho deve ser aceitável se o valor `BUCKET_COUNT` é até 5 vezes o número real de valores de chave.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-119">Performance should be acceptable if the `BUCKET_COUNT` value is within 5 times of the actual number of key values.</span></span>  
  
 <span data-ttu-id="f7ab6-120">Para determinar o número de chaves de índice exclusivo nos dados existentes, use consultas semelhantes aos seguintes exemplos:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-120">To determine the number of unique index keys in existing data, use queries similar to the following examples:</span></span>  
  
### <a name="primary-key-and-unique-indexes"></a><span data-ttu-id="f7ab6-121">Chave primária e índices exclusivos</span><span class="sxs-lookup"><span data-stu-id="f7ab6-121">Primary Key and Unique Indexes</span></span>  
 <span data-ttu-id="f7ab6-122">Como o índice de chave primária é exclusivo, o número de valores distintos na chave corresponde ao número de linhas na tabela.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-122">Because the primary key index is unique, the number of distinct values in the key corresponds to the number of rows in the table.</span></span> <span data-ttu-id="f7ab6-123">Para obter uma chave primária de exemplo em (SalesOrderID, SalesOrderDetailID) na tabela Sales.SalesOrderDetail no banco de dados AdventureWorks, emita a seguinte consulta para calcular o número de valores de chave primária distintos, que corresponde ao número de linhas na tabela:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-123">For an example primary key on (SalesOrderID, SalesOrderDetailID) in the table Sales.SalesOrderDetail in the AdventureWorks database, issue the following query to calculate the number of distinct primary key values, which corresponds to the number of rows in the table:</span></span>  
  
```sql  
SELECT COUNT(*) AS [row count]   
FROM Sales.SalesOrderDetail  
```  
  
 <span data-ttu-id="f7ab6-124">Essa consulta mostra uma contagem de linhas de 121.317.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-124">This query shows a row count of 121,317.</span></span> <span data-ttu-id="f7ab6-125">Use um número de buckets de 240.000 caso a contagem de linhas não seja alterada significativamente.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-125">Use a bucket count of 240,000 if the row count will not change significantly.</span></span> <span data-ttu-id="f7ab6-126">Use um número de buckets de 480.000 se esperar que o número de ordens de venda na tabela quadruplique.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-126">Use a bucket count of 480,000 if the number of sales orders in the table is expected to quadruple.</span></span>  
  
### <a name="non-unique-indexes"></a><span data-ttu-id="f7ab6-127">Índices não exclusivos.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-127">Non-Unique Indexes</span></span>  
 <span data-ttu-id="f7ab6-128">Para outros índices, como, por exemplo um índice de várias colunas em (SpecialOfferID, ProductID), emita a seguinte consulta para determinar o número de valores de chaves de índice exclusivo:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-128">For other indexes, for example a multi-column index on (SpecialOfferID, ProductID), issue the following query to determine the number of unique index key values:</span></span>  
  
```sql  
SELECT COUNT(*) AS [SpecialOfferID_ProductID index key count]  
FROM   
   (SELECT DISTINCT SpecialOfferID, ProductID   
    FROM Sales.SalesOrderDetail) t  
```  
  
 <span data-ttu-id="f7ab6-129">Esta consulta retorna uma contagem de chaves de índice para (SpecialOfferID, ProductID) de 484, indicando que um índice não clusterizado não deve ser usado em lugar de um índice de hash não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-129">This query returns an index key count for (SpecialOfferID, ProductID) of 484, indicating a that a nonclustered index should be used instead of a nonclustered hash index.</span></span>  
  
### <a name="determining-the-number-of-duplicates"></a><span data-ttu-id="f7ab6-130">Determinando o número de duplicatas</span><span class="sxs-lookup"><span data-stu-id="f7ab6-130">Determining the Number of Duplicates</span></span>  
 <span data-ttu-id="f7ab6-131">Para determinar o número médio de valores duplicados para um valor de chave de índice, divida o número total de linhas pelo número de chaves de índice exclusivo.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-131">To determine the average number of duplicate values for an index key value, divide the total number of rows by the number of unique index keys.</span></span>  
  
 <span data-ttu-id="f7ab6-132">Para o índice de exemplo em (SpecialOfferID, ProductID), isso resulta em 121317/484 = 251.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-132">For the example index on (SpecialOfferID, ProductID), this leads to 121317 / 484 = 251.</span></span> <span data-ttu-id="f7ab6-133">Isso significa que valores de chave de índice têm uma média de 251 e, portanto, devem ser um índice não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-133">This means index key values have an average of 251, and thus this should be a nonclustered index.</span></span>  
  
## <a name="troubleshooting-the-bucket-count"></a><span data-ttu-id="f7ab6-134">Solucionando problemas no número de buckets</span><span class="sxs-lookup"><span data-stu-id="f7ab6-134">Troubleshooting the Bucket Count</span></span>  
 <span data-ttu-id="f7ab6-135">Para solucionar problemas de contagem de buckets em tabelas com otimização de memória, use [Sys. dm_db_xtp_hash_index_stats &#40;&#41;Transact-SQL](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) para obter estatísticas sobre os buckets vazios e o comprimento das cadeias de linhas.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-135">To troubleshoot bucket count issues in memory-optimized tables, use [sys.dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) to obtain statistics about the empty buckets and the length of row chains.</span></span> <span data-ttu-id="f7ab6-136">A consulta a seguir pode ser usada para obter estatísticas sobre todos os índices de hash no banco de dados atual.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-136">The following query can be used to obtain statistics about all the hash indexes in the current database.</span></span> <span data-ttu-id="f7ab6-137">A consulta poderá levar alguns minutos para ser executada se houver grandes tabelas no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-137">The query can take several minutes to run if there are large tables in the database.</span></span>  
  
```sql  
SELECT   
   object_name(hs.object_id) AS 'object name',   
   i.name as 'index name',   
   hs.total_bucket_count,  
   hs.empty_bucket_count,  
   floor((cast(empty_bucket_count as float)/total_bucket_count) * 100) AS 'empty_bucket_percent',  
   hs.avg_chain_length,   
   hs.max_chain_length  
FROM sys.dm_db_xtp_hash_index_stats AS hs   
   JOIN sys.indexes AS i   
   ON hs.object_id=i.object_id AND hs.index_id=i.index_id  
```  
  
 <span data-ttu-id="f7ab6-138">Os dois indicadores principais de integridade do índice de hash são:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-138">The two key indicators of hash index health are:</span></span>  
  
 <span data-ttu-id="f7ab6-139">*empty_bucket_percent*</span><span class="sxs-lookup"><span data-stu-id="f7ab6-139">*empty_bucket_percent*</span></span>  
 <span data-ttu-id="f7ab6-140">*empty_bucket_percent* indica o número de buckets vazios no índice de hash.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-140">*empty_bucket_percent* indicates the number of empty buckets in the hash index.</span></span>  
  
 <span data-ttu-id="f7ab6-141">Se *empty_bucket_percent* for menor que 10 por cento, é provável que o número de buckets seja muito baixo.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-141">If *empty_bucket_percent* is less than 10 percent, the bucket count is likely to be too low.</span></span> <span data-ttu-id="f7ab6-142">O ideal é que *empty_bucket_percent* seja 33 por cento ou mais.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-142">Ideally, the *empty_bucket_percent* should be 33 percent or greater.</span></span> <span data-ttu-id="f7ab6-143">Se o número de buckets corresponder ao número de valores de chave de índice, cerca de 1/3 dos bucket ficarão vazios, devido à distribuição de hash.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-143">If the bucket count matches the number of index key values, about 1/3 of the buckets is empty, due to hash distribution.</span></span>  
  
 <span data-ttu-id="f7ab6-144">*avg_chain_length*</span><span class="sxs-lookup"><span data-stu-id="f7ab6-144">*avg_chain_length*</span></span>  
 <span data-ttu-id="f7ab6-145">*avg_chain_length* indica o comprimento médio das cadeias de linha nos buckets de hash.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-145">*avg_chain_length* indicates the average length of the row chains in the hash buckets.</span></span>  
  
 <span data-ttu-id="f7ab6-146">Se *avg_chain_length* é maior que 10 e *empty_bucket_percent* é maior que 10 por cento, provavelmente há muitos valores de chave de índice duplicados e um índice não clusterizado seria mais apropriado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-146">If *avg_chain_length* is greater than 10 and *empty_bucket_percent* is greater than 10 percent, there likely are many duplicate index key values and a nonclustered index would be more appropriate.</span></span> <span data-ttu-id="f7ab6-147">Um comprimento médio ideal de cadeia é 1.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-147">An average chain length of 1 is ideal.</span></span>  
  
 <span data-ttu-id="f7ab6-148">Há dois fatores que afetam o comprimento de cadeia:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-148">There are two factors that impact the chain length:</span></span>  
  
1.  <span data-ttu-id="f7ab6-149">Duplicatas; todas as linhas duplicadas são parte da mesma cadeia no índice de hash.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-149">Duplicates; all duplicate rows are part of the same chain in the hash index.</span></span>  
  
2.  <span data-ttu-id="f7ab6-150">Vários valores de chave são mapeados para o mesmo bucket.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-150">Multiple key values map to the same bucket.</span></span> <span data-ttu-id="f7ab6-151">Quanto menor o número de buckets, mais buckets terão diversos valores mapeados para eles.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-151">The lower the bucket count, the more buckets that will have multiple values mapped to them.</span></span>  
  
 <span data-ttu-id="f7ab6-152">Como exemplo, considere a seguinte tabela e script para inserir linhas de exemplo na tabela:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-152">As an example, consider the following table and script to insert sample rows in the table:</span></span>  
  
```sql  
CREATE TABLE [Sales].[SalesOrderHeader_test]  
(  
   [SalesOrderID] [uniqueidentifier] NOT NULL DEFAULT (newid()),  
   [OrderSequence] int NOT NULL,  
   [OrderDate] [datetime2](7) NOT NULL,  
   [Status] [tinyint] NOT NULL,  
  
PRIMARY KEY NONCLUSTERED HASH ([SalesOrderID]) WITH ( BUCKET_COUNT = 262144 ),  
INDEX IX_OrderSequence HASH (OrderSequence) WITH ( BUCKET_COUNT = 20000),  
INDEX IX_Status HASH ([Status]) WITH ( BUCKET_COUNT = 8),  
INDEX IX_OrderDate NONCLUSTERED ([OrderDate] ASC),  
)WITH ( MEMORY_OPTIMIZED = ON , DURABILITY = SCHEMA_AND_DATA )  
GO  
  
DECLARE @i int = 0  
BEGIN TRAN  
WHILE @i < 262144  
BEGIN  
   INSERT Sales.SalesOrderHeader_test (OrderSequence, OrderDate, [Status]) VALUES (@i, sysdatetime(), @i % 8)  
   SET @i += 1  
END  
COMMIT  
GO  
```  
  
 <span data-ttu-id="f7ab6-153">O script insere 262.144 linhas na tabela.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-153">The script inserts 262,144 rows in the table.</span></span> <span data-ttu-id="f7ab6-154">Ele insere valores exclusivos no índice de chave primária e em IX_OrderSequence.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-154">It inserts unique values in the primary key index and in IX_OrderSequence.</span></span> <span data-ttu-id="f7ab6-155">Ele insere muitos valores duplicados no índice IX_Status: o script gera apenas 8 valores distintos.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-155">It inserts a lot of duplicate values in the index IX_Status: the script only generates 8 distinct values.</span></span>  
  
 <span data-ttu-id="f7ab6-156">A saída da consulta de solução de problemas BUCKET_COUNT é a seguinte:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-156">The output of the BUCKET_COUNT troubleshooting query is as follows:</span></span>  
  
|<span data-ttu-id="f7ab6-157">nome do índice</span><span class="sxs-lookup"><span data-stu-id="f7ab6-157">index name</span></span>|<span data-ttu-id="f7ab6-158">total_bucket_count</span><span class="sxs-lookup"><span data-stu-id="f7ab6-158">total_bucket_count</span></span>|<span data-ttu-id="f7ab6-159">empty_bucket_count</span><span class="sxs-lookup"><span data-stu-id="f7ab6-159">empty_bucket_count</span></span>|<span data-ttu-id="f7ab6-160">empty_bucket_percent</span><span class="sxs-lookup"><span data-stu-id="f7ab6-160">empty_bucket_percent</span></span>|<span data-ttu-id="f7ab6-161">avg_chain_length</span><span class="sxs-lookup"><span data-stu-id="f7ab6-161">avg_chain_length</span></span>|<span data-ttu-id="f7ab6-162">max_chain_length</span><span class="sxs-lookup"><span data-stu-id="f7ab6-162">max_chain_length</span></span>|  
|----------------|--------------------------|--------------------------|----------------------------|------------------------|------------------------|  
|<span data-ttu-id="f7ab6-163">IX_Status</span><span class="sxs-lookup"><span data-stu-id="f7ab6-163">IX_Status</span></span>|<span data-ttu-id="f7ab6-164">8</span><span class="sxs-lookup"><span data-stu-id="f7ab6-164">8</span></span>|<span data-ttu-id="f7ab6-165">4</span><span class="sxs-lookup"><span data-stu-id="f7ab6-165">4</span></span>|<span data-ttu-id="f7ab6-166">50</span><span class="sxs-lookup"><span data-stu-id="f7ab6-166">50</span></span>|<span data-ttu-id="f7ab6-167">65536</span><span class="sxs-lookup"><span data-stu-id="f7ab6-167">65536</span></span>|<span data-ttu-id="f7ab6-168">65536</span><span class="sxs-lookup"><span data-stu-id="f7ab6-168">65536</span></span>|  
|<span data-ttu-id="f7ab6-169">IX_OrderSequence</span><span class="sxs-lookup"><span data-stu-id="f7ab6-169">IX_OrderSequence</span></span>|<span data-ttu-id="f7ab6-170">32768</span><span class="sxs-lookup"><span data-stu-id="f7ab6-170">32768</span></span>|<span data-ttu-id="f7ab6-171">13</span><span class="sxs-lookup"><span data-stu-id="f7ab6-171">13</span></span>|<span data-ttu-id="f7ab6-172">0</span><span class="sxs-lookup"><span data-stu-id="f7ab6-172">0</span></span>|<span data-ttu-id="f7ab6-173">8</span><span class="sxs-lookup"><span data-stu-id="f7ab6-173">8</span></span>|<span data-ttu-id="f7ab6-174">26</span><span class="sxs-lookup"><span data-stu-id="f7ab6-174">26</span></span>|  
|<span data-ttu-id="f7ab6-175">PK_SalesOrd_B14003C3F8FB3364</span><span class="sxs-lookup"><span data-stu-id="f7ab6-175">PK_SalesOrd_B14003C3F8FB3364</span></span>|<span data-ttu-id="f7ab6-176">262144</span><span class="sxs-lookup"><span data-stu-id="f7ab6-176">262144</span></span>|<span data-ttu-id="f7ab6-177">96319</span><span class="sxs-lookup"><span data-stu-id="f7ab6-177">96319</span></span>|<span data-ttu-id="f7ab6-178">36</span><span class="sxs-lookup"><span data-stu-id="f7ab6-178">36</span></span>|<span data-ttu-id="f7ab6-179">1</span><span class="sxs-lookup"><span data-stu-id="f7ab6-179">1</span></span>|<span data-ttu-id="f7ab6-180">8</span><span class="sxs-lookup"><span data-stu-id="f7ab6-180">8</span></span>|  
  
 <span data-ttu-id="f7ab6-181">Considere os três índices de hash nesta tabela:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-181">Consider the three hash indexes on this table:</span></span>  
  
-   <span data-ttu-id="f7ab6-182">IX_Status: 50 por cento dos buckets estão vazios, o que é bom.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-182">IX_Status: 50 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="f7ab6-183">Porém, o comprimento médio da cadeia é muito alto (65.536).</span><span class="sxs-lookup"><span data-stu-id="f7ab6-183">However, the average chain length is very high (65,536).</span></span> <span data-ttu-id="f7ab6-184">Isso indica um grande número de valores duplicados.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-184">This indicates a large number of duplicate values.</span></span> <span data-ttu-id="f7ab6-185">Portanto, usar um índice de hash não clusterizado não é apropriado nesse caso.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-185">Therefore, using a nonclustered hash index is not appropriate in this case.</span></span> <span data-ttu-id="f7ab6-186">Deve-se utilizar índice não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-186">A nonclustered index should be used instead.</span></span>  
  
-   <span data-ttu-id="f7ab6-187">IX_OrderSequence: 0 por cento dos buckets estão vazios, um valor muito baixo.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-187">IX_OrderSequence: 0 percent of the buckets are empty, which is too low.</span></span> <span data-ttu-id="f7ab6-188">Além disso, o comprimento médio de cadeia é 8.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-188">In addition, the average chain length is 8.</span></span> <span data-ttu-id="f7ab6-189">Como os valores nesse índice são exclusivos, isso significa que, em média, 8 valores são mapeados para cada bucket.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-189">As the values in this index are unique, this means on average 8 values are mapped to each bucket.</span></span> <span data-ttu-id="f7ab6-190">O número de buckets deve ser aumentado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-190">The bucket count should be increased.</span></span> <span data-ttu-id="f7ab6-191">Como a chave de índice tem 262.144 valores exclusivos, o número de buckets deve ser pelo menos 262.144.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-191">As the index key has 262,144 unique values, the bucket count should be at least 262,144.</span></span> <span data-ttu-id="f7ab6-192">Se é esperado um futuro crescimento, o número deve ser mais alto.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-192">If future growth is expected, the number should be higher.</span></span>  
  
-   <span data-ttu-id="f7ab6-193">Índice de chave primária (PK__SalesOrder...): 36 por cento dos buckets estão vazios, o que é bom.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-193">Primary key index (PK__SalesOrder...): 36 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="f7ab6-194">Além disso, o comprimento médio da cadeia é 1, o que também é bom.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-194">In addition the average chain length is 1, which is also good.</span></span> <span data-ttu-id="f7ab6-195">Nenhuma alteração necessária.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-195">No change needed.</span></span>  
  
 <span data-ttu-id="f7ab6-196">Para obter mais informações sobre como solucionar problemas nos índices de hash com otimização de memória, consulte [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="f7ab6-196">For more information on troubleshooting issues with your memory-optimized hash indexes, see [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span></span>  
  
## <a name="detailed-considerations-for-further-optimization"></a><span data-ttu-id="f7ab6-197">Considerações detalhadas para a otimização adicional</span><span class="sxs-lookup"><span data-stu-id="f7ab6-197">Detailed Considerations for Further Optimization</span></span>  
 <span data-ttu-id="f7ab6-198">Esta seção descreve considerações adicionais para otimizar o número de buckets.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-198">This section outlines further considerations for optimizing the bucket count.</span></span>  
  
 <span data-ttu-id="f7ab6-199">Para obter o melhor desempenho de índices de hash, equilibre a quantidade de memória alocada para a tabela de hash e o número de valores distintos na chave de índice.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-199">To achieve the best performance for hash indexes, balance the amount of memory allocated to the hash table and the number of distinct values in the index key.</span></span> <span data-ttu-id="f7ab6-200">Também há um equilíbrio entre o desempenho de pesquisas de ponto e as verificações de tabela:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-200">There is also a balance between the performance of point lookups and table scans:</span></span>  
  
-   <span data-ttu-id="f7ab6-201">Quanto mais alto o valor do número de buckets, mais buckets vazios existirão no índice.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-201">The higher the bucket count value, the more empty buckets there will be in the index.</span></span> <span data-ttu-id="f7ab6-202">Isso tem um impacto no uso da memória (8 bytes por bucket) e no desempenho de verificações de tabela, pois cada bucket é verificado como parte de uma verificação de tabela.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-202">This has an impact on memory usage (8 bytes per bucket) and the performance of table scans, as each bucket is scanned as part of a table scan.</span></span>  
  
-   <span data-ttu-id="f7ab6-203">Quanto menor o número de buckets, mais valores serão atribuídos a um único bucket.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-203">The lower the bucket count, the more values are assigned to a single bucket.</span></span> <span data-ttu-id="f7ab6-204">Isso reduz o desempenho para pesquisas e inserções de ponto, pois o [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] pode precisar atravessar vários valores em um único bucket para localizar o valor especificado pelo predicado de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-204">This decreases performance for point lookups and inserts, because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] may need to traverse several values in a single bucket to find the value specified by the search predicate.</span></span>  
  
 <span data-ttu-id="f7ab6-205">Se o número de buckets é significativamente menor que o número de chaves de índice exclusivo, muitos valores serão mapeadas para cada bucket.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-205">If the bucket count is significantly lower than the number of unique index keys, many values will map to each bucket.</span></span> <span data-ttu-id="f7ab6-206">Isso afeta o desempenho da maioria das operações de DML, especialmente pesquisas de ponto (pesquisas de chaves de índice individuais) e de operações de inserção.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-206">This degrades performance of most DML operations, particularly point lookups (lookups of individual index keys) and insert operations.</span></span> <span data-ttu-id="f7ab6-207">Por exemplo, você pode ver o desempenho baixo de consultas SELECT, e das operações UPDATE e DELETE com predicados de igualdade, que correspondem às colunas de chave do índice na cláusula WHERE.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-207">For example, you may see poor performance of SELECT queries and, UPDATE and DELETE operations with equality predicates matching the index key columns in the WHERE clause.</span></span> <span data-ttu-id="f7ab6-208">Um baixo número de buckets também afeta o tempo de recuperação do banco de dados, pois os índices são recriados na inicialização do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-208">A low bucket count will also affect the recovery time of the database, as the indexes are recreated on database startup.</span></span>  
  
### <a name="duplicate-index-key-values"></a><span data-ttu-id="f7ab6-209">Valores de chave de índice duplicados</span><span class="sxs-lookup"><span data-stu-id="f7ab6-209">Duplicate Index Key Values</span></span>  
 <span data-ttu-id="f7ab6-210">Os valores duplicados podem aumentar o impacto do desempenho de colisões de hash.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-210">Duplicate values can increase the performance impact of hash collisions.</span></span> <span data-ttu-id="f7ab6-211">Em geral, não há problema se cada chave de índice tem um número baixo de duplicatas.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-211">This is usually not a problem if each index key has a low number of duplicates.</span></span> <span data-ttu-id="f7ab6-212">Mas, isso poderá ser um problema se a discrepância entre o número de chaves de índice exclusivo e o número de linhas nas tabelas for muito grande.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-212">But this can be a problem if the discrepancy between the number of unique index keys and the number of rows in the tables becomes very large.</span></span>  
  
 <span data-ttu-id="f7ab6-213">Todas as linhas com a mesma chave de índice constarão na mesma cadeia duplicada.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-213">All rows with the same index key will go into the same duplicate chain.</span></span> <span data-ttu-id="f7ab6-214">Se várias chaves de índice estiverem no mesmo bucket devido a uma colisão de hash, o verificador de índice sempre precisará verificar a cadeia duplicada completa para ver o primeiro valor antes de localizar a primeira linha que corresponde ao segundo valor.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-214">If multiple index keys are in the same bucket due to a hash collision, index scanners always need to scan the full duplicate chain for the first value before they can locate the first row corresponding to the second value.</span></span> <span data-ttu-id="f7ab6-215">As chaves duplicadas também dificultam a localização da linha por parte da coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-215">Duplicate keys also make it more difficult for garbage collection to locate the row.</span></span> <span data-ttu-id="f7ab6-216">Por exemplo, se houver 1.000 duplicatas para qualquer chave e uma das linhas for excluída, o coletor de lixo precisará examinar a cadeia de 1.000 duplicatas para desvincular a linha do índice.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-216">For example, if there are 1,000 duplicates for any key and one of the rows is deleted, the garbage collector needs to scan the chain of 1,000 duplicates to unlink the row from the index.</span></span> <span data-ttu-id="f7ab6-217">Isso será verdadeiro mesmo se a consulta que localizou a exclusão tiver usado um índice mais eficaz (um índice de chave primária) para localizar a linha, porque o coletor de lixo precisa desvincular de cada índice</span><span class="sxs-lookup"><span data-stu-id="f7ab6-217">This is true even if the query that found the delete used a more efficient index (a primary key index) to locate the row, because the garbage collector needs to unlink from every index</span></span>  
  
 <span data-ttu-id="f7ab6-218">Para índices de hash, há duas maneiras de reduzir o trabalho causado por valores de chave de índice duplicados:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-218">For hash indexes, there are two ways to reduce the work caused by duplicate index key values:</span></span>  
  
-   <span data-ttu-id="f7ab6-219">Usar um índice não clusterizado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-219">Use a nonclustered index instead.</span></span> <span data-ttu-id="f7ab6-220">Você pode diminuir as duplicadas adicionando colunas à chave de índice sem exigir nenhuma alteração ao aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-220">You can decrease the duplicates by adding columns to the index key without requiring any changes to the application.</span></span>  
  
-   <span data-ttu-id="f7ab6-221">Especificar uma número de buckets alto demais para o índice.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-221">Specify a very high bucket count for the index.</span></span> <span data-ttu-id="f7ab6-222">Por exemplo, 20 a 100 vezes o número de chaves de índice exclusivo.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-222">For example, 20-to-100 times the number of unique index keys.</span></span> <span data-ttu-id="f7ab6-223">Isso reduzirá as colisões de hash.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-223">This will reduce hash collisions.</span></span>  
  
### <a name="small-tables"></a><span data-ttu-id="f7ab6-224">Tabelas pequenas</span><span class="sxs-lookup"><span data-stu-id="f7ab6-224">Small Tables</span></span>  
 <span data-ttu-id="f7ab6-225">Para tabelas menores, a utilização da memória não costuma ser uma preocupação, pois o tamanho do índice será pequeno comparado ao tamanho geral do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-225">For smaller tables, memory utilization is usually not a concern, as the size of the index will be small compared to the overall size of the database.</span></span>  
  
 <span data-ttu-id="f7ab6-226">Você deve fazer uma escolha com base no tipo de desempenho desejado:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-226">You must now make a choice based on the kind of performance you want:</span></span>  
  
-   <span data-ttu-id="f7ab6-227">Se as operações essenciais para o desempenho no índice forem predominantemente pesquisas de ponto e/ou operações de inserção, um número de buckets mais alto será apropriado para reduzir a probabilidade de colisões de hash.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-227">If the performance-critical operations on the index are predominantly point lookups and/or insert operations, a higher bucket count would be appropriate to reduce the likelihood of hash collisions.</span></span> <span data-ttu-id="f7ab6-228">A melhor opção é ter três vezes o número de linhas ou até mesmo mais.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-228">Three times the number of rows or even more would be the best option.</span></span>  
  
-   <span data-ttu-id="f7ab6-229">Se as verificações de índice completo forem as operações essenciais para o desempenho predominantes, use um número de buckets próximo ao número real de valores de chave de índice.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-229">If full index scans are the predominant performance-critical operations, use a bucket count that is close to the actual number of index key values.</span></span>  
  
### <a name="big-tables"></a><span data-ttu-id="f7ab6-230">Tabelas grandes</span><span class="sxs-lookup"><span data-stu-id="f7ab6-230">Big Tables</span></span>  
 <span data-ttu-id="f7ab6-231">Para tabelas grandes, a utilização de memória pode se tornar um problema.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-231">For large tables, memory utilization could become a concern.</span></span> <span data-ttu-id="f7ab6-232">Por exemplo, com uma tabela de linha de 250 milhões que tem quatro índices de hash, cada um com um número de buckets de 1.000.000.000, a sobrecarga para as tabelas de hash é 4 índices \* 1.000.000.000 buckets \* 8 bytes = 32 gigabytes de utilização de memória.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-232">For example, with a 250 million row table that has 4 hash indexes, each with a bucket count of one billion, the overhead for the hash tables is 4 indexes \* 1 billion buckets \* 8 bytes = 32 gigabytes of memory utilization.</span></span> <span data-ttu-id="f7ab6-233">Ao escolher um número de buckets equivalente a 250 milhões para cada um dos índices, a sobrecarga total das tabelas de hash será de 8 gigabytes.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-233">When choosing a bucket count of 250 million for each of the indexes, the total overhead for the hash tables will be 8 gigabytes.</span></span> <span data-ttu-id="f7ab6-234">Observe que isso é além dos 8 bytes de uso de memória que cada índice adiciona a cada linha individual, que é 8 gigabytes nesse cenário (4 índices \* 8 bytes \* 250 milhões linhas).</span><span class="sxs-lookup"><span data-stu-id="f7ab6-234">Note that this is in addition to the 8 bytes of memory usage each index adds to each individual row, which is 8 gigabytes in this scenario (4 indexes \* 8 bytes \* 250 million rows).</span></span>  
  
 <span data-ttu-id="f7ab6-235">As verificações completas de tabelas em geral não estão no caminho essencial para o desempenho para cargas de trabalho do OLTP.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-235">Full table scans are not usually in the performance-critical path for OLTP workloads.</span></span> <span data-ttu-id="f7ab6-236">Consequentemente, a escolha é entre a utilização de memória versus o desempenho da pesquisa de ponto e as operações de inserção:</span><span class="sxs-lookup"><span data-stu-id="f7ab6-236">Therefore, the choice is between memory utilization versus performance of point lookup and insert operations:</span></span>  
  
-   <span data-ttu-id="f7ab6-237">Caso a utilização de memória seja uma preocupação, escolha um número de buckets próximo ao número de valores de chave de índice.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-237">If memory utilization is a concern, choose a bucket count close to the number of index key values.</span></span> <span data-ttu-id="f7ab6-238">O número de buckets não deve ser significativamente menor do que o número de valores de chave de índice, pois isso afeta a maioria das operações de DML, bem como o tempo necessário para recuperar o banco de dados após a reinicialização do servidor.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-238">The bucket count should not be significantly lower than the number of index key values, as this impacts most DML operations as well the time it takes to recover the database after server restart.</span></span>  
  
-   <span data-ttu-id="f7ab6-239">Ao otimizar o desempenho para pesquisas de ponto, um número de buckets duas ou três vezes maior do que o número de valores de índice exclusivo seria apropriado.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-239">When optimizing the performance for point lookups, a higher bucket count of two or even three times the number of unique index values would be appropriate.</span></span> <span data-ttu-id="f7ab6-240">Um número maior de buckets significaria uma maior utilização de memória e a necessidade de mais tempo para realizar uma verificação de índice completo.</span><span class="sxs-lookup"><span data-stu-id="f7ab6-240">A higher bucket count would mean an increased memory utilization and an increase in the time required for a full index scan.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f7ab6-241">Consulte Também</span><span class="sxs-lookup"><span data-stu-id="f7ab6-241">See Also</span></span>  
 [<span data-ttu-id="f7ab6-242">Índices em tabelas com otimização de memória</span><span class="sxs-lookup"><span data-stu-id="f7ab6-242">Indexes on Memory-Optimized Tables</span></span>](../../2014/database-engine/indexes-on-memory-optimized-tables.md)  
  
  
